
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Informes Acad√©micos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --warning-color: #e74c3c;
            --text-color: #2c3e50;
            --light-gray: #ecf0f1;
            --border-color: #bdc3c7;
            --hover-color: #2980b9;
            --success-color: #27ae60;
            --info-color: #9b59b6;
            --dark-gray: #7f8c8d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
        }

        body {
            background-color: #f9f9f9;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            color: white;
            font-size: 24px;
            margin-bottom: 5px;
        }

        header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            font-weight: 500;
        }

        .tab.active {
            background-color: white;
            border-color: var(--border-color);
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }

        .tab:hover:not(.active) {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .tab-content {
            display: none;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .file-upload {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upload-box {
            border: 2px dashed var(--border-color);
            padding: 30px;
            text-align: center;
            border-radius: 5px;
            transition: all 0.3s ease;
            background-color: var(--light-gray);
        }

        .upload-box:hover {
            border-color: var(--primary-color);
            background-color: rgba(52, 152, 219, 0.05);
        }

        .upload-box p {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .file-btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-btn:hover {
            background-color: var(--hover-color);
        }

        .hidden {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            font-size: 14px;
        }

        .config-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 100%;
            overflow-x: auto;
        }

        .config-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-item label {
            font-weight: 500;
            font-size: 14px;
        }

        .config-item input, .config-item select, .config-item .flatpickr-input {
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }

        .config-item input:focus, .config-item select:focus, .config-item .flatpickr-input:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .weight-container {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            padding-bottom: 10px;
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .weight-item {
            display: flex;
            flex-direction: column;
            min-width: 200px;
            margin-bottom: 10px;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: 5px;
            border-left: 3px solid var(--primary-color);
        }

        .weight-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .weight-item-header h4 {
            font-size: 16px;
            color: var(--primary-color);
        }

        .weight-item-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .eval-date-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .eval-date-container label {
            font-size: 14px;
            font-weight: 500;
        }

        .competence-selector {
            margin-top: 10px;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .competence-selector h5 {
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 14px;
        }

        .competence-checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
        }

        .competence-checkbox {
            display: flex;
            align-items: center;
            padding: 3px 8px;
            background-color: var(--light-gray);
            border-radius: 3px;
            font-size: 12px;
        }

        .competence-checkbox input {
            margin-right: 5px;
        }

        .weight-actions {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .weight-validation {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        
        .field-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: 5px;
        }
        
        .field-checkbox {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .field-checkbox:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }
        
        .field-checkbox input {
            margin-right: 5px;
        }
        
        .field-checkbox.student-id {
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .field-checkbox.grade-field {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .weight-validation.valid {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--success-color);
            display: block;
        }

        .weight-validation.invalid {
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--warning-color);
            display: block;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn:hover {
            background-color: var(--hover-color);
        }

        .btn:disabled {
            background-color: var(--light-gray);
            color: var(--text-color);
            cursor: not-allowed;
        }

        .btn-success {
            background-color: var(--secondary-color);
        }

        .btn-success:hover {
            background-color: var(--success-color);
        }

        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-warning:hover {
            background-color: #c0392b;
        }

        .btn-info {
            background-color: var(--info-color);
        }

        .btn-info:hover {
            background-color: #8e44ad;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .students-list {
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .student-item {
            padding: 10px 15px;
            border-bottom: 1px solid var(--light-gray);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .student-item:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .student-item.selected {
            background-color: rgba(52, 152, 219, 0.2);
            border-left: 3px solid var(--primary-color);
        }

        .report-container {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .report-header {
            border-bottom: 2px solid var(--light-gray);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .report-body {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .report-section {
            margin-bottom: 20px;
        }

        .report-section h3 {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var(--light-gray);
        }

        .grades-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .grades-table th, .grades-table td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
        }

        .grades-table th {
            background-color: var(--light-gray);
            font-weight: 500;
        }

        .chart-container {
            height: 300px;
            margin-bottom: 20px;
        }

        .competence-container {
            margin-top: 20px;
        }

        .competence-item {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: rgba(52, 152, 219, 0.1);
        }

        .competence-progress {
            margin-top: 5px;
            background-color: var(--light-gray);
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        .competence-progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
        }

        .prediction-container {
            padding: 15px;
            background-color: rgba(46, 204, 113, 0.1);
            border-radius: 4px;
            margin-top: 20px;
        }

        .prediction-value {
            font-size: 18px;
            font-weight: 500;
            color: var(--secondary-color);
            margin-top: 10px;
        }

        .export-options {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .group-report-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 500;
            color: var(--primary-color);
        }

        .stat-description {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .risk-students {
            margin-top: 20px;
        }

        .risk-students h3 {
            margin-bottom: 10px;
        }

        .risk-student-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var(--light-gray);
        }

        .risk-student-item .name {
            font-weight: 500;
        }

        .risk-student-item .grade {
            color: var(--warning-color);
        }

        .filter-container {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 4px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }

        .evaluation-report {
            margin-top: 20px;
        }

        .indicator {
            margin-top: 5px;
            padding-left: 20px;
            font-size: 14px;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            border: 5px solid var(--light-gray);
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .message.error {
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--warning-color);
        }

        .message.success {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--success-color);
        }

        .message.info {
            background-color: rgba(52, 152, 219, 0.2);
            color: var(--primary-color);
        }

        .competence-mapping-container {
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }

        .competence-mapping-header {
            background-color: var(--light-gray);
            padding: 10px 15px;
            font-weight: 500;
        }

        .competence-mapping-body {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .competence-mapping-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }

        .competence-mapping-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .competence-mapping-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .competence-mapping-title h4 {
            font-size: 16px;
            color: var(--primary-color);
        }

        .competence-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .competence-tag {
            background-color: rgba(52, 152, 219, 0.1);
            color: var(--primary-color);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
        }

        .date-tag {
            background-color: rgba(155, 89, 182, 0.1);
            color: var(--info-color);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .timeline-container {
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .timeline-header {
            margin-bottom: 20px;
        }

        .timeline {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
        }

        .timeline::after {
            content: '';
            position: absolute;
            width: 6px;
            background-color: var(--light-gray);
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -3px;
        }

        .timeline-item {
            padding: 10px 40px;
            position: relative;
            background-color: inherit;
            width: 50%;
        }

        .timeline-item:nth-child(odd) {
            left: 0;
        }

        .timeline-item:nth-child(even) {
            left: 50%;
        }

        .timeline-content {
            padding: 15px;
            background-color: white;
            position: relative;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--primary-color);
        }

        .timeline-item:nth-child(even) .timeline-content {
            border-left: none;
            border-right: 4px solid var(--secondary-color);
        }

        .timeline-content h3 {
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .timeline-item:nth-child(even) .timeline-content h3 {
            color: var(--secondary-color);
        }

        .timeline-date {
            color: var(--dark-gray);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .timeline-item::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border: 4px solid var(--primary-color);
            top: 15px;
            right: -12px;
            border-radius: 50%;
            z-index: 1;
        }

        .timeline-item:nth-child(even)::after {
            left: -12px;
            border-color: var(--secondary-color);
        }

        .preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            display: none;
        }

        .preview-content {
            background-color: white;
            border-radius: 5px;
            width: 80%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .preview-header {
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px 5px 0 0;
        }

        .preview-body {
            padding: 20px;
        }

        .preview-close {
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .preview-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 15px 20px;
            background-color: var(--light-gray);
            border-radius: 0 0 5px 5px;
        }

        .competence-filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .competence-filter-tag {
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .competence-filter-tag:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }

        .competence-filter-tag.active {
            background-color: var(--primary-color);
            color: white;
        }

        .date-range-filter {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-range-filter input {
            max-width: 120px;
        }

        @media (max-width: 768px) {
            .report-body {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-direction: column;
                border-bottom: none;
            }

            .tab {
                border-radius: 0;
                margin-right: 0;
                border: 1px solid var(--border-color);
                margin-bottom: 2px;
            }

            .tab.active {
                border-bottom: 1px solid var(--primary-color);
            }

            .config-row {
                grid-template-columns: 1fr;
            }

            .timeline::after {
                left: 31px;
            }

            .timeline-item {
                width: 100%;
                padding-left: 70px;
                padding-right: 25px;
            }

            .timeline-item:nth-child(even) {
                left: 0;
            }

            .timeline-item::after {
                left: 18px;
                top: 15px;
            }

            .timeline-item:nth-child(even)::after {
                left: 18px;
            }

            .timeline-item:nth-child(even) .timeline-content {
                border-right: none;
                border-left: 4px solid var(--secondary-color);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sistema de Informes Acad√©micos</h1>
            <p>Generaci√≥n de informes acad√©micos basados en competencias y evaluaciones</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="upload">Carga de Archivos</div>
            <div class="tab" data-tab="config">Configuraci√≥n</div>
            <div class="tab" data-tab="mapping">Mapeo de Competencias</div>
            <div class="tab" data-tab="individual">Reporte Individual</div>
            <div class="tab" data-tab="group">Reporte Grupal</div>
            <div class="tab" data-tab="evaluation">Reporte por Evaluaci√≥n</div>
            <div class="tab" data-tab="timeline">L√≠nea de Tiempo</div>
        </div>

        <div id="messageContainer"></div>

        <!-- Tab: Carga de Archivos -->
        <div class="tab-content active" id="upload">
            <div class="file-upload">
                <div class="upload-box">
                    <p>Archivo de Notas de Estudiantes (.xlsx, .xls, .csv)</p>
                    <label class="file-btn">
                        Seleccionar Archivo
                        <input type="file" id="studentsFile" class="hidden" accept=".xlsx,.xls,.csv">
                    </label>
                    <div id="studentsFileInfo" class="file-info"></div>
                </div>

                <div class="upload-box">
                    <p>Archivo de Competencias y Criterios (.xlsx, .xls, .csv)</p>
                    <label class="file-btn">
                        Seleccionar Archivo
                        <input type="file" id="competencesFile" class="hidden" accept=".xlsx,.xls,.csv">
                    </label>
                    <div id="competencesFileInfo" class="file-info"></div>
                </div>

                <button id="loadFilesBtn" class="btn" disabled>Cargar Archivos</button>
            </div>
        </div>

        <!-- Tab: Configuraci√≥n -->
        <div class="tab-content" id="config">
            <div class="config-container">
                <div class="config-row">
                    <div class="config-item">
                        <label for="decimalPlaces">Decimales a mostrar</label>
                        <input type="number" id="decimalPlaces" min="2" value="2">
                    </div>

                    <div class="config-item">
                        <label for="passingGrade">Nota m√≠nima aprobatoria</label>
                        <input type="number" id="passingGrade" min="0" step="0.01" value="3.00">
                    </div>

                    <div class="config-item">
                        <label for="groupSelect">Grupo</label>
                        <select id="groupSelect">
                            <option value="">Seleccione un grupo</option>
                        </select>
                    </div>

                    <div class="config-item">
                        <label for="semesterSelect">Semestre/Periodo</label>
                        <select id="semesterSelect">
                            <option value="2025-1">2025-1</option>
                            
                        <option value="2024-2">2024-2</option>
                        <option value="2024-1">2024-1</option>
                        <option value="2023-2">2023-2</option>
</select>
</div>
</div>

<div class="config-row" id="fieldSelectionContainer">
<h3>Selecci√≥n de Campos</h3>
<p>Seleccione los campos que desea incluir en el an√°lisis:</p>
<div id="availableFields" class="field-selection">
<!-- Los campos disponibles se generar√°n din√°micamente -->
</div>
</div>

<h3>Pesos y Fechas de Evaluaciones</h3>
<div class="weight-container" id="weightContainer">
<!-- Los pesos de evaluaci√≥n se generar√°n din√°micamente -->
</div>

<div class="weight-actions">
<button id="distributeWeightsBtn" class="btn">Distribuir Pesos Equitativamente</button>
<button id="clearWeightsBtn" class="btn btn-warning">Limpiar Pesos</button>
</div>

<div id="weightValidation" class="weight-validation">
Los pesos deben sumar exactamente 100%
</div>

<button id="saveConfigBtn" class="btn btn-success">Guardar Configuraci√≥n</button>
</div>
</div>

<!-- Tab: Mapeo de Competencias -->
<div class="tab-content" id="mapping">
<div class="config-row">
<div class="config-item">
<label for="competenceSheetSelect">Hoja de Competencias</label>
<select id="competenceSheetSelect">
<option value="">Seleccione una hoja</option>
</select>
</div>
<div class="config-item">
<label for="competenceMappingGroup">Filtrar por grupo</label>
<select id="competenceMappingGroup">
<option value="">Todos los grupos</option>
</select>
</div>
</div>

<div class="competence-mapping-container">
<div class="competence-mapping-header">
Mapeo de Competencias a Evaluaciones
</div>
<div class="competence-mapping-body" id="competenceMappingBody">
<!-- El mapeo de competencias se generar√° din√°micamente -->
</div>
</div>

<button id="updateMappingBtn" class="btn btn-success" style="margin-top: 20px;">Actualizar Mapeo</button>
</div>

<!-- Tab: Reporte Individual -->
<div class="tab-content" id="individual">
<div class="filter-container">
<div class="filter-item">
<label for="studentSearch">Buscar estudiante</label>
<input type="text" id="studentSearch" placeholder="Nombre del estudiante">
</div>

<div class="filter-item">
<label>Filtrar por competencia</label>
<div id="individualCompetenceFilter" class="competence-filter-group">
<!-- Los filtros de competencia se generar√°n din√°micamente -->
</div>
</div>

<div class="filter-item">
<label>Rango de fechas</label>
<div class="date-range-filter">
<input type="text" id="individualStartDate" placeholder="Fecha inicial" class="flatpickr-input">
<span>a</span>
<input type="text" id="individualEndDate" placeholder="Fecha final" class="flatpickr-input">
</div>
</div>
</div>

<div class="students-list" id="studentsList">
<!-- La lista de estudiantes se generar√° din√°micamente -->
</div>

<div class="report-container" id="individualReport">
<div class="report-header">
<h2 id="studentName">Seleccione un estudiante</h2>
<div id="studentInfo" style="color: var(--dark-gray);"></div>
</div>
<div class="report-body">
<div class="report-section">
<h3>Evaluaciones</h3>
<table class="grades-table" id="gradesTable">
<thead>
    <tr>
        <th>Evaluaci√≥n</th>
        <th>Fecha</th>
        <th>Nota</th>
        <th>Peso</th>
        <th>Contribuci√≥n</th>
    </tr>
</thead>
<tbody>
    <!-- Las evaluaciones se generar√°n din√°micamente -->
</tbody>
</table>
</div>

<div class="report-section">
<h3>Competencias</h3>
<div class="competence-container" id="competenceContainer">
<!-- Las competencias se generar√°n din√°micamente -->
</div>
</div>
</div>

<div class="prediction-container" id="predictionContainer">
<h3>Predicci√≥n</h3>
<p>Para aprobar el curso, este estudiante necesita obtener:</p>
<div id="predictionResults">
<!-- Las predicciones se generar√°n din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewIndividualBtn" class="btn btn-info">Vista Previa</button>
<button id="exportPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printBtn" class="btn">Imprimir</button>
</div>
</div>
</div>

<!-- Tab: Reporte Grupal -->
<div class="tab-content" id="group">
<div class="filter-container">
<div class="filter-item">
<label for="performanceFilter">Filtrar por rendimiento</label>
<select id="performanceFilter">
<option value="all">Todos</option>
<option value="high">Alto</option>
<option value="medium">Medio</option>
<option value="low">Bajo</option>
</select>
</div>

<div class="filter-item">
<label for="competenceFilter">Filtrar por competencia</label>
<select id="competenceFilter">
<option value="all">Todas</option>
</select>
</div>

<div class="filter-item">
<label>Rango de fechas</label>
<div class="date-range-filter">
<input type="text" id="groupStartDate" placeholder="Fecha inicial" class="flatpickr-input">
<span>a</span>
<input type="text" id="groupEndDate" placeholder="Fecha final" class="flatpickr-input">
</div>
</div>
</div>

<div class="group-report-container" id="groupStatsContainer">
<!-- Las estad√≠sticas grupales se generar√°n din√°micamente -->
</div>

<div class="chart-container">
<canvas id="groupChart"></canvas>
</div>

<div class="chart-container">
<h3>Rendimiento por Competencia</h3>
<canvas id="competenceChart"></canvas>
</div>

<div class="risk-students" id="riskStudentsContainer">
<h3>Estudiantes en riesgo</h3>
<div id="riskStudentsList">
<!-- Los estudiantes en riesgo se generar√°n din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewGroupBtn" class="btn btn-info">Vista Previa</button>
<button id="exportGroupPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportGroupExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printGroupBtn" class="btn">Imprimir</button>
</div>
</div>

<!-- Tab: Reporte por Evaluaci√≥n -->
<div class="tab-content" id="evaluation">
<div class="filter-container">
<div class="filter-item">
<label for="evaluationSelect">Seleccionar evaluaci√≥n</label>
<select id="evaluationSelect">
<option value="">Seleccione una evaluaci√≥n</option>
</select>
</div>

<div class="filter-item">
<label for="evalCompetenceFilter">Filtrar por competencia</label>
<select id="evalCompetenceFilter">
<option value="all">Todas las competencias</option>
</select>
</div>
</div>

<div class="evaluation-report" id="evaluationReportContainer">
<!-- El reporte por evaluaci√≥n se generar√° din√°micamente -->
</div>

<div class="chart-container">
<canvas id="evaluationChart"></canvas>
</div>

<div class="chart-container">
<h3>Rendimiento por Competencia en esta Evaluaci√≥n</h3>
<canvas id="evalCompetenceChart"></canvas>
</div>

<div class="export-options">
<button id="previewEvalBtn" class="btn btn-info">Vista Previa</button>
<button id="exportEvalPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportEvalExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printEvalBtn" class="btn">Imprimir</button>
</div>
</div>

<!-- Tab: L√≠nea de Tiempo -->
<div class="tab-content" id="timeline">
<div class="filter-container">
<div class="filter-item">
<label for="timelineStudentSelect">Seleccionar estudiante</label>
<select id="timelineStudentSelect">
<option value="group">Rendimiento grupal</option>
</select>
</div>

<div class="filter-item">
<label for="timelineCompetenceFilter">Filtrar por competencia</label>
<select id="timelineCompetenceFilter">
<option value="all">Todas las competencias</option>
</select>
</div>
</div>

<div class="timeline-container">
<div class="timeline-header">
<h3>L√≠nea de Tiempo de Evaluaciones</h3>
</div>
<div class="timeline" id="evaluationTimeline">
<!-- La l√≠nea de tiempo se generar√° din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewTimelineBtn" class="btn btn-info">Vista Previa</button>
<button id="exportTimelinePdfBtn" class="btn">Exportar a PDF</button>
<button id="printTimelineBtn" class="btn">Imprimir</button>
</div>
</div>
</div>

<!-- Contenedor de Previsualizaci√≥n -->
<div class="preview-container" id="previewContainer">
<div class="preview-content">
<div class="preview-header">
<h2 id="previewTitle">Vista Previa</h2>
<span class="preview-close" id="previewClose">&times;</span>
</div>
<div class="preview-body" id="previewBody">
<!-- El contenido de previsualizaci√≥n se generar√° din√°micamente -->
</div>
<div class="preview-actions">
<button id="cancelPreviewBtn" class="btn btn-warning">Cancelar</button>
<button id="confirmExportBtn" class="btn btn-success">Confirmar Exportaci√≥n</button>
</div>
</div>
</div>

<div class="loading" id="loadingIndicator">
<div class="spinner"></div>
<p>Procesando datos...</p>
</div>

<script>
// Estado global de la aplicaci√≥n
const appState = {
studentsData: null,
competencesData: null,
competenceSheets: [],
config: {
decimalPlaces: 2,
passingGrade: 3.00,
weights: {},
dates: {},
selectedGroup: '',
semester: '2025-1',
selectedFields: [],
studentIdFields: []
},
processedData: {
students: [],
competences: [],
evaluations: [],
indicators: {},
competenceMappings: {}
},
currentStudent: null,
charts: {},
datepickers: {},
filters: {
individual: {
competences: [],
dateRange: { start: null, end: null }
},
group: {
performance: 'all',
competence: 'all',
dateRange: { start: null, end: null }
},
evaluation: {
selectedEval: '',
competence: 'all'
},
timeline: {
student: 'group',
competence: 'all'
}
},
exportData: {
type: '',
content: null,
filename: ''
}
};

// Elementos DOM
const elements = {
tabs: document.querySelectorAll('.tab'),
tabContents: document.querySelectorAll('.tab-content'),
studentsFile: document.getElementById('studentsFile'),
competencesFile: document.getElementById('competencesFile'),
studentsFileInfo: document.getElementById('studentsFileInfo'),
competencesFileInfo: document.getElementById('competencesFileInfo'),
loadFilesBtn: document.getElementById('loadFilesBtn'),
groupSelect: document.getElementById('groupSelect'),
semesterSelect: document.getElementById('semesterSelect'),
decimalPlaces: document.getElementById('decimalPlaces'),
passingGrade: document.getElementById('passingGrade'),
weightContainer: document.getElementById('weightContainer'),
weightValidation: document.getElementById('weightValidation'),
availableFields: document.getElementById('availableFields'),
distributeWeightsBtn: document.getElementById('distributeWeightsBtn'),
clearWeightsBtn: document.getElementById('clearWeightsBtn'),
saveConfigBtn: document.getElementById('saveConfigBtn'),
competenceSheetSelect: document.getElementById('competenceSheetSelect'),
competenceMappingGroup: document.getElementById('competenceMappingGroup'),
competenceMappingBody: document.getElementById('competenceMappingBody'),
updateMappingBtn: document.getElementById('updateMappingBtn'),
studentSearch: document.getElementById('studentSearch'),
individualCompetenceFilter: document.getElementById('individualCompetenceFilter'),
individualStartDate: document.getElementById('individualStartDate'),
individualEndDate: document.getElementById('individualEndDate'),
studentsList: document.getElementById('studentsList'),
studentName: document.getElementById('studentName'),
studentInfo: document.getElementById('studentInfo'),
gradesTable: document.getElementById('gradesTable'),
competenceContainer: document.getElementById('competenceContainer'),
predictionContainer: document.getElementById('predictionContainer'),
predictionResults: document.getElementById('predictionResults'),
previewIndividualBtn: document.getElementById('previewIndividualBtn'),
exportPdfBtn: document.getElementById('exportPdfBtn'),
exportExcelBtn: document.getElementById('exportExcelBtn'),
printBtn: document.getElementById('printBtn'),
performanceFilter: document.getElementById('performanceFilter'),
competenceFilter: document.getElementById('competenceFilter'),
groupStartDate: document.getElementById('groupStartDate'),
groupEndDate: document.getElementById('groupEndDate'),
groupStatsContainer: document.getElementById('groupStatsContainer'),
groupChart: document.getElementById('groupChart'),
competenceChart: document.getElementById('competenceChart'),
riskStudentsContainer: document.getElementById('riskStudentsContainer'),
riskStudentsList: document.getElementById('riskStudentsList'),
previewGroupBtn: document.getElementById('previewGroupBtn'),
exportGroupPdfBtn: document.getElementById('exportGroupPdfBtn'),
exportGroupExcelBtn: document.getElementById('exportGroupExcelBtn'),
printGroupBtn: document.getElementById('printGroupBtn'),
evaluationSelect: document.getElementById('evaluationSelect'),
evalCompetenceFilter: document.getElementById('evalCompetenceFilter'),
evaluationReportContainer: document.getElementById('evaluationReportContainer'),
evaluationChart: document.getElementById('evaluationChart'),
evalCompetenceChart: document.getElementById('evalCompetenceChart'),
previewEvalBtn: document.getElementById('previewEvalBtn'),
exportEvalPdfBtn: document.getElementById('exportEvalPdfBtn'),
exportEvalExcelBtn: document.getElementById('exportEvalExcelBtn'),
printEvalBtn: document.getElementById('printEvalBtn'),
timelineStudentSelect: document.getElementById('timelineStudentSelect'),
timelineCompetenceFilter: document.getElementById('timelineCompetenceFilter'),
evaluationTimeline: document.getElementById('evaluationTimeline'),
previewTimelineBtn: document.getElementById('previewTimelineBtn'),
exportTimelinePdfBtn: document.getElementById('exportTimelinePdfBtn'),
printTimelineBtn: document.getElementById('printTimelineBtn'),
previewContainer: document.getElementById('previewContainer'),
previewTitle: document.getElementById('previewTitle'),
previewBody: document.getElementById('previewBody'),
previewClose: document.getElementById('previewClose'),
cancelPreviewBtn: document.getElementById('cancelPreviewBtn'),
confirmExportBtn: document.getElementById('confirmExportBtn'),
loadingIndicator: document.getElementById('loadingIndicator'),
messageContainer: document.getElementById('messageContainer')
};

// Funciones auxiliares
const utils = {
// Mostrar mensaje
showMessage: (message, type = 'info') => {
if (!elements.messageContainer) return;

elements.messageContainer.innerHTML = `
<div class="message ${type}">
${message}
</div>
`;
setTimeout(() => {
if (elements.messageContainer) {
elements.messageContainer.innerHTML = '';
}
}, 5000);
},

// Mostrar cargando
showLoading: () => {
if (elements.loadingIndicator) {
elements.loadingIndicator.style.display = 'flex';
}
},

// Ocultar cargando
hideLoading: () => {
if (elements.loadingIndicator) {
elements.loadingIndicator.style.display = 'none';
}
},

// Formatear n√∫mero seg√∫n configuraci√≥n
formatNumber: (number) => {
if (number === undefined || number === null) return 'N/A';
const decimalPlaces = appState.config.decimalPlaces || 2;
return Number(number).toFixed(decimalPlaces);
},

// Formatear fecha
formatDate: (dateStr) => {
if (!dateStr) return 'No asignada';
try {
const date = new Date(dateStr);
if (isNaN(date.getTime())) return 'Fecha inv√°lida';
return date.toLocaleDateString('es-ES', { 
day: '2-digit', 
month: '2-digit', 
year: 'numeric' 
});
} catch (e) {
return 'Fecha inv√°lida';
}
},

// Verificar si los pesos suman 100%
validateWeights: () => {
const weights = appState.config.weights || {};
const sum = Object.values(weights).reduce((acc, val) => {
const num = parseFloat(val) || 0;
return acc + num;
}, 0);

// Tolerancia peque√±a para errores de redondeo
const isValid = Math.abs(sum - 100) < 0.001;

if (elements.weightValidation) {
elements.weightValidation.classList.toggle('valid', isValid);
elements.weightValidation.classList.toggle('invalid', !isValid);
elements.weightValidation.textContent = isValid
? "Los pesos suman 100% correctamente"
: `Los pesos suman ${sum.toFixed(1)}% (debe ser exactamente 100%)`;
}
return isValid;
},

// Calcular nota final ponderada para un estudiante (adaptada para reportes parciales)
calculateFinalGrade: (student, filterCompetences = [], dateRange = {}) => {
if (!student || !appState.config.weights) return 0;

let finalGrade = 0;
let totalWeight = 0;
let completedWeight = 0;

for (const evalKey in appState.config.weights) {
// Obtener el peso de la evaluaci√≥n
const weight = parseFloat(appState.config.weights[evalKey]) / 100 || 0;
totalWeight += weight;

// Verificar si debemos filtrar por competencia
if (filterCompetences.length > 0) {
const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
if (!evalCompetences.some(comp => filterCompetences.includes(comp))) {
continue;
}
}

// Verificar si debemos filtrar por fecha
if (dateRange.start && dateRange.end) {
const evalDate = appState.config.dates[evalKey];
if (evalDate) {
try {
    const date = new Date(evalDate);
    const start = new Date(dateRange.start);
    const end = new Date(dateRange.end);
    if (date < start || date > end) {
        continue;
    }
} catch (e) {
    console.error('Error al comparar fechas:', e);
}
}
}

if (student[evalKey] !== undefined && student[evalKey] !== null) {
const grade = parseFloat(student[evalKey]) || 0;
finalGrade += grade * weight;
completedWeight += weight;
}
}

// Si no hay evaluaciones completadas, retornar 0
if (completedWeight === 0) return 0;

// Si est√°n todas las evaluaciones completadas o no hay filtros, usar el peso total
if (completedWeight === totalWeight || (filterCompetences.length === 0 && !dateRange.start && !dateRange.end)) {
return finalGrade / totalWeight * 100;
}

// Para reportes parciales, calcular proporcionalmente al peso de las evaluaciones completadas
return finalGrade / completedWeight * 100;
},

// Calcular estad√≠sticas de grupo
calculateGroupStats: (students, filterCompetences = [], dateRange = {}) => {
if (!students || students.length === 0) return null;

const grades = students.map(student => 
utils.calculateFinalGrade(student, filterCompetences, dateRange)
).filter(grade => grade > 0); // Filtrar estudiantes sin evaluaciones

if (grades.length === 0) return null;

const sum = grades.reduce((acc, grade) => acc + grade, 0);
const avg = sum / grades.length;
const min = Math.min(...grades);
const max = Math.max(...grades);

// Calcular desviaci√≥n est√°ndar
const squaredDiffs = grades.map(grade => Math.pow(grade - avg, 2));
const avgSquaredDiff = squaredDiffs.reduce((acc, val) => acc + val, 0) / grades.length;
const stdDev = Math.sqrt(avgSquaredDiff);

// Contar estudiantes por debajo de la nota m√≠nima
const passingGrade = appState.config.passingGrade || 3.0;
const studentsAtRisk = grades.filter(grade => grade < passingGrade).length;

return {
totalStudents: students.length,
evaluatedStudents: grades.length,
average: avg,
min: min,
max: max,
stdDev: stdDev,
studentsAtRisk: studentsAtRisk
};
},

// Predecir nota requerida en evaluaciones restantes
predictRequiredGrade: (student, filterCompetences = []) => {
if (!student || !appState.config.weights) {
return { possible: false, message: "No hay datos suficientes para realizar una predicci√≥n" };
}

// Obtener evaluaciones pendientes (no tienen nota asignada)
const pendingEvaluations = [];
let completedWeight = 0;
let currentContribution = 0;

for (const evalKey in appState.config.weights) {
// Verificar si debemos filtrar por competencia
if (filterCompetences.length > 0) {
const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
if (!evalCompetences.some(comp => filterCompetences.includes(comp))) {
continue;
}
}

const weight = parseFloat(appState.config.weights[evalKey]) / 100 || 0;

if (student[evalKey] !== undefined && student[evalKey] !== null) {
// Evaluaci√≥n ya completada
const grade = parseFloat(student[evalKey]) || 0;
currentContribution += grade * weight;
completedWeight += weight;
} else {
// Evaluaci√≥n pendiente
pendingEvaluations.push(evalKey);
}
}

// Calcular peso de evaluaciones pendientes
const pendingWeight = 1 - completedWeight;

if (pendingWeight <= 0) {
const finalGrade = currentContribution / completedWeight;
const passingGrade = appState.config.passingGrade || 3.0;

if (finalGrade >= passingGrade) {
return {
possible: true,
message: "El estudiante ya tiene nota aprobatoria con las evaluaciones actuales.",
requiredGrade: 0,
evaluations: []
};
} else {
return {
possible: false,
message: "El estudiante no tiene evaluaciones pendientes y su nota actual no es aprobatoria."
};
}
}

// Calcular la nota m√≠nima requerida para aprobar
const passingGrade = appState.config.passingGrade || 3.0;
const requiredContribution = passingGrade - currentContribution;

// Calcular la nota que necesitar√≠a en cada evaluaci√≥n pendiente
const requiredGrade = requiredContribution / pendingWeight;

if (requiredGrade > 5) {
return {
possible: false,
message: `No es posible alcanzar la nota m√≠nima de ${passingGrade.toFixed(1)} con las evaluaciones pendientes.`
};
}

return {
possible: true,
message: `El estudiante necesita obtener la siguiente nota en ${pendingEvaluations.length > 1 ? 'cada una de las evaluaciones' : 'la evaluaci√≥n'} pendientes:`,
requiredGrade: requiredGrade,
evaluations: pendingEvaluations
};
},

// Calcular rendimiento por competencia
calculateCompetencePerformance: (students, competences, dateRange = {}) => {
const compPerformance = {};

// Inicializar estructura para cada competencia
const uniqueCompetences = utils.getUniqueCompetences();
uniqueCompetences.forEach(comp => {
compPerformance[comp] = {
totalStudents: 0,
passStudents: 0,
sum: 0,
count: 0,
average: 0
};
});

// Analizar cada estudiante
students.forEach(student => {
uniqueCompetences.forEach(comp => {
// Obtener evaluaciones relacionadas con esta competencia
const relatedEvals = [];

for (const evalKey in appState.processedData.competenceMappings) {
const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];

if (evalCompetences.includes(comp)) {
    // Verificar filtro de fecha si es necesario
    if (dateRange.start && dateRange.end) {
        const evalDate = appState.config.dates[evalKey];
        if (evalDate) {
            try {
                const date = new Date(evalDate);
                const start = new Date(dateRange.start);
                const end = new Date(dateRange.end);
                if (date < start || date > end) {
                    continue;
                }
            } catch (e) {
                console.error('Error al comparar fechas:', e);
            }
        }
    }
    
    relatedEvals.push(evalKey);
}
}

// Calcular promedio de estudiante para esta competencia
let compSum = 0;
let evalCount = 0;

relatedEvals.forEach(evalName => {
if (student[evalName] !== undefined && student[evalName] !== null) {
    compSum += parseFloat(student[evalName]) || 0;
    evalCount++;
}
});

if (evalCount > 0) {
const studentAvg = compSum / evalCount;
compPerformance[comp].sum += studentAvg;
compPerformance[comp].count++;
compPerformance[comp].totalStudents++;

if (studentAvg >= appState.config.passingGrade) {
    compPerformance[comp].passStudents++;
}
}
});
});

// Calcular promedios finales
uniqueCompetences.forEach(comp => {
if (compPerformance[comp].count > 0) {
compPerformance[comp].average = compPerformance[comp].sum / compPerformance[comp].count;
}
});

return compPerformance;
},

// Calcular rendimiento por competencia en una evaluaci√≥n espec√≠fica
// john6
// Calcular rendimiento por competencia en una evaluaci√≥n espec√≠fica
calculateEvaluationCompetencePerformance: (students, evalName) => {
    const compPerformance = {};
    
    // Obtener las competencias asociadas a esta evaluaci√≥n
    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
    
    // Inicializar estructura para cada competencia
    evalCompetences.forEach(comp => {
        compPerformance[comp] = {
            totalStudents: 0,
            passStudents: 0,
            sum: 0,
            average: 0
        };
    });
    
    // Analizar cada estudiante
    students.forEach(student => {
        if (student[evalName] !== undefined && student[evalName] !== null) {
            const grade = parseFloat(student[evalName]) || 0;
            
            evalCompetences.forEach(comp => {
                compPerformance[comp].sum += grade;
                compPerformance[comp].totalStudents++;
                
                if (grade >= appState.config.passingGrade) {
                    compPerformance[comp].passStudents++;
                }
            });
        }
    });
    
    // Calcular promedios finales
    evalCompetences.forEach(comp => {
        if (compPerformance[comp].totalStudents > 0) {
            compPerformance[comp].average = compPerformance[comp].sum / compPerformance[comp].totalStudents;
        }
    });
    
    return compPerformance;
},

// Obtener evaluaciones filtradas por competencia
getFilteredEvaluations: (competenceFilter) => {
    if (!competenceFilter || competenceFilter === 'all') {
        return appState.processedData.evaluations || [];
    }

    return (appState.processedData.evaluations || []).filter(evalName => {
        const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
        return evalCompetences.includes(competenceFilter);
    });
},

// Obtener competencias √∫nicas
getUniqueCompetences: () => {
    const competences = new Set();

    if (!appState.processedData.competenceMappings) {
        return [];
    }

    // Recopilar todas las competencias de los mapeos
    Object.values(appState.processedData.competenceMappings).forEach(compList => {
        if (compList && compList.length) {
            compList.forEach(comp => competences.add(comp));
        }
    });

    return Array.from(competences);
},

// Mostrar vista previa
showPreview: (title, content, exportType, filename) => {
    if (!elements.previewContainer || !elements.previewTitle || !elements.previewBody) return;
    
    elements.previewTitle.textContent = title;
    elements.previewBody.innerHTML = content;
    elements.previewContainer.style.display = 'flex';
    
    // Guardar datos para exportaci√≥n
    appState.exportData = {
        type: exportType,
        content: content,
        filename: filename
    };
},

// Cerrar vista previa
closePreview: () => {
    if (elements.previewContainer) {
        elements.previewContainer.style.display = 'none';
    }
    if (elements.previewBody) {
        elements.previewBody.innerHTML = '';
    }
    appState.exportData = { type: '', content: null, filename: '' };
},

// Exportar a PDF
exportToPdf: (content, filename) => {
    utils.showLoading();
    
    setTimeout(() => {
        try {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            // Crear elemento temporal para renderizar el contenido
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = content;
            document.body.appendChild(tempDiv);
            
            // Aplicar estilos para mejor visualizaci√≥n
            tempDiv.style.width = '210mm';
            tempDiv.style.padding = '10mm';
            tempDiv.style.position = 'absolute';
            tempDiv.style.top = '-9999px';
            tempDiv.style.left = '-9999px';
            
            // Usar html2canvas para capturar el contenido
            html2canvas(tempDiv, { scale: 2 }).then(canvas => {
                const imgData = canvas.toDataURL('image/jpeg', 1.0);
                const imgWidth = 190;
                const pageHeight = 287;
                const imgHeight = canvas.height * imgWidth / canvas.width;
                let heightLeft = imgHeight;
                let position = 10;
                
                doc.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
                heightLeft -= pageHeight;
                
                // Si el contenido es m√°s largo que una p√°gina, agregar p√°ginas adicionales
                while (heightLeft > 0) {
                    position = heightLeft - imgHeight;
                    doc.addPage();
                    doc.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;
                }
                
                // Guardar el PDF
                doc.save(filename);
                
                // Eliminar el div temporal
                document.body.removeChild(tempDiv);
                
                utils.hideLoading();
                utils.showMessage('PDF exportado correctamente.', 'success');
            });
        } catch (error) {
            utils.hideLoading();
            utils.showMessage('Error al exportar a PDF: ' + error.message, 'error');
            console.error(error);
        }
    }, 500);
},

// Exportar a Excel
exportToExcel: (data, filename) => {
    utils.showLoading();
    
    setTimeout(() => {
        try {
            const worksheet = XLSX.utils.json_to_sheet(data);
            const workbook = XLSX.utils.book_new();
            
            XLSX.utils.book_append_sheet(workbook, worksheet, 'Reporte');
            
            // Guardar el archivo
            XLSX.writeFile(workbook, filename);
            
            utils.hideLoading();
            utils.showMessage('Excel exportado correctamente.', 'success');
        } catch (error) {
            utils.hideLoading();
            utils.showMessage('Error al exportar a Excel: ' + error.message, 'error');
            console.error(error);
        }
    }, 500);
},

// Imprimir contenido
printContent: (content) => {
    // Crear un iframe para imprimir
    const printFrame = document.createElement('iframe');
    printFrame.style.position = 'absolute';
    printFrame.style.top = '-9999px';
    printFrame.style.left = '-9999px';
    document.body.appendChild(printFrame);
    
    printFrame.contentDocument.open();
    printFrame.contentDocument.write(`
        <!DOCTYPE html>
        <html>
        <head>
            <title>Imprimir</title>
            <style>
                body { font-family: Arial, sans-serif; }
                table { border-collapse: collapse; width: 100%; }
                th, td { border: 1px solid #ddd; padding: 8px; }
                th { background-color: #f2f2f2; }
            </style>
        </head>
        <body>
            ${content}
        </body>
        </html>
    `);
    printFrame.contentDocument.close();
    
    // Esperar a que el iframe se cargue completamente
    printFrame.onload = () => {
        printFrame.contentWindow.focus();
        printFrame.contentWindow.print();
        
        // Eliminar el iframe despu√©s de imprimir
        setTimeout(() => {
            document.body.removeChild(printFrame);
        }, 1000);
    };
}
};

// Controladores de eventos
const eventHandlers = {
// Cambiar pesta√±a
tabClick: (e) => {
    const tabId = e.target.getAttribute('data-tab');
    if (!tabId) return;

    // Actualizar clases activas
    elements.tabs.forEach(tab => tab.classList.remove('active'));
    elements.tabContents.forEach(content => content.classList.remove('active'));

    e.target.classList.add('active');
    const tabContent = document.getElementById(tabId);
    if (tabContent) {
        tabContent.classList.add('active');
    }

    // Validaciones para cambio de pesta√±a
    if (['mapping', 'individual', 'group', 'evaluation', 'timeline'].includes(tabId) && 
        (!appState.studentsData || !appState.competencesData)) {
        utils.showMessage('Primero debe cargar los archivos.', 'error');
        return;
    }

    if (['individual', 'group', 'evaluation', 'timeline'].includes(tabId) && 
        (!appState.processedData.students || !appState.processedData.students.length || 
         !appState.processedData.evaluations || !appState.processedData.evaluations.length)) {
        utils.showMessage('Primero debe cargar los archivos y configurar los pesos.', 'error');
        return;
    }

    // Inicializaciones espec√≠ficas por pesta√±a
    switch(tabId) {
        case 'mapping':
            if (appState.competencesData) {
                renderCompetenceMapping();
            }
            break;
        case 'timeline':
            if (appState.processedData.students && appState.processedData.students.length) {
                renderTimelinePage();
            }
            break;
        case 'group':
            if (appState.processedData.students && appState.processedData.students.length) {
                eventHandlers.filterByPerformance();
            }
            break;
    }
},

// Manejar cambio en archivo de estudiantes
studentsFileChange: (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (elements.studentsFileInfo) {
        elements.studentsFileInfo.textContent = `Archivo seleccionado: ${file.name}`;
    }
    eventHandlers.checkFilesLoaded();
},

// Manejar cambio en archivo de competencias
competencesFileChange: (e) => {
    const file = e.target.files[0];
    if (!file) return;

    if (elements.competencesFileInfo) {
        elements.competencesFileInfo.textContent = `Archivo seleccionado: ${file.name}`;
    }
    eventHandlers.checkFilesLoaded();
},

// Verificar si ambos archivos est√°n cargados
checkFilesLoaded: () => {
    const studentsFile = elements.studentsFile ? elements.studentsFile.files[0] : null;
    const competencesFile = elements.competencesFile ? elements.competencesFile.files[0] : null;

    if (elements.loadFilesBtn) {
        elements.loadFilesBtn.disabled = !(studentsFile && competencesFile);
    }
},

// Cargar archivos
loadFiles: async () => {
    utils.showLoading();

    try {
        const studentsFile = elements.studentsFile ? elements.studentsFile.files[0] : null;
        const competencesFile = elements.competencesFile ? elements.competencesFile.files[0] : null;

        if (!studentsFile || !competencesFile) {
            throw new Error('Debe seleccionar ambos archivos.');
        }

        // Cargar archivo de estudiantes
        const studentsData = await readExcelOrCsvFile(studentsFile);
        appState.studentsData = studentsData;

        // Cargar archivo de competencias
        const competencesData = await readExcelOrCsvFile(competencesFile);
        appState.competencesData = competencesData;
        appState.competenceSheets = Object.keys(competencesData);

        // Configurar grupos disponibles
        if (elements.groupSelect) {
            elements.groupSelect.innerHTML = '<option value="">Seleccione un grupo</option>';
            if (appState.studentsData) {
                Object.keys(appState.studentsData).forEach(group => {
                    elements.groupSelect.innerHTML += `<option value="${group}">${group}</option>`;
                });
            }
        }

        // Configurar hojas de competencias
        if (elements.competenceSheetSelect) {
            elements.competenceSheetSelect.innerHTML = '<option value="">Seleccione una hoja</option>';
            appState.competenceSheets.forEach(sheet => {
                elements.competenceSheetSelect.innerHTML += `<option value="${sheet}">${sheet}</option>`;
            });
        }

        utils.showMessage('Archivos cargados correctamente. Por favor, configure los par√°metros.', 'success');

        // Cambiar a la pesta√±a de configuraci√≥n
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        elements.tabContents.forEach(content => content.classList.remove('active'));

        const configTab = document.querySelector('[data-tab="config"]');
        const configContent = document.getElementById('config');
        
        if (configTab) configTab.classList.add('active');
        if (configContent) configContent.classList.add('active');
    } catch (error) {
        utils.showMessage(`Error al cargar los archivos: ${error.message}`, 'error');
        console.error(error);
    }

    utils.hideLoading();
},

// Manejar cambio de grupo
groupChange: () => {
    const selectedGroup = elements.groupSelect ? elements.groupSelect.value : '';
    if (!selectedGroup) return;

    appState.config.selectedGroup = selectedGroup;

    // Obtener datos del grupo seleccionado
    const groupData = appState.studentsData ? appState.studentsData[selectedGroup] : null;
    if (!groupData || !groupData.length) return;

    // Obtener todos los campos disponibles
    const firstRow = groupData[0];
    const allFields = firstRow ? Object.keys(firstRow) : [];

    // Generar selector de campos
    if (elements.availableFields) {
        elements.availableFields.innerHTML = '';

        allFields.forEach(field => {
            const isStudentName = field.toLowerCase().includes('nombre') || 
                                field.toLowerCase().includes('name') ||
                                field.toLowerCase().includes('estudiante');

            const isGradeField = !isStudentName && 
                                (field.toLowerCase().includes('eval') || 
                                 field.toLowerCase().includes('nota') ||
                                 field.toLowerCase().includes('grade') ||
                                 field.match(/\d/) ||  // Contiene n√∫meros
                                 field.match(/^[a-zA-Z]\d*$/)); // Patr√≥n como P1, C2, etc.

            const className = isStudentName ? 'student-id' : (isGradeField ? 'grade-field' : '');
            const checked = isStudentName || isGradeField;

            const checkboxId = `field-${field.replace(/\s+/g, '-')}`;
            
            const fieldDiv = document.createElement('div');
            fieldDiv.className = `field-checkbox ${className}`;
            
            const checkbox = document.createElement('input');
            checkbox.type = 'checkbox';
            checkbox.id = checkboxId;
            checkbox.className = 'field-select';
            checkbox.setAttribute('data-field', field);
            checkbox.checked = checked;
            
            const label = document.createElement('label');
            label.htmlFor = checkboxId;
            label.textContent = field;
            
            fieldDiv.appendChild(checkbox);
            fieldDiv.appendChild(label);
            
            elements.availableFields.appendChild(fieldDiv);
        });

        // Event listeners para los checkboxes
        document.querySelectorAll('.field-select').forEach(checkbox => {
            checkbox.addEventListener('change', eventHandlers.fieldSelectionChange);
        });

        // Actualizar campos seleccionados
        eventHandlers.fieldSelectionChange();
    }
},

// Manejar cambio en selecci√≥n de campos
fieldSelectionChange: () => {
    const selectedFields = [];
    const studentIdFields = [];

    document.querySelectorAll('.field-select:checked').forEach(checkbox => {
        const field = checkbox.getAttribute('data-field');
        if (field) {
            selectedFields.push(field);

            if (checkbox.closest('.field-checkbox').classList.contains('student-id')) {
                studentIdFields.push(field);
            }
        }
    });

    // Guardar campos seleccionados
    appState.config.selectedFields = selectedFields;
    appState.config.studentIdFields = studentIdFields;

    // Obtener campos de evaluaci√≥n (excluyendo campos de ID)
    const evaluationFields = selectedFields.filter(field => 
        !studentIdFields.includes(field)
    );

    // Actualizar contenedor de pesos
    if (elements.weightContainer) {
        elements.weightContainer.innerHTML = '';

        evaluationFields.forEach(eval => {
            const currentWeight = parseFloat(appState.config.weights[eval]) || 0;
            const currentDate = appState.config.dates[eval] || '';

            const weightItem = document.createElement('div');
            weightItem.className = 'weight-item';
            weightItem.innerHTML = `
                <div class="weight-item-header">
                    <h4>${eval}</h4>
                </div>
                <div class="weight-item-content">
                    <div>
                        <label for="weight-${eval}">Peso (%)</label>
                        <input type="number" id="weight-${eval}" 
                            data-eval="${eval}" 
                            class="weight-input" 
                            min="0" max="100" step="0.1" 
                            value="${currentWeight}">
                    </div>
                    <div class="eval-date-container">
                        <label for="date-${eval}">Fecha:</label>
                        <input type="text" id="date-${eval}" 
                            data-eval="${eval}" 
                            class="date-input flatpickr-input" 
                            placeholder="Seleccionar fecha"
                            value="${currentDate}">
                    </div>
                    <div class="competence-selector">
                        <h5>Competencias asociadas:</h5>
                        <div class="competence-checkbox-group" id="comp-group-${eval}">
                            <!-- Se a√±adir√°n competencias din√°micamente -->
                        </div>
                    </div>
                </div>
            `;

            elements.weightContainer.appendChild(weightItem);

            // Inicializar el selector de fecha
            const dateInput = document.getElementById(`date-${eval}`);
            if (dateInput) {
                // Eliminar datepicker existente si hay uno
                if (appState.datepickers[`date-${eval}`]) {
                    appState.datepickers[`date-${eval}`].destroy();
                }

                appState.datepickers[`date-${eval}`] = flatpickr(dateInput, {
                    dateFormat: "Y-m-d",
                    onChange: (selectedDates, dateStr) => {
                        appState.config.dates[eval] = dateStr;
                        // Actualizar visualizaci√≥n si estamos en la pesta√±a de mapeo
                        if (document.getElementById('mapping') && 
                            document.getElementById('mapping').classList.contains('active')) {
                            renderCompetenceMapping();
                        }
                    }
                });
                
                // Si ya tiene una fecha, establecerla
                if (currentDate) {
                    appState.datepickers[`date-${eval}`].setDate(currentDate, false);
                }
            }

            // A√±adir competencias disponibles al selector
            const competenceGroup = document.getElementById(`comp-group-${eval}`);
            if (competenceGroup) {
                competenceGroup.innerHTML = ''; // Limpiar primero
                
                // Obtener todas las competencias √∫nicas
                let uniqueCompetences = [];
                const selectedSheet = elements.competenceSheetSelect ? 
                    elements.competenceSheetSelect.value : '';
                
                if (selectedSheet && appState.competencesData && appState.competencesData[selectedSheet]) {
                    uniqueCompetences = [...new Set(appState.competencesData[selectedSheet]
                        .filter(c => c.Competencia)
                        .map(c => c.Competencia))];
                } else if (appState.competencesData) {
                    Object.values(appState.competencesData).forEach(sheetData => {
                        const sheetCompetences = [...new Set(sheetData
                            .filter(c => c.Competencia)
                            .map(c => c.Competencia))];
                        uniqueCompetences = [...new Set([...uniqueCompetences, ...sheetCompetences])];
                    });
                }
                
                // A√±adir checkboxes para cada competencia
                uniqueCompetences.forEach(comp => {
                    const checkboxId = `comp-${eval}-${comp.replace(/\s+/g, '-')}`;
                    const isChecked = appState.processedData.competenceMappings && 
                                    appState.processedData.competenceMappings[eval] &&
                                    appState.processedData.competenceMappings[eval].includes(comp);
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = checkboxId;
                    checkbox.className = 'comp-checkbox';
                    checkbox.setAttribute('data-eval', eval);
                    checkbox.setAttribute('data-comp', comp);
                    checkbox.checked = isChecked;
                    checkbox.addEventListener('change', eventHandlers.competenceCheckboxChange);
                    
                    const label = document.createElement('label');
                    label.className = 'competence-checkbox';
                    label.htmlFor = checkboxId;
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(comp));
                    
                    competenceGroup.appendChild(label);
                });
            }
        });

        // Agregar event listeners a inputs de peso
        document.querySelectorAll('.weight-input').forEach(input => {
            input.addEventListener('input', eventHandlers.weightChange);
        });

        // Verificar peso total inicial
        utils.validateWeights();
    }
},

// Manejar cambio en los checkboxes de competencias
competenceCheckboxChange: (e) => {
    const evalName = e.target.getAttribute('data-eval');
    const compName = e.target.getAttribute('data-comp');
    const isChecked = e.target.checked;

    if (!evalName || !compName) return;

    // Inicializar el mapeo si es necesario
    if (!appState.processedData.competenceMappings) {
        appState.processedData.competenceMappings = {};
    }
    if (!appState.processedData.competenceMappings[evalName]) {
        appState.processedData.competenceMappings[evalName] = [];
    }

    // Actualizar el mapeo
    if (isChecked) {
        if (!appState.processedData.competenceMappings[evalName].includes(compName)) {
            appState.processedData.competenceMappings[evalName].push(compName);
        }
    } else {
        appState.processedData.competenceMappings[evalName] = 
            appState.processedData.competenceMappings[evalName].filter(c => c !== compName);
    }

    // Actualizar la vista si estamos en la pesta√±a de mapeo
    if (document.getElementById('mapping') && 
        document.getElementById('mapping').classList.contains('active')) {
        renderCompetenceMapping();
    }
},

// Manejar cambio en pesos
weightChange: () => {
    const weights = {};
    let total = 0;

    document.querySelectorAll('.weight-input').forEach(input => {
        const evalName = input.getAttribute('data-eval');
        const weight = parseFloat(input.value) || 0;
        if (evalName) {
            weights[evalName] = weight;
            total += weight;
        }
    });

    appState.config.weights = weights;

    // Validar si suman 100%
    utils.validateWeights();
},

// Distribuir pesos equitativamente
distributeWeights: () => {
    const weightInputs = document.querySelectorAll('.weight-input');
    if (weightInputs.length === 0) return;

    const equalWeight = (100 / weightInputs.length).toFixed(2);

    weightInputs.forEach(input => {
        const evalName = input.getAttribute('data-eval');
        input.value = equalWeight;
        if (evalName) {
            appState.config.weights[evalName] = parseFloat(equalWeight);
        }
    });

    // Verificar peso total
    utils.validateWeights();

    utils.showMessage('Pesos distribuidos equitativamente.', 'success');
},

// Limpiar pesos
clearWeights: () => {
    document.querySelectorAll('.weight-input').forEach(input => {
        input.value = 0;
        const evalName = input.getAttribute('data-eval');
        if (evalName) {
            appState.config.weights[evalName] = 0;
        }
    });

    // Verificar peso total
    utils.validateWeights();

    utils.showMessage('Pesos limpiados.', 'info');
},

// Guardar configuraci√≥n
saveConfig: () => {
    // Verificar si se seleccion√≥ un grupo
    if (!appState.config.selectedGroup) {
        utils.showMessage('Debe seleccionar un grupo.', 'error');
        return;
    }

    // Verificar si se seleccionaron campos
    if (!appState.config.selectedFields || appState.config.selectedFields.length === 0) {
        utils.showMessage('Debe seleccionar al menos un campo.', 'error');
        return;
    }

    // Verificar si los pesos suman 100%
    if (!utils.validateWeights()) {
        utils.showMessage('Los pesos deben sumar exactamente 100%. Use el bot√≥n "Distribuir Pesos Equitativamente" para asignar pesos autom√°ticamente.', 'error');
        return;
    }

    // Guardar configuraci√≥n general
    appState.config.decimalPlaces = parseInt(elements.decimalPlaces.value) || 2;
    appState.config.passingGrade = parseFloat(elements.passingGrade.value) || 3.00;
    appState.config.semester = elements.semesterSelect ? elements.semesterSelect.value : '2025-1';

    // Procesar datos
    utils.showLoading();
    setTimeout(() => {
        try {
            processData();
            utils.hideLoading();

            utils.showMessage('Configuraci√≥n guardada correctamente.', 'success');

            // Cambiar a la pesta√±a de mapeo de competencias
            elements.tabs.forEach(tab => tab.classList.remove('active'));
            elements.tabContents.forEach(content => content.classList.remove('active'));

            const mappingTab = document.querySelector('[data-tab="mapping"]');
            const mappingContent = document.getElementById('mapping');
            
            if (mappingTab) mappingTab.classList.add('active');
            if (mappingContent) mappingContent.classList.add('active');

            // Inicializar el mapeo de competencias
            renderCompetenceMapping();

        } catch (error) {
            utils.hideLoading();
            utils.showMessage('Error al procesar los datos: ' + error.message, 'error');
            console.error(error);
        }
    }, 500);
},

// Actualizar mapeo de competencias
updateCompetenceMapping: () => {
    utils.showMessage('Mapeo de competencias actualizado correctamente.', 'success');

    // Cambiar a la pesta√±a de reporte individual
    elements.tabs.forEach(tab => tab.classList.remove('active'));
    elements.tabContents.forEach(content => content.classList.remove('active'));

    const individualTab = document.querySelector('[data-tab="individual"]');
    const individualContent = document.getElementById('individual');
    
    if (individualTab) individualTab.classList.add('active');
    if (individualContent) individualContent.classList.add('active');

    // Inicializar filtros de competencias para reportes individuales
    initializeCompetenceFilters();

    // Inicializar datepickers para filtros
    initializeDatepickers();
},

// B√∫squeda de estudiante
searchStudent: () => {
    const searchTerm = elements.studentSearch ? elements.studentSearch.value.toLowerCase() : '';
    const students = appState.processedData.students || [];

    if (elements.studentsList) {
        elements.studentsList.innerHTML = '';

        students.forEach(student => {
            if (student.Nombre && student.Nombre.toLowerCase().includes(searchTerm)) {
                const studentElement = document.createElement('div');
                studentElement.className = 'student-item';
                studentElement.dataset.id = student.id;
                studentElement.textContent = student.Nombre;
                
                studentElement.addEventListener('click', () => eventHandlers.selectStudent(student));
                
                elements.studentsList.appendChild(studentElement);
            }
        });
    }
},

// Seleccionar estudiante
selectStudent: (student) => {
    if (!student) return;

    // Marcar estudiante seleccionado en la lista
    document.querySelectorAll('.student-item').forEach(item => {
        if (item.dataset.id && student.id) {
            item.classList.toggle('selected', item.dataset.id === student.id);
        }
    });

    appState.currentStudent = student;

    // Actualizar nombre del estudiante
    if (elements.studentName) {
//john5
elements.studentName.textContent = student.Nombre || 'Estudiante sin nombre';
}

// Mostrar informaci√≥n adicional
if (elements.studentInfo) {
    elements.studentInfo.textContent = `Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}`;
}

// Aplicar filtros actuales
const activeCompetences = getActiveCompetenceFilters('individualCompetenceFilter');
const dateRange = {
    start: elements.individualStartDate ? elements.individualStartDate.value : null,
    end: elements.individualEndDate ? elements.individualEndDate.value : null
};

// Validar rango de fechas
if (dateRange.start && dateRange.end) {
    try {
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        if (startDate > endDate) {
            utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
            return;
        }
    } catch (e) {
        console.error('Error al validar fechas:', e);
    }
}

// Almacenar filtros en el estado
appState.filters.individual.competences = activeCompetences;
appState.filters.individual.dateRange = dateRange;

// Mostrar evaluaciones
renderStudentGrades(student, activeCompetences, dateRange);

// Mostrar competencias
renderStudentCompetences(student, activeCompetences, dateRange);

// Mostrar predicci√≥n
renderPrediction(student, activeCompetences);
},

// Filtrar reporte individual por competencia
filterIndividualByCompetence: () => {
if (!appState.currentStudent) return;

const activeCompetences = getActiveCompetenceFilters('individualCompetenceFilter');
const dateRange = {
    start: elements.individualStartDate ? elements.individualStartDate.value : null,
    end: elements.individualEndDate ? elements.individualEndDate.value : null
};

// Validar rango de fechas
if (dateRange.start && dateRange.end) {
    try {
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        if (startDate > endDate) {
            utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
            return;
        }
    } catch (e) {
        console.error('Error al validar fechas:', e);
    }
}

// Almacenar filtros en el estado
appState.filters.individual.competences = activeCompetences;
appState.filters.individual.dateRange = dateRange;

// Actualizar reporte individual
renderStudentGrades(appState.currentStudent, activeCompetences, dateRange);
renderStudentCompetences(appState.currentStudent, activeCompetences, dateRange);
renderPrediction(appState.currentStudent, activeCompetences);
},

// Filtrar por rendimiento en reporte grupal
filterByPerformance: () => {
const performanceValue = elements.performanceFilter ? elements.performanceFilter.value : 'all';
appState.filters.group.performance = performanceValue;

const competenceValue = elements.competenceFilter ? elements.competenceFilter.value : 'all';
appState.filters.group.competence = competenceValue;

const dateRange = {
    start: elements.groupStartDate ? elements.groupStartDate.value : null,
    end: elements.groupEndDate ? elements.groupEndDate.value : null
};

// Validar rango de fechas
if (dateRange.start && dateRange.end) {
    try {
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        if (startDate > endDate) {
            utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
            return;
        }
    } catch (e) {
        console.error('Error al validar fechas:', e);
    }
}

appState.filters.group.dateRange = dateRange;

const students = appState.processedData.students || [];

let filtered = students;

// Filtrar por rendimiento
if (performanceValue !== 'all') {
    const passingGrade = appState.config.passingGrade || 3.0;

    switch (performanceValue) {
        case 'high':
            filtered = filtered.filter(s => utils.calculateFinalGrade(s, 
                competenceValue !== 'all' ? [competenceValue] : [],
                dateRange) >= passingGrade + 1);
            break;
        case 'medium':
            filtered = filtered.filter(s => {
                const grade = utils.calculateFinalGrade(s, 
                    competenceValue !== 'all' ? [competenceValue] : [],
                    dateRange);
                return grade >= passingGrade && grade < passingGrade + 1;
            });
            break;
        case 'low':
            filtered = filtered.filter(s => utils.calculateFinalGrade(s, 
                competenceValue !== 'all' ? [competenceValue] : [],
                dateRange) < passingGrade);
            break;
    }
}

renderGroupReport(filtered, 
    competenceValue !== 'all' ? [competenceValue] : [],
    dateRange);
},

// Seleccionar evaluaci√≥n para reporte
selectEvaluation: () => {
const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
if (!evalName) return;

const competenceValue = elements.evalCompetenceFilter ? 
    elements.evalCompetenceFilter.value : 'all';

appState.filters.evaluation.selectedEval = evalName;
appState.filters.evaluation.competence = competenceValue;

renderEvaluationReport(evalName, competenceValue !== 'all' ? [competenceValue] : []);
},

// Filtrar reporte de evaluaci√≥n por competencia
filterEvaluationByCompetence: () => {
const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
if (!evalName) return;

const competenceValue = elements.evalCompetenceFilter ? 
    elements.evalCompetenceFilter.value : 'all';

appState.filters.evaluation.competence = competenceValue;

renderEvaluationReport(evalName, competenceValue !== 'all' ? [competenceValue] : []);
},

// Seleccionar estudiante para l√≠nea de tiempo
selectTimelineStudent: () => {
const studentValue = elements.timelineStudentSelect ? 
    elements.timelineStudentSelect.value : 'group';

const competenceValue = elements.timelineCompetenceFilter ? 
    elements.timelineCompetenceFilter.value : 'all';

appState.filters.timeline.student = studentValue;
appState.filters.timeline.competence = competenceValue;

renderTimeline(studentValue, competenceValue);
},

// Filtrar l√≠nea de tiempo por competencia
filterTimelineByCompetence: () => {
const studentValue = elements.timelineStudentSelect ? 
    elements.timelineStudentSelect.value : 'group';

const competenceValue = elements.timelineCompetenceFilter ? 
    elements.timelineCompetenceFilter.value : 'all';

appState.filters.timeline.competence = competenceValue;

renderTimeline(studentValue, competenceValue);
},

// Vista previa de reporte individual
previewIndividualReport: () => {
if (!appState.currentStudent) {
    utils.showMessage('Debe seleccionar un estudiante.', 'error');
    return;
}

// Aplicar filtros actuales
const activeCompetences = getActiveCompetenceFilters('individualCompetenceFilter');
const dateRange = {
    start: elements.individualStartDate ? elements.individualStartDate.value : null,
    end: elements.individualEndDate ? elements.individualEndDate.value : null
};

// Validar rango de fechas
if (dateRange.start && dateRange.end) {
    try {
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        if (startDate > endDate) {
            utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
            return;
        }
    } catch (e) {
        console.error('Error al validar fechas:', e);
    }
}

// Clonar el reporte individual
const individualReport = document.getElementById('individualReport').cloneNode(true);

// Actualizar el nombre del estudiante en el clon
const cloneStudentName = individualReport.querySelector('#studentName');
if (cloneStudentName) {
    cloneStudentName.textContent = appState.currentStudent.Nombre || 'Estudiante sin nombre';
}

const cloneStudentInfo = individualReport.querySelector('#studentInfo');
if (cloneStudentInfo) {
    cloneStudentInfo.textContent = `Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}`;
}

// Actualizar la tabla de notas en el clon
const cloneGradesTable = individualReport.querySelector('.grades-table tbody');
if (cloneGradesTable) {
    cloneGradesTable.innerHTML = '';
    
    let totalWeight = 0;
    let completedWeight = 0;
    let totalContribution = 0;
    
    for (const evalName in appState.config.weights) {
        // Aplicar filtros
        if (activeCompetences.length > 0) {
            const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
            if (!evalCompetences.some(comp => activeCompetences.includes(comp))) {
                continue;
            }
        }
        
        if (dateRange.start && dateRange.end) {
            const evalDate = appState.config.dates[evalName];
            if (evalDate) {
                try {
                    const date = new Date(evalDate);
                    const start = new Date(dateRange.start);
                    const end = new Date(dateRange.end);
                    if (date < start || date > end) {
                        continue;
                    }
                } catch (e) {
                    console.error('Error al comparar fechas:', e);
                }
            }
        }
        
        const grade = appState.currentStudent[evalName];
        const weight = parseFloat(appState.config.weights[evalName]) / 100 || 0;
        totalWeight += weight;
        
        const contribution = grade !== undefined && grade !== null ? grade * weight : 0;
        const evalDate = appState.config.dates[evalName] || '';
        
        if (grade !== undefined && grade !== null) {
            completedWeight += weight;
            totalContribution += contribution;
        }
        
        const row = document.createElement('tr');
        row.innerHTML = `
            <td>${evalName}</td>
            <td>${utils.formatDate(evalDate)}</td>
            <td>${grade !== undefined && grade !== null ? utils.formatNumber(grade) : 'Pendiente'}</td>
            <td>${utils.formatNumber(weight * 100)}%</td>
            <td>${grade !== undefined && grade !== null ? utils.formatNumber(contribution) : 'N/A'}</td>
        `;
        cloneGradesTable.appendChild(row);
    }
    
    // Calcular nota final (adaptada para reportes parciales)
    let finalGrade = 0;
    if (completedWeight > 0) {
        finalGrade = (totalContribution / completedWeight) * 100;
    }
    
    // Proyecci√≥n al 100%
    const projectedGrade = finalGrade / 100;
    
    // Agregar fila de total
    const totalRow = document.createElement('tr');
    totalRow.innerHTML = `
        <td><strong>Total</strong></td>
        <td></td>
        <td></td>
        <td><strong>${utils.formatNumber(totalWeight * 100)}%</strong></td>
        <td><strong>${utils.formatNumber(totalContribution)}</strong></td>
    `;
    cloneGradesTable.appendChild(totalRow);
    
    // Agregar fila de nota actual
    const currentGradeRow = document.createElement('tr');
    currentGradeRow.innerHTML = `
        <td colspan="4"><strong>Nota actual (${utils.formatNumber(completedWeight * 100)}% completado):</strong></td>
        <td><strong>${utils.formatNumber(projectedGrade)}</strong></td>
    `;
    cloneGradesTable.appendChild(currentGradeRow);
}

// Actualizar las competencias en el clon
const cloneCompetenceContainer = individualReport.querySelector('.competence-container');
if (cloneCompetenceContainer) {
    cloneCompetenceContainer.innerHTML = '';
    
    // Obtener competencias √∫nicas (filtradas si es necesario)
    let competencesToShow = utils.getUniqueCompetences();
    if (activeCompetences.length > 0) {
        competencesToShow = competencesToShow.filter(comp => activeCompetences.includes(comp));
    }
    
    competencesToShow.forEach(compName => {
        // Obtener evaluaciones relacionadas con esta competencia
        const relatedEvals = [];
        
        for (const evalKey in appState.processedData.competenceMappings) {
            const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
            
            if (evalCompetences.includes(compName)) {
                // Verificar filtro de fecha si es necesario
                if (dateRange.start && dateRange.end) {
                    const evalDate = appState.config.dates[evalKey];
                    if (evalDate) {
                        try {
                            const date = new Date(evalDate);
                            const start = new Date(dateRange.start);
                            const end = new Date(dateRange.end);
                            if (date < start || date > end) {
                                continue;
                            }
                        } catch (e) {
                            console.error('Error al comparar fechas:', e);
                        }
                    }
                }
                
                relatedEvals.push(evalKey);
            }
        }
        
        // Calcular promedio de estudiante para esta competencia
        let compAvg = 0;
        let evalCount = 0;
        
        relatedEvals.forEach(evalName => {
            if (appState.currentStudent[evalName] !== undefined && 
                appState.currentStudent[evalName] !== null) {
                compAvg += parseFloat(appState.currentStudent[evalName]) || 0;
                evalCount++;
            }
        });
        
        if (evalCount > 0) {
            compAvg = compAvg / evalCount;
        }
        
        // Calcular porcentaje de logro (considerando 5 como nota m√°xima)
        const achievementPercentage = evalCount > 0 ? (compAvg / 5) * 100 : 0;
        
        // Crear elemento de competencia
        const compElement = document.createElement('div');
        compElement.className = 'competence-item';
        compElement.innerHTML = `
            <div><strong>${compName}</strong>${evalCount > 0 ? ` - ${utils.formatNumber(compAvg)}` : ' - Sin datos'}</div>
            <div class="competence-progress">
                <div class="competence-progress-bar" style="width: ${achievementPercentage}%"></div>
            </div>
        `;
        
        // Agregar indicadores
        const indicators = appState.processedData.indicators[compName] || [];
        if (indicators.length > 0) {
            const indicatorsHtml = indicators.map(ind => `
                <div class="indicator">${ind}</div>
            `).join('');
            
            compElement.innerHTML += `<div class="indicators">${indicatorsHtml}</div>`;
        }
        
        // Agregar evaluaciones relacionadas
        if (relatedEvals.length > 0) {
            const evalHtml = relatedEvals.map(eval => `
                <div class="competence-tag">${eval}</div>
            `).join('');
            
            compElement.innerHTML += `
                <div style="margin-top: 10px; font-size: 12px;">
                    <em>Evaluaciones:</em>
                    <div class="competence-list">${evalHtml}</div>
                </div>
            `;
        }
        
        cloneCompetenceContainer.appendChild(compElement);
    });
}

// Actualizar la predicci√≥n en el clon
const clonePredictionResults = individualReport.querySelector('#predictionResults');
if (clonePredictionResults) {
    const prediction = utils.predictRequiredGrade(appState.currentStudent, activeCompetences);
    
    if (!prediction.possible) {
        clonePredictionResults.innerHTML = `
            <div class="prediction-message">${prediction.message}</div>
        `;
    } else if (prediction.requiredGrade <= 0) {
        clonePredictionResults.innerHTML = `
            <div class="prediction-message">${prediction.message}</div>
        `;
    } else {
        const evalsList = prediction.evaluations.map(eval => `
            <div class="prediction-value">
                ${eval}: ${utils.formatNumber(prediction.requiredGrade)}
            </div>
        `).join('');
        
        clonePredictionResults.innerHTML = `
            <div class="prediction-message">${prediction.message}</div>
            ${evalsList}
            <div class="prediction-note">
                Nota final proyectada si obtienes estas calificaciones: 
                <strong>${utils.formatNumber(appState.config.passingGrade)}</strong>
            </div>
        `;
    }
}

utils.showPreview(
    `Vista Previa - Reporte de ${appState.currentStudent.Nombre || 'Estudiante'}`,
    individualReport.outerHTML,
    'pdf',
    `reporte_${(appState.currentStudent.Nombre || 'estudiante').replace(/\s+/g, '_')}.pdf`
);
},

// Exportar reporte individual a PDF
exportIndividualPdf: () => {
if (!appState.currentStudent) {
    utils.showMessage('Debe seleccionar un estudiante.', 'error');
    return;
}

const reportContainer = document.getElementById('individualReport');
if (!reportContainer) return;

const filename = `reporte_${(appState.currentStudent.Nombre || 'estudiante').replace(/\s+/g, '_')}.pdf`;

utils.exportToPdf(reportContainer.outerHTML, filename);
},

// Exportar reporte individual a Excel
exportIndividualExcel: () => {
if (!appState.currentStudent) {
    utils.showMessage('Debe seleccionar un estudiante.', 'error');
    return;
}

const student = appState.currentStudent;

// Crear datos para Excel
const excelData = [];

// Informaci√≥n del estudiante
excelData.push({
    "Tipo": "Informaci√≥n",
    "Detalle": "Estudiante",
    "Valor": student.Nombre
});

excelData.push({
    "Tipo": "Informaci√≥n",
    "Detalle": "Grupo",
    "Valor": appState.config.selectedGroup
});

excelData.push({
    "Tipo": "Informaci√≥n",
    "Detalle": "Semestre",
    "Valor": appState.config.semester
});

// Fila vac√≠a
excelData.push({});

// Evaluaciones
excelData.push({
    "Tipo": "Encabezado",
    "Detalle": "Evaluaciones",
    "Valor": ""
});

for (const evalName in appState.config.weights) {
    const grade = student[evalName];
    const weight = parseFloat(appState.config.weights[evalName]) || 0;
    const contribution = grade !== undefined && grade !== null ? grade * (weight / 100) : 0;
    const evalDate = appState.config.dates[evalName] || '';
    
    excelData.push({
        "Evaluaci√≥n": evalName,
        "Fecha": evalDate,
        "Nota": grade !== undefined && grade !== null ? grade : "Pendiente",
        "Peso (%)": weight,
        "Contribuci√≥n": grade !== undefined && grade !== null ? contribution : "N/A"
    });
}

// Calcular nota final
let totalContribution = 0;
let completedWeight = 0;

for (const evalName in appState.config.weights) {
    if (student[evalName] !== undefined && student[evalName] !== null) {
        const grade = parseFloat(student[evalName]) || 0;
        const weight = parseFloat(appState.config.weights[evalName]) / 100 || 0;
        totalContribution += grade * weight;
        completedWeight += weight;
    }
}

// Calcular nota final (adaptada para reportes parciales)
let finalGrade = 0;
if (completedWeight > 0) {
    finalGrade = (totalContribution / completedWeight) * 100;
}

// Proyecci√≥n al 100%
const projectedGrade = finalGrade / 100;

// Agregar nota final
excelData.push({});
excelData.push({
    "Evaluaci√≥n": "NOTA ACTUAL",
    "Fecha": "",
    "Nota": utils.formatNumber(projectedGrade),
    "Peso (%)": utils.formatNumber(completedWeight * 100) + "% completado",
    "Contribuci√≥n": ""
});

// Fila vac√≠a
excelData.push({});

// Competencias
excelData.push({
    "Tipo": "Encabezado",
    "Detalle": "Competencias",
    "Valor": ""
});

const uniqueCompetences = utils.getUniqueCompetences();
uniqueCompetences.forEach(compName => {
    // Obtener evaluaciones relacionadas con esta competencia
    const relatedEvals = [];
    
    for (const evalKey in appState.processedData.competenceMappings) {
        const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
        
        if (evalCompetences.includes(compName)) {
            relatedEvals.push(evalKey);
        }
    }
    
    // Calcular promedio de estudiante para esta competencia
    let compAvg = 0;
    let evalCount = 0;
    
    relatedEvals.forEach(evalName => {
        if (student[evalName] !== undefined && student[evalName] !== null) {
            compAvg += parseFloat(student[evalName]) || 0;
            evalCount++;
        }
    });
    
    if (evalCount > 0) {
        compAvg = compAvg / evalCount;
    }
    
    excelData.push({
        "Competencia": compName,
        "Promedio": evalCount > 0 ? utils.formatNumber(compAvg) : "Sin datos",
        "Evaluaciones": relatedEvals.join(", ")
    });
    
    // Agregar indicadores
    const indicators = appState.processedData.indicators[compName] || [];
    indicators.forEach(ind => {
        excelData.push({
            "Competencia": "",
            "Promedio": "",
            "Evaluaciones": "",
            "Indicador": ind
        });
    });
});

const filename = `reporte_${(student.Nombre || 'estudiante').replace(/\s+/g, '_')}.xlsx`;

utils.exportToExcel(excelData, filename);
},

// Imprimir reporte individual
printIndividualReport: () => {
if (!appState.currentStudent) {
    utils.showMessage('Debe seleccionar un estudiante.', 'error');
    return;
}

const reportContainer = document.getElementById('individualReport');
if (!reportContainer) return;

utils.printContent(reportContainer.outerHTML);
},

// Vista previa de reporte grupal
previewGroupReport: () => {
const performanceFilter = elements.performanceFilter ? elements.performanceFilter.value : 'all';
const competenceFilter = elements.competenceFilter ? elements.competenceFilter.value : 'all';
const dateRange = {
    start: elements.groupStartDate ? elements.groupStartDate.value : null,
    end: elements.groupEndDate ? elements.groupEndDate.value : null
};

// Validar rango de fechas
if (dateRange.start && dateRange.end) {
    try {
        const startDate = new Date(dateRange.start);
        const endDate = new Date(dateRange.end);
        if (startDate > endDate) {
            utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
            return;
        }
    } catch (e) {
        console.error('Error al validar fechas:', e);
    }
}

const students = appState.processedData.students || [];

// Filtrar estudiantes seg√∫n el rendimiento
let filtered = students;
const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

if (performanceFilter !== 'all') {
    const passingGrade = appState.config.passingGrade || 3.0;
    
    switch (performanceFilter) {
        case 'high':
            filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) >= passingGrade + 1);
            break;
        case 'medium':
            filtered = filtered.filter(s => {
                const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                return grade >= passingGrade && grade < passingGrade + 1;
            });
            break;
        case 'low':
            filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) < passingGrade);
            break;
    }
}

// Clonar los contenedores de estad√≠sticas y gr√°ficos
const groupStatsContainer = document.getElementById('groupStatsContainer').cloneNode(true);
const groupChart = document.getElementById('groupChart');
const competenceChart = document.getElementById('competenceChart');
const riskStudentsList = document.getElementById('riskStudentsList').cloneNode(true);

// Capturar los gr√°ficos como im√°genes
let groupChartImg = '';
let competenceChartImg = '';

if (groupChart && appState.charts.groupChart) {
    groupChartImg = `<img src="${appState.charts.groupChart.toBase64Image()}" style="width:100%;">`;
}

if (competenceChart && appState.charts.competenceChart) {
    competenceChartImg = `<img src="${appState.charts.competenceChart.toBase64Image()}" style="width:100%;">`;
}

// Construir el contenido del reporte
const reportContent = `
    <div style="margin-bottom: 20px;">
        <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
        <p>Semestre: ${appState.config.semester}</p>
        
        <div style="margin-top: 10px;">
            <strong>Filtros aplicados:</strong>
            <ul>
                <li>Rendimiento: ${performanceFilter === 'all' ? 'Todos' : 
                                  performanceFilter === 'high' ? 'Alto' : 
                                  performanceFilter === 'medium' ? 'Medio' : 'Bajo'}</li>
                <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                <li>Rango de fechas: ${dateRange.start && dateRange.end ? 
                                    `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}</li>
            </ul>
        </div>
    </div>
    
    <div>${groupStatsContainer.outerHTML}</div>
    
    <div style="margin: 20px 0;">
        <h3>Distribuci√≥n de Calificaciones</h3>
        ${groupChartImg}
    </div>
    
    <div style="margin: 20px 0;">
        <h3>Rendimiento por Competencia</h3>
        ${competenceChartImg}
    </div>
    
    <div style="margin: 20px 0;">
        <h3>Estudiantes en Riesgo</h3>
        ${riskStudentsList.outerHTML}
    </div>
`;

utils.showPreview(
    'Vista Previa - Reporte Grupal',
    reportContent,
    'pdf',
    `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.pdf`
);
},

// john4
// Exportar reporte grupal a PDF
exportGroupPdf: () => {
    const performanceFilter = elements.performanceFilter ? elements.performanceFilter.value : 'all';
    const competenceFilter = elements.competenceFilter ? elements.competenceFilter.value : 'all';
    const dateRange = {
        start: elements.groupStartDate ? elements.groupStartDate.value : null,
        end: elements.groupEndDate ? elements.groupEndDate.value : null
    };
    
    // Validar rango de fechas
    if (dateRange.start && dateRange.end) {
        try {
            const startDate = new Date(dateRange.start);
            const endDate = new Date(dateRange.end);
            if (startDate > endDate) {
                utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
                return;
            }
        } catch (e) {
            console.error('Error al validar fechas:', e);
        }
    }
    
    const students = appState.processedData.students || [];
    
    // Filtrar estudiantes seg√∫n el rendimiento
    let filtered = students;
    const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
    
    if (performanceFilter !== 'all') {
        const passingGrade = appState.config.passingGrade || 3.0;
        
        switch (performanceFilter) {
            case 'high':
                filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) >= passingGrade + 1);
                break;
            case 'medium':
                filtered = filtered.filter(s => {
                    const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                    return grade >= passingGrade && grade < passingGrade + 1;
                });
                break;
            case 'low':
                filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) < passingGrade);
                break;
        }
    }
    
    // Capturar los elementos del reporte
    const groupStatsContainer = document.getElementById('groupStatsContainer');
    const groupChart = document.getElementById('groupChart');
    const competenceChart = document.getElementById('competenceChart');
    const riskStudentsList = document.getElementById('riskStudentsList');
    
    if (!groupStatsContainer || !groupChart || !competenceChart || !riskStudentsList) {
        utils.showMessage('Error al generar el reporte.', 'error');
        return;
    }
    
    // Capturar los gr√°ficos como im√°genes
    let groupChartImg = '';
    let competenceChartImg = '';
    
    if (appState.charts.groupChart) {
        groupChartImg = `<img src="${appState.charts.groupChart.toBase64Image()}" style="width:100%;">`;
    }
    
    if (appState.charts.competenceChart) {
        competenceChartImg = `<img src="${appState.charts.competenceChart.toBase64Image()}" style="width:100%;">`;
    }
    
    // Construir el contenido del reporte
    const reportContent = `
        <div style="margin-bottom: 20px;">
            <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
            <p>Semestre: ${appState.config.semester}</p>
            
            <div style="margin-top: 10px;">
                <strong>Filtros aplicados:</strong>
                <ul>
                    <li>Rendimiento: ${performanceFilter === 'all' ? 'Todos' : 
                                      performanceFilter === 'high' ? 'Alto' : 
                                      performanceFilter === 'medium' ? 'Medio' : 'Bajo'}</li>
                    <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                    <li>Rango de fechas: ${dateRange.start && dateRange.end ? 
                                        `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}</li>
                </ul>
            </div>
        </div>
        
        <div>${groupStatsContainer.outerHTML}</div>
        
        <div style="margin: 20px 0;">
            <h3>Distribuci√≥n de Calificaciones</h3>
            ${groupChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Rendimiento por Competencia</h3>
            ${competenceChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Estudiantes en Riesgo</h3>
            ${riskStudentsList.outerHTML}
        </div>
    `;
    
    const filename = `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.pdf`;
    
    utils.exportToPdf(reportContent, filename);
},

// Exportar reporte grupal a Excel
exportGroupExcel: () => {
    const performanceFilter = elements.performanceFilter ? elements.performanceFilter.value : 'all';
    const competenceFilter = elements.competenceFilter ? elements.competenceFilter.value : 'all';
    const dateRange = {
        start: elements.groupStartDate ? elements.groupStartDate.value : null,
        end: elements.groupEndDate ? elements.groupEndDate.value : null
    };
    
    const students = appState.processedData.students || [];
    
    // Filtrar estudiantes seg√∫n el rendimiento
    let filtered = students;
    const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
    
    if (performanceFilter !== 'all') {
        const passingGrade = appState.config.passingGrade || 3.0;
        
        switch (performanceFilter) {
            case 'high':
                filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) >= passingGrade + 1);
                break;
            case 'medium':
                filtered = filtered.filter(s => {
                    const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                    return grade >= passingGrade && grade < passingGrade + 1;
                });
                break;
            case 'low':
                filtered = filtered.filter(s => utils.calculateFinalGrade(s, competenceValue, dateRange) < passingGrade);
                break;
        }
    }
    
    // Crear datos para Excel
    const excelData = [];
    
    // Informaci√≥n del grupo
    excelData.push({
        "Informaci√≥n": "Grupo",
        "Valor": appState.config.selectedGroup
    });
    
    excelData.push({
        "Informaci√≥n": "Semestre",
        "Valor": appState.config.semester
    });
    
    excelData.push({
        "Informaci√≥n": "Filtro de rendimiento",
        "Valor": performanceFilter === 'all' ? 'Todos' : 
                 performanceFilter === 'high' ? 'Alto' : 
                 performanceFilter === 'medium' ? 'Medio' : 'Bajo'
    });
    
    excelData.push({
        "Informaci√≥n": "Filtro de competencia",
        "Valor": competenceFilter === 'all' ? 'Todas' : competenceFilter
    });
    
    excelData.push({
        "Informaci√≥n": "Rango de fechas",
        "Valor": dateRange.start && dateRange.end ? 
                `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'
    });
    
    // Fila vac√≠a
    excelData.push({});
    
    // Estad√≠sticas
    const stats = utils.calculateGroupStats(filtered, competenceValue, dateRange);
    
    if (stats) {
        excelData.push({
            "Estad√≠stica": "Total Estudiantes",
            "Valor": stats.totalStudents
        });
        
        excelData.push({
            "Estad√≠stica": "Estudiantes Evaluados",
            "Valor": stats.evaluatedStudents
        });
        
        excelData.push({
            "Estad√≠stica": "Promedio",
            "Valor": utils.formatNumber(stats.average)
        });
        
        excelData.push({
            "Estad√≠stica": "Nota M√≠nima",
            "Valor": utils.formatNumber(stats.min)
        });
        
        excelData.push({
            "Estad√≠stica": "Nota M√°xima",
            "Valor": utils.formatNumber(stats.max)
        });
        
        excelData.push({
            "Estad√≠stica": "Desviaci√≥n Est√°ndar",
            "Valor": utils.formatNumber(stats.stdDev)
        });
        
        excelData.push({
            "Estad√≠stica": "Estudiantes en Riesgo",
            "Valor": stats.studentsAtRisk
        });
    }
    
    // Fila vac√≠a
    excelData.push({});
    
    // Rendimiento por competencia
    const compPerformance = utils.calculateCompetencePerformance(students, appState.processedData.competences, dateRange);
    
    excelData.push({
        "Competencia": "Competencia",
        "Promedio": "Promedio",
        "Tasa de Aprobaci√≥n": "Tasa de Aprobaci√≥n (%)",
        "Estudiantes Evaluados": "Estudiantes Evaluados"
    });
    
    Object.keys(compPerformance).forEach(comp => {
        if (competenceValue.length === 0 || competenceValue.includes(comp)) {
            const perf = compPerformance[comp];
            
            if (perf.count > 0) {
                const passRate = (perf.passStudents / perf.totalStudents) * 100;
                
                excelData.push({
                    "Competencia": comp,
                    "Promedio": utils.formatNumber(perf.average),
                    "Tasa de Aprobaci√≥n": utils.formatNumber(passRate) + "%",
                    "Estudiantes Evaluados": perf.totalStudents
                });
            }
        }
    });
    
    // Fila vac√≠a
    excelData.push({});
    
    // Lista de estudiantes con calificaciones
    excelData.push({
        "Nombre": "Nombre",
        "Nota Final": "Nota Final",
        "Estado": "Estado"
    });
    
    // Ordenar estudiantes por nombre
    const sortedStudents = [...filtered].sort((a, b) => 
        a.Nombre && b.Nombre ? a.Nombre.localeCompare(b.Nombre) : 0);
    
    sortedStudents.forEach(student => {
        const finalGrade = utils.calculateFinalGrade(student, competenceValue, dateRange);
        const status = finalGrade >= appState.config.passingGrade ? "Aprobado" : "Reprobado";
        
        excelData.push({
            "Nombre": student.Nombre,
            "Nota Final": utils.formatNumber(finalGrade / 100),
            "Estado": status
        });
    });
    
    const filename = `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.xlsx`;
    
    utils.exportToExcel(excelData, filename);
},

// Imprimir reporte grupal
printGroupReport: () => {
    const performanceFilter = elements.performanceFilter ? elements.performanceFilter.value : 'all';
    const competenceFilter = elements.competenceFilter ? elements.competenceFilter.value : 'all';
    const dateRange = {
        start: elements.groupStartDate ? elements.groupStartDate.value : null,
        end: elements.groupEndDate ? elements.groupEndDate.value : null
    };
    
    // Validar rango de fechas
    if (dateRange.start && dateRange.end) {
        try {
            const startDate = new Date(dateRange.start);
            const endDate = new Date(dateRange.end);
            if (startDate > endDate) {
                utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'error');
                return;
            }
        } catch (e) {
            console.error('Error al validar fechas:', e);
        }
    }
    
    // Capturar los elementos del reporte
    const groupStatsContainer = document.getElementById('groupStatsContainer');
    const groupChart = document.getElementById('groupChart');
    const competenceChart = document.getElementById('competenceChart');
    const riskStudentsList = document.getElementById('riskStudentsList');
    
    if (!groupStatsContainer || !groupChart || !competenceChart || !riskStudentsList) {
        utils.showMessage('Error al generar el reporte.', 'error');
        return;
    }
    
    // Capturar los gr√°ficos como im√°genes
    let groupChartImg = '';
    let competenceChartImg = '';
    
    if (appState.charts.groupChart) {
        groupChartImg = `<img src="${appState.charts.groupChart.toBase64Image()}" style="width:100%;">`;
    }
    
    if (appState.charts.competenceChart) {
        competenceChartImg = `<img src="${appState.charts.competenceChart.toBase64Image()}" style="width:100%;">`;
    }
    
    // Construir el contenido del reporte
    const reportContent = `
        <div style="margin-bottom: 20px;">
            <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
            <p>Semestre: ${appState.config.semester}</p>
            
            <div style="margin-top: 10px;">
                <strong>Filtros aplicados:</strong>
                <ul>
                    <li>Rendimiento: ${performanceFilter === 'all' ? 'Todos' : 
                                      performanceFilter === 'high' ? 'Alto' : 
                                      performanceFilter === 'medium' ? 'Medio' : 'Bajo'}</li>
                    <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                    <li>Rango de fechas: ${dateRange.start && dateRange.end ? 
                                        `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}</li>
                </ul>
            </div>
        </div>
        
        <div>${groupStatsContainer.outerHTML}</div>
        
        <div style="margin: 20px 0;">
            <h3>Distribuci√≥n de Calificaciones</h3>
            ${groupChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Rendimiento por Competencia</h3>
            ${competenceChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Estudiantes en Riesgo</h3>
            ${riskStudentsList.outerHTML}
        </div>
    `;
    
    utils.printContent(reportContent);
},

// Vista previa de reporte por evaluaci√≥n
previewEvaluationReport: () => {
    const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
    if (!evalName) {
        utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
        return;
    }
    
    const competenceFilter = elements.evalCompetenceFilter ? elements.evalCompetenceFilter.value : 'all';
    const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
    
    // Capturar los elementos del reporte
    const evaluationReportContainer = document.getElementById('evaluationReportContainer').cloneNode(true);
    const evaluationChart = document.getElementById('evaluationChart');
    const evalCompetenceChart = document.getElementById('evalCompetenceChart');
    
    // Capturar los gr√°ficos como im√°genes
    let evalChartImg = '';
    let evalCompChartImg = '';
    
    if (evaluationChart && appState.charts.evaluationChart) {
        evalChartImg = `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="width:100%;">`;
    }
    
    if (evalCompetenceChart && appState.charts.evalCompetenceChart) {
        evalCompChartImg = `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="width:100%;">`;
    }
    
    // Construir el contenido del reporte
    const reportContent = `
        <div style="margin-bottom: 20px;">
            <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
            <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
            
            <div style="margin-top: 10px;">
                <strong>Filtros aplicados:</strong>
                <ul>
                    <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                </ul>
            </div>
        </div>
        
        <div>${evaluationReportContainer.outerHTML}</div>
        
        <div style="margin: 20px 0;">
            <h3>Distribuci√≥n de Calificaciones</h3>
            ${evalChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Rendimiento por Competencia</h3>
            ${evalCompChartImg}
        </div>
    `;
    
    utils.showPreview(
        `Vista Previa - Reporte de Evaluaci√≥n ${evalName}`,
        reportContent,
        'pdf',
        `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.pdf`
    );
},

// Exportar reporte de evaluaci√≥n a PDF
exportEvaluationPdf: () => {
    const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
    if (!evalName) {
        utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
        return;
    }
    
    const competenceFilter = elements.evalCompetenceFilter ? elements.evalCompetenceFilter.value : 'all';
    const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
    
    // Capturar los elementos del reporte
    const evaluationReportContainer = document.getElementById('evaluationReportContainer');
    const evaluationChart = document.getElementById('evaluationChart');
    const evalCompetenceChart = document.getElementById('evalCompetenceChart');
    
    if (!evaluationReportContainer || !evaluationChart) {
        utils.showMessage('Error al generar el reporte.', 'error');
        return;
    }
    
    // Capturar los gr√°ficos como im√°genes
    let evalChartImg = '';
    let evalCompChartImg = '';
    
    if (appState.charts.evaluationChart) {
        evalChartImg = `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="width:100%;">`;
    }
    
    if (appState.charts.evalCompetenceChart) {
        evalCompChartImg = `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="width:100%;">`;
    }
    
    // Construir el contenido del reporte
    const reportContent = `
        <div style="margin-bottom: 20px;">
            <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
            <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
            
            <div style="margin-top: 10px;">
                <strong>Filtros aplicados:</strong>
                <ul>
                    <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                </ul>
            </div>
        </div>
        
        <div>${evaluationReportContainer.outerHTML}</div>
        
        <div style="margin: 20px 0;">
            <h3>Distribuci√≥n de Calificaciones</h3>
            ${evalChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Rendimiento por Competencia</h3>
            ${evalCompChartImg}
        </div>
    `;
    
    const filename = `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.pdf`;
    
    utils.exportToPdf(reportContent, filename);
},

// Exportar reporte de evaluaci√≥n a Excel
exportEvaluationExcel: () => {
    const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
    if (!evalName) {
        utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
        return;
    }
    
    const competenceFilter = elements.evalCompetenceFilter ? elements.evalCompetenceFilter.value : 'all';
    const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
    
    const students = appState.processedData.students || [];
    
    // Obtener datos de la evaluaci√≥n
    const evalData = students.map(student => ({
        id: student.id,
        name: student.Nombre,
        grade: student[evalName]
    })).filter(item => item.grade !== undefined && item.grade !== null);
    
    // Calcular estad√≠sticas
    const grades = evalData.map(item => item.grade);
    
    if (grades.length === 0) {
        utils.showMessage('No hay datos para esta evaluaci√≥n.', 'error');
        return;
    }
    
    const sum = grades.reduce((acc, grade) => acc + grade, 0);
    const avg = sum / grades.length;
    const min = Math.min(...grades);
    const max = Math.max(...grades);
    
    // Calcular desviaci√≥n est√°ndar
    const squaredDiffs = grades.map(grade => Math.pow(grade - avg, 2));
    const avgSquaredDiff = squaredDiffs.reduce((acc, val) => acc + val, 0) / grades.length;
    const stdDev = Math.sqrt(avgSquaredDiff);
    
    // Contar estudiantes por debajo de la nota m√≠nima
    const passingGrade = appState.config.passingGrade || 3.0;
    const studentsAtRisk = evalData.filter(item => item.grade < passingGrade).length;
    
    // Calcular contribuci√≥n al total
    const weight = parseFloat(appState.config.weights[evalName]) / 100 || 0;
    const contribution = weight * 5;
    const currentContribution = avg * weight;
    
    // Obtener fecha de la evaluaci√≥n
    const evalDate = appState.config.dates[evalName] || 'No asignada';
    
    // Obtener competencias asociadas
    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
    
    // Filtrar competencias si es necesario
    let competencesToShow = evalCompetences;
    if (competenceValue.length > 0) {
        competencesToShow = evalCompetences.filter(comp => competenceValue.includes(comp));
    }
    
    // Crear datos para Excel
    const excelData = [];
    
    // Informaci√≥n de la evaluaci√≥n
    excelData.push({
        "Informaci√≥n": "Evaluaci√≥n",
        "Valor": evalName
    });
    
    excelData.push({
        "Informaci√≥n": "Grupo",
        "Valor": appState.config.selectedGroup
    });
    
    excelData.push({
        "Informaci√≥n": "Semestre",
        "Valor": appState.config.semester
    });
    
    excelData.push({
        "Informaci√≥n": "Fecha",
        "Valor": utils.formatDate(evalDate)
    });
    
    excelData.push({
        "Informaci√≥n": "Peso",
        "Valor": weight * 100 + "%"
    });
    
    excelData.push({
        "Informaci√≥n": "Filtro de competencia",
        "Valor": competenceFilter === 'all' ? 'Todas' : competenceFilter
    });
    
    // Fila vac√≠a
    excelData.push({});
    
    // Estad√≠sticas
    excelData.push({
        "Estad√≠stica": "Estudiantes Evaluados",
        "Valor": evalData.length
    });
    
    excelData.push({
        "Estad√≠stica": "Promedio",
        "Valor": utils.formatNumber(avg)
    });
    
    excelData.push({
        "Estad√≠stica": "Nota M√≠nima",
        "Valor": utils.formatNumber(min)
    });
    
    excelData.push({
        "Estad√≠stica": "Nota M√°xima",
        "Valor": utils.formatNumber(max)
    });
    
    excelData.push({
        "Estad√≠stica": "Desviaci√≥n Est√°ndar",
        "Valor": utils.formatNumber(stdDev)
    });
    
    excelData.push({
        "Estad√≠stica": "Estudiantes por debajo de " + passingGrade,
        "Valor": studentsAtRisk
    });
    
    excelData.push({
        "Estad√≠stica": "Contribuci√≥n Actual",
        "Valor": utils.formatNumber(currentContribution) + " / " + utils.formatNumber(contribution)
    });
    
    // Fila vac√≠a
    excelData.push({});
    
    // Competencias evaluadas
    excelData.push({
        "Competencia": "Competencia",
        "Indicadores": "Indicadores"
    });
    
    competencesToShow.forEach(compName => {
        const indicators = appState.processedData.indicators[compName] || [];
        
        excelData.push({
            "Competencia": compName,
            "Indicadores": indicators.join("; ")
        });
    });
    
    // Fila vac√≠a
    excelData.push({});
    
    // Lista de calificaciones
    excelData.push({
        "Estudiante": "Estudiante",
        "Calificaci√≥n": "Calificaci√≥n"
    });
    
    // Ordenar estudiantes por nombre
    evalData.sort((a, b) => a.name.localeCompare(b.name));
    
    evalData.forEach(item => {
        excelData.push({
            "Estudiante": item.name,
            "Calificaci√≥n": utils.formatNumber(item.grade)
        });
    });
    
    const filename = `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.xlsx`;
    
    utils.exportToExcel(excelData, filename);
},

// Imprimir reporte de evaluaci√≥n
printEvaluationReport: () => {
    const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
    if (!evalName) {
        utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
        return;
    }
    
    const competenceFilter = elements.evalCompetenceFilter ? elements.evalCompetenceFilter.value : 'all';
    
    // Capturar los elementos del reporte
    const evaluationReportContainer = document.getElementById('evaluationReportContainer');
    const evaluationChart = document.getElementById('evaluationChart');
    const evalCompetenceChart = document.getElementById('evalCompetenceChart');
    
    if (!evaluationReportContainer || !evaluationChart) {
        utils.showMessage('Error al generar el reporte.', 'error');
        return;
    }
    
    // Capturar los gr√°ficos como im√°genes
    let evalChartImg = '';
    let evalCompChartImg = '';
    
    if (appState.charts.evaluationChart) {
        evalChartImg = `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="width:100%;">`;
    }
    
    if (appState.charts.evalCompetenceChart) {
        evalCompChartImg = `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="width:100%;">`;
    }
    
    // Construir el contenido del reporte
    const reportContent = `
        <div style="margin-bottom: 20px;">
            <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
            <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
            
            <div style="margin-top: 10px;">
                <strong>Filtros aplicados:</strong>
                <ul>
                    <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                </ul>
            </div>
        </div>
        
        <div>${evaluationReportContainer.outerHTML}</div>
        
        <div style="margin: 20px 0;">
            <h3>Distribuci√≥n de Calificaciones</h3>
            ${evalChartImg}
        </div>
        
        <div style="margin: 20px 0;">
            <h3>Rendimiento por Competencia</h3>
            ${evalCompChartImg}
        </div>
    `;
    
    utils.printContent(reportContent);
},

// Vista previa de la l√≠nea de tiempo
previewTimelineReport: () => {
// john3
const studentValue = elements.timelineStudentSelect ? elements.timelineStudentSelect.value : 'group';
const competenceValue = elements.timelineCompetenceFilter ? elements.timelineCompetenceFilter.value : 'all';

// Obtener el nombre del estudiante si es un estudiante espec√≠fico
let studentName = "Rendimiento grupal";
if (studentValue !== 'group') {
    const student = appState.processedData.students.find(s => s.id === studentValue);
    if (student) {
        studentName = student.Nombre;
    }
}

// Capturar el contenedor de la l√≠nea de tiempo
const timelineContainer = document.getElementById('evaluationTimeline').cloneNode(true);

// Construir el contenido del reporte
const reportContent = `
    <div style="margin-bottom: 20px;">
        <h2>L√≠nea de Tiempo de Evaluaciones</h2>
        <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
        <p>Estudiante: ${studentName}</p>
        
        <div style="margin-top: 10px;">
            <strong>Filtros aplicados:</strong>
            <ul>
                <li>Competencia: ${competenceValue === 'all' ? 'Todas' : competenceValue}</li>
            </ul>
        </div>
    </div>
    
    <div class="timeline-container">
        <div class="timeline-header">
            <h3>L√≠nea de Tiempo de Evaluaciones</h3>
        </div>
        <div class="timeline">
            ${timelineContainer.innerHTML}
        </div>
    </div>
`;

utils.showPreview(
    'Vista Previa - L√≠nea de Tiempo',
    reportContent,
    'pdf',
    `linea_tiempo_${studentValue === 'group' ? 'grupo' : 'estudiante_' + studentName.replace(/\s+/g, '_')}.pdf`
);
},

// Exportar l√≠nea de tiempo a PDF
exportTimelinePdf: () => {
const studentValue = elements.timelineStudentSelect ? elements.timelineStudentSelect.value : 'group';
const competenceValue = elements.timelineCompetenceFilter ? elements.timelineCompetenceFilter.value : 'all';

// Obtener el nombre del estudiante si es un estudiante espec√≠fico
let studentName = "Rendimiento grupal";
if (studentValue !== 'group') {
    const student = appState.processedData.students.find(s => s.id === studentValue);
    if (student) {
        studentName = student.Nombre;
    }
}

// Capturar el contenedor de la l√≠nea de tiempo
const timelineContainer = document.getElementById('evaluationTimeline');

if (!timelineContainer) {
    utils.showMessage('Error al generar el reporte.', 'error');
    return;
}

// Construir el contenido del reporte
const reportContent = `
    <div style="margin-bottom: 20px;">
        <h2>L√≠nea de Tiempo de Evaluaciones</h2>
        <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
        <p>Estudiante: ${studentName}</p>
        
        <div style="margin-top: 10px;">
            <strong>Filtros aplicados:</strong>
            <ul>
                <li>Competencia: ${competenceValue === 'all' ? 'Todas' : competenceValue}</li>
            </ul>
        </div>
    </div>
    
    <div class="timeline-container" style="margin-top: 20px; padding: 20px;">
        <div class="timeline-header">
            <h3>L√≠nea de Tiempo de Evaluaciones</h3>
        </div>
        <div class="timeline">
            ${timelineContainer.innerHTML}
        </div>
    </div>
`;

const filename = `linea_tiempo_${studentValue === 'group' ? 'grupo' : 'estudiante_' + studentName.replace(/\s+/g, '_')}.pdf`;

utils.exportToPdf(reportContent, filename);
},

// Imprimir l√≠nea de tiempo
printTimelineReport: () => {
const studentValue = elements.timelineStudentSelect ? elements.timelineStudentSelect.value : 'group';
const competenceValue = elements.timelineCompetenceFilter ? elements.timelineCompetenceFilter.value : 'all';

// Obtener el nombre del estudiante si es un estudiante espec√≠fico
let studentName = "Rendimiento grupal";
if (studentValue !== 'group') {
    const student = appState.processedData.students.find(s => s.id === studentValue);
    if (student) {
        studentName = student.Nombre;
    }
}

// Capturar el contenedor de la l√≠nea de tiempo
const timelineContainer = document.getElementById('evaluationTimeline');

if (!timelineContainer) {
    utils.showMessage('Error al generar el reporte.', 'error');
    return;
}

// Construir el contenido del reporte
const reportContent = `
    <div style="margin-bottom: 20px;">
        <h2>L√≠nea de Tiempo de Evaluaciones</h2>
        <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
        <p>Estudiante: ${studentName}</p>
        
        <div style="margin-top: 10px;">
            <strong>Filtros aplicados:</strong>
            <ul>
                <li>Competencia: ${competenceValue === 'all' ? 'Todas' : competenceValue}</li>
            </ul>
        </div>
    </div>
    
    <div class="timeline-container" style="margin-top: 20px; padding: 20px;">
        <div class="timeline-header">
            <h3>L√≠nea de Tiempo de Evaluaciones</h3>
        </div>
        <div class="timeline">
            ${timelineContainer.innerHTML}
        </div>
    </div>
`;

utils.printContent(reportContent);
},

// Cerrar previsualizaci√≥n
closePreview: () => {
utils.closePreview();
},

// Confirmar exportaci√≥n
confirmExport: () => {
if (!appState.exportData.type || !appState.exportData.filename) {
    utils.closePreview();
    return;
}

if (appState.exportData.type === 'pdf') {
    // Identificar qu√© exportar en base al nombre de archivo
    if (appState.exportData.filename.includes('individual') || 
        appState.exportData.filename.includes('reporte_')) {
        eventHandlers.exportIndividualPdf();
    } else if (appState.exportData.filename.includes('grupal')) {
        eventHandlers.exportGroupPdf();
    } else if (appState.exportData.filename.includes('evaluacion')) {
        eventHandlers.exportEvaluationPdf();
    } else if (appState.exportData.filename.includes('linea_tiempo')) {
        eventHandlers.exportTimelinePdf();
    }
} else if (appState.exportData.type === 'excel') {
    // Identificar qu√© exportar en base al nombre de archivo
    if (appState.exportData.filename.includes('individual') || 
        appState.exportData.filename.includes('reporte_')) {
        eventHandlers.exportIndividualExcel();
    } else if (appState.exportData.filename.includes('grupal')) {
        eventHandlers.exportGroupExcel();
    } else if (appState.exportData.filename.includes('evaluacion')) {
        eventHandlers.exportEvaluationExcel();
    }
}

utils.closePreview();
}
};

// Funci√≥n adaptada para leer archivos Excel y CSV
async function readExcelOrCsvFile(file) {
return new Promise((resolve, reject) => {
const reader = new FileReader();

reader.onload = (e) => {
    try {
        const data = new Uint8Array(e.target.result);
        let result = {};
        
        // Determinar tipo de archivo
        const fileExtension = file.name.split('.').pop().toLowerCase();
        
        if (fileExtension === 'csv') {
            // Procesar archivo CSV
            const csvText = new TextDecoder().decode(data);
            const sheets = {};
            
            // Para archivos CSV, usamos el nombre del archivo como nombre de hoja
            const sheetName = file.name.replace(/\.[^/.]+$/, "");
            
            // Convertir CSV a objeto JSON
            const jsonData = csvToJson(csvText);
            sheets[sheetName] = jsonData;
            
            resolve(sheets);
        } else {
            // Procesar archivo Excel
            const workbook = XLSX.read(data, { 
                type: 'array', 
                cellDates: true,
                cellStyles: true,
                dateNF: 'yyyy-mm-dd'
            });
            
            const sheets = {};
            
            // Procesar cada hoja del archivo
            workbook.SheetNames.forEach(sheetName => {
                const worksheet = workbook.Sheets[sheetName];
                const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                    raw: false,
                    dateNF: 'yyyy-mm-dd'
                });
                sheets[sheetName] = jsonData;
            });
            
            resolve(sheets);
        }
    } catch (error) {
        reject(new Error(`Error al procesar el archivo: ${error.message}`));
    }
};

reader.onerror = (error) => {
    reject(new Error(`Error al leer el archivo: ${error.target.error.message}`));
};

reader.readAsArrayBuffer(file);
});
}

// Funci√≥n para convertir CSV a JSON
function csvToJson(csvText) {
// Determinar el delimitador (coma o punto y coma)
const delimiter = csvText.indexOf(';') !== -1 ? ';' : ',';

// Dividir el CSV en l√≠neas
const lines = csvText.split(/\r\n|\n/);

// Extraer los encabezados
const headers = lines[0].split(delimiter).map(header => header.trim().replace(/^["']|["']$/g, ''));

// Inicializar array para los resultados
const result = [];

// Procesar cada l√≠nea (excepto la primera que son los encabezados)
for (let i = 1; i < lines.length; i++) {
// Ignorar l√≠neas vac√≠as
if (lines[i].trim() === '') continue;

const obj = {};
const currentLine = lines[i].split(delimiter);

// Para cada encabezado, asignar el valor correspondiente
for (let j = 0; j < headers.length; j++) {
    let value = currentLine[j] ? currentLine[j].trim().replace(/^["']|["']$/g, '') : '';
    
    // Intentar convertir a n√∫mero si es posible
    if (!isNaN(value) && value !== '') {
        value = parseFloat(value);
    }
    
    // Intentar convertir a fecha si tiene formato de fecha
    if (/^\d{4}-\d{2}-\d{2}/.test(value)) {
        try {
            const date = new Date(value);
            if (!isNaN(date.getTime())) {
                value = date;
            }
        } catch (e) {
            // Si falla la conversi√≥n, mantener como string
        }
    }
    
    obj[headers[j]] = value;
}

result.push(obj);
}

return result;
}

// Procesar datos despu√©s de cargar archivos y configuraci√≥n
function processData() {
const selectedGroup = appState.config.selectedGroup;

if (!selectedGroup || !appState.studentsData || !appState.studentsData[selectedGroup]) {
throw new Error('Grupo no v√°lido o datos no cargados.');
}

// Obtener campos seleccionados
const selectedFields = appState.config.selectedFields || [];
const studentIdFields = appState.config.studentIdFields || [];

if (selectedFields.length === 0) {
throw new Error('No hay campos seleccionados para procesar.');
}

// Procesar estudiantes
const allStudents = appState.studentsData[selectedGroup];
const students = allStudents.map((student, index) => {
const filteredStudent = { id: `student-${index}` };

// Copiar campos seleccionados
selectedFields.forEach(field => {
    if (student[field] !== undefined) {
        // Convertir a n√∫mero si es un valor num√©rico
        if (typeof student[field] === 'string' && !isNaN(student[field]) && student[field].trim() !== '') {
            filteredStudent[field] = parseFloat(student[field]);
        } else {
            filteredStudent[field] = student[field];
        }
    }
});

// Establecer nombre del estudiante
if (studentIdFields.length > 0) {
    const studentNameField = studentIdFields[0];
    filteredStudent.Nombre = student[studentNameField] || `Estudiante ${index + 1}`;
} else {
    filteredStudent.Nombre = `Estudiante ${index + 1}`;
}

return filteredStudent;
});

appState.processedData.students = students;

// Procesar competencias (todas las hojas)
const allCompetences = [];
Object.values(appState.competencesData).forEach(sheetData => {
// Extraer competencias e indicadores normalizando nombres de campos
const processedData = sheetData.map(item => {
    const normalizedItem = {};
    
    // Buscar campos que coincidan con competencia e indicador (caso insensible)
    Object.keys(item).forEach(key => {
        const lowerKey = key.toLowerCase();
        if (lowerKey.includes('competen')) {
            normalizedItem.Competencia = item[key];
        } else if (lowerKey.includes('indica')) {
            normalizedItem.Indicador = item[key];
        } else {
            normalizedItem[key] = item[key]; // Mantener otros campos
        }
    });
    
    return normalizedItem;
}).filter(item => item.Competencia); // Solo incluir items con competencia definida

allCompetences.push(...processedData);
});

appState.processedData.competences = allCompetences;

// Obtener evaluaciones (campos seleccionados excepto IDs)
appState.processedData.evaluations = selectedFields.filter(
field => !studentIdFields.includes(field)
);

// Procesar indicadores
const indicators = {};
allCompetences.forEach(comp => {
if (!indicators[comp.Competencia]) {
    indicators[comp.Competencia] = [];
}
if (comp.Indicador && !indicators[comp.Competencia].includes(comp.Indicador)) {
    indicators[comp.Competencia].push(comp.Indicador);
}
});
appState.processedData.indicators = indicators;

// Inicializar mapeo de competencias si es nuevo
if (!appState.processedData.competenceMappings || Object.keys(appState.processedData.competenceMappings).length === 0) {
const competenceMappings = {};

appState.processedData.evaluations.forEach(evalName => {
    competenceMappings[evalName] = [];
});

appState.processedData.competenceMappings = competenceMappings;
}

// Cargar lista de estudiantes
if (elements.studentsList) {
elements.studentsList.innerHTML = '';
students.forEach(student => {
    const studentElement = document.createElement('div');
    studentElement.className = 'student-item';
    studentElement.dataset.id = student.id;
    studentElement.textContent = student.Nombre;
    
    studentElement.addEventListener('click', () => eventHandlers.selectStudent(student));
    
    elements.studentsList.appendChild(studentElement);
});
}

// Cargar lista de competencias para filtro de reporte grupal
const uniqueCompetences = utils.getUniqueCompetences();
if (elements.competenceFilter) {
elements.competenceFilter.innerHTML = '<option value="all">Todas</option>';
uniqueCompetences.forEach(comp => {
    elements.competenceFilter.innerHTML += `<option value="${comp}">${comp}</option>`;
});
}

if (elements.evalCompetenceFilter) {
elements.evalCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>';
uniqueCompetences.forEach(comp => {
    elements.evalCompetenceFilter.innerHTML += `<option value="${comp}">${comp}</option>`;
});
}

// Cargar lista de evaluaciones
if (elements.evaluationSelect) {
elements.evaluationSelect.innerHTML = '<option value="">Seleccione una evaluaci√≥n</option>';
appState.processedData.evaluations.forEach(eval => {
    elements.evaluationSelect.innerHTML += `<option value="${eval}">${eval}</option>`;
});
}

// Cargar lista de estudiantes para l√≠nea de tiempo
if (elements.timelineStudentSelect) {
elements.timelineStudentSelect.innerHTML = '<option value="group">Rendimiento grupal</option>';
students.forEach(student => {
    elements.timelineStudentSelect.innerHTML += `<option value="${student.id}">${student.Nombre}</option>`;
});
}

// Cargar lista de competencias para filtro de l√≠nea de tiempo
if (elements.timelineCompetenceFilter) {
elements.timelineCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>';
uniqueCompetences.forEach(comp => {
    elements.timelineCompetenceFilter.innerHTML += `<option value="${comp}">${comp}</option>`;
});
}

// Renderizar reporte grupal por defecto
renderGroupReport(students);
}

// Renderizar mapeo de competencias
function renderCompetenceMapping() {
if (!elements.competenceMappingBody) return;

const selectedSheet = elements.competenceSheetSelect ? elements.competenceSheetSelect.value : '';
const selectedGroup = elements.competenceMappingGroup ? elements.competenceMappingGroup.value : '';

// Actualizar selector de grupos para mapeo
if (elements.competenceMappingGroup) {
elements.competenceMappingGroup.innerHTML = '<option value="">Todos los grupos</option>';
if (appState.studentsData) {
    Object.keys(appState.studentsData).forEach(group => {
        elements.competenceMappingGroup.innerHTML += 
            `<option value="${group}" ${group === appState.config.selectedGroup ? 'selected' : ''}>${group}</option>`;
    });
}
}

// Mostrar mapeo actual
elements.competenceMappingBody.innerHTML = '';

if (!appState.config.weights) return;

// Mostrar solo evaluaciones con peso asignado
const evaluationsWithWeight = Object.keys(appState.config.weights)
.filter(evalName => parseFloat(appState.config.weights[evalName]) > 0);

evaluationsWithWeight.forEach(evalName => {
const mappedCompetences = appState.processedData.competenceMappings && 
                        appState.processedData.competenceMappings[evalName] || [];
const evalDate = appState.config.dates && appState.config.dates[evalName] || 'No asignada';

const mappingItem = document.createElement('div');
mappingItem.className = 'competence-mapping-item';
mappingItem.innerHTML = `
    <div class="competence-mapping-title">
        <h4>${evalName}</h4>
        <div class="date-tag">
            <span>Fecha:</span>
            <span>${utils.formatDate(evalDate)}</span>
        </div>
    </div>
    <div class="competence-list">
        ${mappedCompetences.length > 0 
            ? mappedCompetences.map(comp => `<div class="competence-tag">${comp}</div>`).join('') 
            : '<em>No hay competencias asociadas</em>'}
    </div>
`;

elements.competenceMappingBody.appendChild(mappingItem);
});
}

// Inicializar filtros de competencias
function initializeCompetenceFilters() {
const uniqueCompetences = utils.getUniqueCompetences();

// Filtros para reporte individual
if (elements.individualCompetenceFilter) {
elements.individualCompetenceFilter.innerHTML = '';
uniqueCompetences.forEach(comp => {
    const tag = document.createElement('div');
    tag.className = 'competence-filter-tag';
    tag.setAttribute('data-comp', comp);
    tag.textContent = comp;
    
    tag.addEventListener('click', () => {
        tag.classList.toggle('active');
        eventHandlers.filterIndividualByCompetence();
    });
    
    elements.individualCompetenceFilter.appendChild(tag);
});
}
}

// Inicializar datepickers para filtros
function initializeDatepickers() {
// Eliminar datepickers existentes
Object.values(appState.datepickers).forEach(dp => {
if (dp && typeof dp.destroy === 'function') {
    dp.destroy();
}
});
appState.datepickers = {};

// Datepicker para filtro individual
if (elements.individualStartDate) {
appState.datepickers.individualStartDate = flatpickr(elements.individualStartDate, {
    dateFormat: "Y-m-d",
    onChange: () => eventHandlers.filterIndividualByCompetence()
});
}

if (elements.individualEndDate) {
appState.datepickers.individualEndDate = flatpickr(elements.individualEndDate, {
    dateFormat: "Y-m-d",
    onChange: () => eventHandlers.filterIndividualByCompetence()
});
}

// Datepicker para filtro grupal
if (elements.groupStartDate) {
appState.datepickers.groupStartDate = flatpickr(elements.groupStartDate, {
    dateFormat: "Y-m-d",
    onChange: () => eventHandlers.filterByPerformance()
});
}

if (elements.groupEndDate) {
appState.datepickers.groupEndDate = flatpickr(elements.groupEndDate, {
    dateFormat: "Y-m-d",
    onChange: () => eventHandlers.filterByPerformance()
});
}
}

// Obtener competencias activas de los filtros
function getActiveCompetenceFilters(filterId) {
const activeCompetences = [];
const filterContainer = document.getElementById(filterId);

if (filterContainer) {
filterContainer.querySelectorAll('.competence-filter-tag.active').forEach(tag => {
    const comp = tag.getAttribute('data-comp');
    if (comp) activeCompetences.push(comp);
});
}

return activeCompetences;
}

// Renderizar tabla de notas del estudiante
function renderStudentGrades(student, filterCompetences = [], dateRange = {}) {
if (!elements.gradesTable || !appState.config.weights) return;

const tbody = elements.gradesTable.querySelector('tbody');
if (!tbody) return;

tbody.innerHTML = '';

let totalWeight = 0;
let completedWeight = 0;
let totalContribution = 0;

for (const evalName in appState.config.weights) {
// Verificar si debemos filtrar por competencia
if (filterCompetences.length > 0) {
    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
    if (!evalCompetences.some(comp => filterCompetences.includes(comp))) {
        continue;
    }
}

// Verificar si debemos filtrar por fecha
if (dateRange.start && dateRange.end) {
    const evalDate = appState.config.dates[evalName];
    if (evalDate) {
        try {
            const date = new Date(evalDate);
            const start = new Date(dateRange.start);
            const end = new Date(dateRange.end);
            if (date < start || date > end) {
                continue;
            }
        } catch (e) {
            console.error('Error al comparar fechas:', e);
        }
    }
}

const weight = parseFloat(appState.config.weights[evalName]) / 100 || 0;
totalWeight += weight;

const grade = student[evalName];
const contribution = grade !== undefined && grade !== null ? grade * weight : 0;
const evalDate = appState.config.dates[evalName] || '';

if (grade !== undefined && grade !== null) {
    completedWeight += weight;
    totalContribution += contribution;
}

const row = document.createElement('tr');

// Obtener competencias asociadas a esta evaluaci√≥n
const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
const competencesHtml = evalCompetences.length > 0 
    ? evalCompetences.map(comp => `<div class="competence-tag">${comp}</div>`).join('') 
    : '';

row.innerHTML = `
    <td>${evalName}</td>
    <td>${utils.formatDate(evalDate)}</td>
    <td>${grade !== undefined && grade !== null ? utils.formatNumber(grade) : 'Pendiente'}</td>
    <td>${utils.formatNumber(weight * 100)}%</td>
    <td>${grade !== undefined && grade !== null ? utils.formatNumber(contribution) : 'N/A'}</td>
`;

tbody.appendChild(row);
}

// Calcular nota final (adaptada para reportes parciales)
let finalGrade = 0;
if (completedWeight > 0) {
finalGrade = (totalContribution / completedWeight) * 100;
}

// Proyecci√≥n al 100%
const projectedGrade = finalGrade / 100;

// Agregar fila de total
const totalRow = document.createElement('tr');
totalRow.innerHTML = `
<td><strong>Total</strong></td>
<td></td>
<td></td>
<td><strong>${utils.formatNumber(totalWeight * 100)}%</strong></td>
<td><strong>${utils.formatNumber(totalContribution)}</strong></td>
`;
tbody.appendChild(totalRow);

// Agregar fila de nota actual
const currentGradeRow = document.createElement('tr');
currentGradeRow.innerHTML = `
<td colspan="4"><strong>Nota actual (${utils.formatNumber(completedWeight * 100)}% completado):</strong></td>
<td><strong>${utils.formatNumber(projectedGrade)}</strong></td>
`;
tbody.appendChild(currentGradeRow);
}

// Renderizar competencias del estudiante
function renderStudentCompetences(student, filterCompetences = [], dateRange = {}) {
if (!elements.competenceContainer) return;

elements.competenceContainer.innerHTML = '';

// Obtener competencias √∫nicas (filtradas si es necesario)
let competencesToShow = utils.getUniqueCompetences();
if (filterCompetences.length > 0) {
competencesToShow = competencesToShow.filter(comp => filterCompetences.includes(comp));
}

competencesToShow.forEach(compName => {
// Obtener evaluaciones relacionadas con esta competencia
const relatedEvals = [];

for (const evalKey in appState.processedData.competenceMappings) {
    const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
    
    if (evalCompetences.includes(compName)) {
        // Verificar filtro de fecha si es necesario
        if (dateRange.start && dateRange.end) {
            const evalDate = appState.config.dates[evalKey];
            if (evalDate) {
                try {
                    const date = new Date(evalDate);
                    const start = new Date(dateRange.start);
                    const end = new Date(dateRange.end);
                    if (date < start || date > end) {
                        continue;
                    }
                } catch (e) {
                    console.error('Error al comparar fechas:', e);
                }
            }
        }
        
        relatedEvals.push(evalKey);
    }
}

// Calcular promedio de estudiante para esta competencia
let compAvg = 0;
let evalCount = 0;

relatedEvals.forEach(evalName => {
    if (student[evalName] !== undefined && student[evalName] !== null) {
        compAvg += parseFloat(student[evalName]) || 0;
        evalCount++;
    }
});

if (evalCount > 0)
{
    compAvg = compAvg / evalCount;
}

// Calcular porcentaje de logro (considerando 5 como nota m√°xima)
const achievementPercentage = evalCount > 0 ? (compAvg / 5) * 100 : 0;

// Crear elemento de competencia
const compElement = document.createElement('div');
compElement.className = 'competence-item';
compElement.innerHTML = `
    <div><strong>${compName}</strong>${evalCount > 0 ? ` - ${utils.formatNumber(compAvg)}` : ' - Sin datos'}</div>
    <div class="competence-progress">
        <div class="competence-progress-bar" style="width: ${achievementPercentage}%"></div>
    </div>
`;

// Agregar indicadores
const indicators = appState.processedData.indicators[compName] || [];
if (indicators.length > 0) {
    const indicatorsHtml = indicators.map(ind => `
        <div class="indicator">${ind}</div>
    `).join('');
    
    compElement.innerHTML += `<div class="indicators">${indicatorsHtml}</div>`;
}

// Agregar evaluaciones relacionadas
if (relatedEvals.length > 0) {
    const evalHtml = relatedEvals.map(eval => `
        <div class="competence-tag">${eval}</div>
    `).join('');
    
    compElement.innerHTML += `
        <div style="margin-top: 10px; font-size: 12px;">
            <em>Evaluaciones:</em>
            <div class="competence-list">${evalHtml}</div>
        </div>
    `;
}

elements.competenceContainer.appendChild(compElement);
});
}

// Renderizar predicci√≥n
function renderPrediction(student, filterCompetences = []) {
if (!elements.predictionResults) return;

const prediction = utils.predictRequiredGrade(student, filterCompetences);

if (!prediction.possible) {
elements.predictionResults.innerHTML = `
    <div class="prediction-message">${prediction.message}</div>
`;
return;
}

if (prediction.requiredGrade <= 0) {
elements.predictionResults.innerHTML = `
    <div class="prediction-message">${prediction.message}</div>
`;
return;
}

const evalsList = prediction.evaluations.map(evalName => {
const evalDate = appState.config.dates[evalName] ? 
    ` (${utils.formatDate(appState.config.dates[evalName])})` : '';
return `
    <div class="prediction-value">
        ${evalName}${evalDate}: ${utils.formatNumber(prediction.requiredGrade)}
    </div>
`;
}).join('');

elements.predictionResults.innerHTML = `
<div class="prediction-message">${prediction.message}</div>
${evalsList}
<div class="prediction-note">
    Nota final proyectada si obtienes estas calificaciones: 
    <strong>${utils.formatNumber(appState.config.passingGrade)}</strong>
</div>
`;
}

// Renderizar reporte grupal
function renderGroupReport(students, filterCompetences = [], dateRange = {}) {
if (!elements.groupStatsContainer || !elements.riskStudentsList) return;

if (!students || students.length === 0) {
utils.showMessage('No hay estudiantes para mostrar.', 'info');
elements.groupStatsContainer.innerHTML = '<div class="message info">No hay estudiantes para mostrar</div>';
elements.riskStudentsList.innerHTML = '';
return;
}

// Calcular estad√≠sticas
const stats = utils.calculateGroupStats(students, filterCompetences, dateRange);

if (!stats) {
utils.showMessage('No hay datos suficientes para generar estad√≠sticas.', 'info');
elements.groupStatsContainer.innerHTML = '<div class="message info">No hay datos suficientes para generar estad√≠sticas</div>';
return;
}

// Mostrar estad√≠sticas
elements.groupStatsContainer.innerHTML = `
<div class="stat-card">
    <h3>Total Estudiantes</h3>
    <div class="stat-value">${stats.totalStudents}</div>
</div>
<div class="stat-card">
    <h3>Estudiantes Evaluados</h3>
    <div class="stat-value">${stats.evaluatedStudents}</div>
    <div class="stat-description">${Math.round((stats.evaluatedStudents / stats.totalStudents) * 100)}% del grupo</div>
</div>
<div class="stat-card">
    <h3>Promedio</h3>
    <div class="stat-value">${utils.formatNumber(stats.average)}</div>
</div>
<div class="stat-card">
    <h3>Nota M√≠nima</h3>
    <div class="stat-value">${utils.formatNumber(stats.min)}</div>
</div>
<div class="stat-card">
    <h3>Nota M√°xima</h3>
    <div class="stat-value">${utils.formatNumber(stats.max)}</div>
</div>
<div class="stat-card">
    <h3>Desviaci√≥n Est√°ndar</h3>
    <div class="stat-value">${utils.formatNumber(stats.stdDev)}</div>
</div>
<div class="stat-card">
    <h3>Estudiantes en Riesgo</h3>
    <div class="stat-value">${stats.studentsAtRisk}</div>
    <div class="stat-description">Nota < ${appState.config.passingGrade}</div>
</div>
`;

// Calcular rendimiento por competencia
const compPerformance = utils.calculateCompetencePerformance(
students, 
appState.processedData.competences,
dateRange
);

// Encontrar competencia con menor logro
let minCompetence = null;
let minValue = Infinity;

for (const compId in compPerformance) {
if (filterCompetences.length > 0 && !filterCompetences.includes(compId)) {
    continue;
}

if (compPerformance[compId].average < minValue && compPerformance[compId].average > 0) {
    minValue = compPerformance[compId].average;
    minCompetence = compId;
}
}

if (minCompetence) {
elements.groupStatsContainer.innerHTML += `
    <div class="stat-card">
        <h3>Competencia con menor logro</h3>
        <div class="stat-value">${minCompetence}</div>
        <div class="stat-description">Promedio: ${utils.formatNumber(minValue)}</div>
    </div>
`;
}

// Mostrar informaci√≥n de filtros aplicados
if (filterCompetences.length > 0 || (dateRange.start && dateRange.end)) {
let filterInfo = '<div class="stat-card"><h3>Filtros Aplicados</h3>';

if (filterCompetences.length > 0) {
    filterInfo += `<div class="stat-description">Competencias: ${filterCompetences.join(', ')}</div>`;
}

if (dateRange.start && dateRange.end) {
    filterInfo += `<div class="stat-description">Fechas: ${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}</div>`;
}

filterInfo += '</div>';
elements.groupStatsContainer.innerHTML += filterInfo;
}

// Mostrar estudiantes en riesgo
elements.riskStudentsList.innerHTML = '';

const studentsAtRisk = students.filter(s => 
utils.calculateFinalGrade(s, filterCompetences, dateRange) < appState.config.passingGrade
).sort((a, b) => 
utils.calculateFinalGrade(a, filterCompetences, dateRange) - utils.calculateFinalGrade(b, filterCompetences, dateRange)
);

if (studentsAtRisk.length === 0) {
elements.riskStudentsList.innerHTML = '<div class="risk-student-item">No hay estudiantes en riesgo</div>';
} else {
studentsAtRisk.forEach(student => {
    const finalGrade = utils.calculateFinalGrade(student, filterCompetences, dateRange);
    
    elements.riskStudentsList.innerHTML += `
        <div class="risk-student-item">
            <span class="name">${student.Nombre}</span>
            <span class="grade">${utils.formatNumber(finalGrade / 100)}</span>
        </div>
    `;
});
}

// Crear gr√°fico de grupo
renderGroupChart(students, filterCompetences, dateRange);

// Crear gr√°fico de competencias
renderCompetenceChart(students, compPerformance, filterCompetences);
}

// Renderizar gr√°fico de grupo
function renderGroupChart(students, filterCompetences = [], dateRange = {}) {
if (!elements.groupChart) return;

// Destruir gr√°fico anterior si existe
if (appState.charts.groupChart) {
appState.charts.groupChart.destroy();
}

// Preparar datos para el gr√°fico
const grades = students.map(student => 
utils.calculateFinalGrade(student, filterCompetences, dateRange) / 100
).filter(grade => grade > 0); // Filtrar calificaciones con valores v√°lidos

if (grades.length === 0) {
return; // No hay datos para mostrar
}

// Crear rangos de notas
const ranges = [
'0-1', '1-1.5', '1.5-2', '2-2.5', '2.5-3', 
'3-3.5', '3.5-4', '4-4.5', '4.5-5'
];

// Contar estudiantes por rango
const countByRange = ranges.map(range => {
const [min, max] = range.split('-').map(parseFloat);
return grades.filter(grade => grade >= min && grade < max).length;
});

// Determinar colores por rango
const passingGrade = appState.config.passingGrade;
const colors = ranges.map(range => {
const [min, max] = range.split('-').map(parseFloat);
return max <= passingGrade ? 'rgba(231, 76, 60, 0.7)' : 'rgba(46, 204, 113, 0.7)';
});

const borderColors = ranges.map(range => {
const [min, max] = range.split('-').map(parseFloat);
return max <= passingGrade ? 'rgba(231, 76, 60, 1)' : 'rgba(46, 204, 113, 1)';
});

// Crear gr√°fico
const ctx = elements.groupChart.getContext('2d');
appState.charts.groupChart = new Chart(ctx, {
type: 'bar',
data: {
    labels: ranges,
    datasets: [{
        label: 'Distribuci√≥n de Calificaciones',
        data: countByRange,
        backgroundColor: colors,
        borderColor: borderColors,
        borderWidth: 1
    }]
},
options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
        y: {
            beginAtZero: true,
            title: {
                display: true,
                text: 'N√∫mero de Estudiantes'
            },
            ticks: {
                precision: 0
            }
        },
        x: {
            title: {
                display: true,
                text: 'Rango de Notas'
            }
        }
    },
    plugins: {
        tooltip: {
            callbacks: {
                label: function(context) {
                    return `Estudiantes: ${context.raw}`;
                }
            }
        },
        legend: {
            display: false
        },
        title: {
            display: true,
            text: 'Distribuci√≥n de Calificaciones'
        }
    }
}
});
}

// Renderizar gr√°fico de competencias
function renderCompetenceChart(students, compPerformance, filterCompetences = []) {
if (!elements.competenceChart) return;

// Destruir gr√°fico anterior si existe
if (appState.charts.competenceChart) {
appState.charts.competenceChart.destroy();
}

// Filtrar competencias si es necesario
let competences = Object.keys(compPerformance);
if (filterCompetences.length > 0) {
competences = competences.filter(comp => filterCompetences.includes(comp));
}

// Filtrar competencias que tengan datos
competences = competences.filter(comp => compPerformance[comp].count > 0);

if (competences.length === 0) {
return; // No hay datos para mostrar
}

// Limitar a las 10 competencias m√°s relevantes si hay demasiadas
if (competences.length > 10) {
competences.sort((a, b) => compPerformance[a].average - compPerformance[b].average);
competences = competences.slice(0, 10);
}

// Preparar datos para el gr√°fico
const labels = competences;
const averages = competences.map(comp => compPerformance[comp].average);
const passRates = competences.map(comp => 
(compPerformance[comp].passStudents / compPerformance[comp].totalStudents) * 100
);

// Crear gr√°fico
const ctx = elements.competenceChart.getContext('2d');
appState.charts.competenceChart = new Chart(ctx, {
type: 'bar',
data: {
    labels: labels,
    datasets: [
        {
            label: 'Promedio',
            data: averages,
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: 'rgba(52, 152, 219, 1)',
            borderWidth: 1,
            yAxisID: 'y'
        },
        {
            label: 'Tasa de Aprobaci√≥n (%)',
            data: passRates,
            backgroundColor: 'rgba(46, 204, 113, 0.7)',
            borderColor: 'rgba(46, 204, 113, 1)',
            borderWidth: 1,
            type: 'line',
            yAxisID: 'y1'
        }
    ]
},
options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
        y: {
            beginAtZero: true,
            position: 'left',
            title: {
                display: true,
                text: 'Promedio'
            },
            suggestedMax: 5
        },
        y1: {
            beginAtZero: true,
            position: 'right',
            title: {
                display: true,
                text: 'Tasa de Aprobaci√≥n (%)'
            },
            grid: {
                drawOnChartArea: false
            },
            max: 100
        },
        x: {
            title: {
                display: true,
                text: 'Competencias'
            },
            ticks: {
                maxRotation: 45,
                minRotation: 45
            }
        }
    },
    plugins: {
        tooltip: {
            callbacks: {
                label: function(context) {
                    const datasetLabel = context.dataset.label;
                    const value = context.raw;
                    return `${datasetLabel}: ${value.toFixed(2)}${context.datasetIndex === 1 ? '%' : ''}`;
                }
            }
        },
        title: {
            display: true,
            text: 'Rendimiento por Competencia'
        }
    }
}
});
}

// Renderizar reporte por evaluaci√≥n
function renderEvaluationReport(evalName, filterCompetences = []) {
if (!elements.evaluationReportContainer || !elements.evaluationChart) return;

const students = appState.processedData.students;

// Obtener datos de la evaluaci√≥n
const evalData = students.map(student => ({
id: student.id,
name: student.Nombre,
grade: student[evalName]
})).filter(item => item.grade !== undefined && item.grade !== null);

// Ordenar por calificaci√≥n
evalData.sort((a, b) => b.grade - a.grade);

// Calcular estad√≠sticas
const grades = evalData.map(item => item.grade);

if (grades.length === 0) {
utils.showMessage('No hay datos para esta evaluaci√≥n.', 'error');
elements.evaluationReportContainer.innerHTML = '<div class="message error">No hay datos para esta evaluaci√≥n</div>';
return;
}

const sum = grades.reduce((acc, grade) => acc + grade, 0);
const avg = sum / grades.length;
const min = Math.min(...grades);
const max = Math.max(...grades);

// Calcular desviaci√≥n est√°ndar
const squaredDiffs = grades.map(grade => Math.pow(grade - avg, 2));
const avgSquaredDiff = squaredDiffs.reduce((acc, val) => acc + val, 0) / grades.length;
const stdDev = Math.sqrt(avgSquaredDiff);

// Contar estudiantes por debajo de la nota m√≠nima
const studentsAtRisk = evalData.filter(item => item.grade < appState.config.passingGrade).length;

// Calcular contribuci√≥n al total
const weight = parseFloat(appState.config.weights[evalName]) / 100 || 0;
const contribution = weight * 5;
const currentContribution = avg * weight;

// Obtener fecha de la evaluaci√≥n
const evalDate = appState.config.dates[evalName] || 'No asignada';

// Obtener competencias asociadas
const evalCompetences = appState.processedData.competenceMappings[evalName] || [];

// Filtrar competencias si es necesario
let competencesToShow = evalCompetences;
if (filterCompetences.length > 0) {
competencesToShow = evalCompetences.filter(comp => filterCompetences.includes(comp));
}

// Mostrar reporte
elements.evaluationReportContainer.innerHTML = `
<div class="report-section">
    <h3>Estad√≠sticas de ${evalName}</h3>
    <div style="margin-bottom: 10px; color: var(--dark-gray);">
        Fecha: ${utils.formatDate(evalDate)}
    </div>
    <div class="group-report-container">
        <div class="stat-card">
            <h3>Estudiantes Evaluados</h3>
            <div class="stat-value">${evalData.length}</div>
            <div class="stat-description">${Math.round((evalData.length / students.length) * 100)}% del grupo</div>
        </div>
        <div class="stat-card">
            <h3>Promedio</h3>
            <div class="stat-value">${utils.formatNumber(avg)}</div>
        </div>
        <div class="stat-card">
            <h3>Nota M√≠nima</h3>
            <div class="stat-value">${utils.formatNumber(min)}</div>
        </div>
        <div class="stat-card">
            <h3>Nota M√°xima</h3>
            <div class="stat-value">${utils.formatNumber(max)}</div>
        </div>
        <div class="stat-card">
            <h3>Desviaci√≥n Est√°ndar</h3>
            <div class="stat-value">${utils.formatNumber(stdDev)}</div>
        </div>
        <div class="stat-card">
            <h3>Estudiantes por debajo de ${appState.config.passingGrade}</h3>
            <div class="stat-value">${studentsAtRisk}</div>
        </div>
        <div class="stat-card">
            <h3>Peso en la Nota Final</h3>
            <div class="stat-value">${utils.formatNumber(weight * 100)}%</div>
        </div>
        <div class="stat-card">
            <h3>Contribuci√≥n Actual</h3>
            <div class="stat-value">${utils.formatNumber(currentContribution)} / ${utils.formatNumber(contribution)}</div>
        </div>
    </div>
</div>

<div class="report-section">
    <h3>Competencias Evaluadas</h3>
    <div class="competence-container">
`;

// Mostrar competencias relacionadas
if (competencesToShow.length === 0) {
elements.evaluationReportContainer.innerHTML += `
    <div class="competence-item">No hay competencias registradas para esta evaluaci√≥n</div>
`;
} else {
competencesToShow.forEach(compName => {
    const indicators = appState.processedData.indicators[compName] || [];
    
    elements.evaluationReportContainer.innerHTML += `
        <div class="competence-item">
            <div><strong>${compName}</strong></div>
            ${indicators.map(ind => `<div class="indicator">${ind}</div>`).join('')}
        </div>
    `;
});
}

elements.evaluationReportContainer.innerHTML += `
    </div>
</div>

<div class="report-section">
    <h3>Listado de Calificaciones</h3>
    <table class="grades-table">
        <thead>
            <tr>
                <th>Estudiante</th>
                <th>Calificaci√≥n</th>
            </tr>
        </thead>
        <tbody>
            ${evalData.map(item => `
                <tr>
                    <td>${item.name}</td>
                    <td>${utils.formatNumber(item.grade)}</td>
                </tr>
            `).join('')}
        </tbody>
    </table>
</div>
`;

// Crear gr√°fico de evaluaci√≥n
renderEvaluationChart(evalName, evalData);

// Crear gr√°fico de rendimiento por competencia en esta evaluaci√≥n
if (competencesToShow.length > 0) {
renderEvaluationCompetenceChart(evalName, evalData, competencesToShow);
} else {
if (appState.charts.evalCompetenceChart) {
    appState.charts.evalCompetenceChart.destroy();
    appState.charts.evalCompetenceChart = null;
}
}
}

// Crear gr√°fico de evaluaci√≥n
function renderEvaluationChart(evalName, evalData) {
if (!elements.evaluationChart) return;

// Destruir gr√°fico anterior si existe
if (appState.charts.evaluationChart) {
appState.charts.evaluationChart.destroy();
}

// Preparar datos para el gr√°fico
const grades = evalData.map(item => item.grade);

if (grades.length === 0) {
return; // No hay datos para mostrar
}

// Crear rangos de notas
const ranges = ['0-1', '1-2', '2-3', '3-4', '4-5'];

// Contar estudiantes por rango
const countByRange = ranges.map(range => {
const [min, max] = range.split('-').map(parseFloat);
return grades.filter(grade => grade >= min && grade < max).length;
});

// Determinar colores por rango
const passingGrade = appState.config.passingGrade;
const colors = ranges.map(range => {
const [min, max] = range.split('-').map(parseFloat);
return max <= passingGrade ? 'rgba(231, 76, 60, 0.7)' : 'rgba(46, 204, 113, 0.7)';
});

// Crear gr√°fico
const ctx = elements.evaluationChart.getContext('2d');
appState.charts.evaluationChart = new Chart(ctx, {
type: 'bar',
data: {
    labels: ranges,
    datasets: [{
        label: `Distribuci√≥n de Calificaciones - ${evalName}`,
        data: countByRange,
        backgroundColor: colors,
        borderColor: colors.map(color => color.replace('0.7', '1')),
        borderWidth: 1
    }]
},
options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
        y: {
            beginAtZero: true,
            title: {
                display: true,
                text: 'N√∫mero de Estudiantes'
            },
            ticks: {
                precision: 0
            }
        },
        x: {
            title: {
                display: true,
                text: 'Rango de Notas'
            }
        }
    },
    plugins: {
        tooltip: {
            callbacks: {
                label: function(context) {
                    return `Estudiantes: ${context.raw}`;
                }
            }
        },
        title: {
            display: true,
            text: `Distribuci√≥n de Calificaciones - ${evalName}`
        }
    }
}
});
}

// Crear gr√°fico de rendimiento por competencia en evaluaci√≥n
function renderEvaluationCompetenceChart(evalName, evalData, competences) {
if (!elements.evalCompetenceChart) return;

// Destruir gr√°fico anterior si existe
if (appState.charts.evalCompetenceChart) {
appState.charts.evalCompetenceChart.destroy();
}

// Calcular rendimiento por competencia en esta evaluaci√≥n
const compPerformance = utils.calculateEvaluationCompetencePerformance(
appState.processedData.students, 
evalName
);

// Preparar datos para el gr√°fico
const labels = competences;
const averages = competences.map(comp => compPerformance[comp] ? compPerformance[comp].average : 0);
const passRates = competences.map(comp => 
compPerformance[comp] ? 
(compPerformance[comp].passStudents / compPerformance[comp].totalStudents) * 100 : 
0
);

// Crear gr√°fico
const ctx = elements.evalCompetenceChart.getContext('2d');
appState.charts.evalCompetenceChart = new Chart(ctx, {
type: 'bar',
data: {
    labels: labels,
    datasets: [
        {
            label: 'Promedio',
            data: averages,
            backgroundColor: 'rgba(52, 152, 219, 0.7)',
            borderColor: 'rgba(52, 152, 219, 1)',
            borderWidth: 1,
            yAxisID: 'y'
        },
        {
            label: 'Tasa de Aprobaci√≥n (%)',
            data: passRates,
            backgroundColor: 'rgba(46, 204, 113, 0.7)',
            borderColor: 'rgba(46, 204, 113, 1)',
            borderWidth: 1,
            type: 'line',
            yAxisID: 'y1'
        }
    ]
},
options: {
    responsive: true,
    maintainAspectRatio: false,
    scales: {
        y: {
            beginAtZero: true,
            position: 'left',
            title: {
                display: true,
                text: 'Promedio'
            },
            suggestedMax: 5
        },
        y1: {
            beginAtZero: true,
            position: 'right',
            title: {
                display: true,
                text: 'Tasa de Aprobaci√≥n (%)'
            },
            grid: {
                drawOnChartArea: false
            },
            max: 100
        },
        x: {
            title: {
                display: true,
                text: 'Competencias'
            },
            ticks: {
                maxRotation: 45,
                minRotation: 45
            }
        }
    },
    plugins: {
        tooltip: {
            callbacks: {
                label: function(context) {
                    const datasetLabel = context.dataset.label;
                    const value = context.raw;
                    return `${datasetLabel}: ${value.toFixed(2)}${context.datasetIndex === 1 ? '%' : ''}`;
                }
            }
        },
        title: {
            display: true,
            text: `Rendimiento por Competencia - ${evalName}`
        }
    }
}
});
}

// Renderizar p√°gina de l√≠nea de tiempo
function renderTimelinePage() {
    // Verificar que existan los elementos necesarios
    if (!elements.timelineStudentSelect || !elements.evaluationTimeline) return;
    
    // Actualizar selector de estudiantes
    elements.timelineStudentSelect.innerHTML = '<option value="group">Rendimiento grupal</option>';
    
    appState.processedData.students.forEach(student => {
        const isSelected = student.id === appState.filters.timeline.student ? 'selected' : '';
        elements.timelineStudentSelect.innerHTML += `<option value="${student.id}" ${isSelected}>${student.Nombre}</option>`;
    });
    
    // Actualizar selector de competencias
    if (elements.timelineCompetenceFilter) {
        const competenceValue = appState.filters.timeline.competence || 'all';
        
        elements.timelineCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>';
        
        utils.getUniqueCompetences().forEach(comp => {
            const isSelected = comp === competenceValue ? 'selected' : '';
            elements.timelineCompetenceFilter.innerHTML += `<option value="${comp}" ${isSelected}>${comp}</option>`;
        });
    }
    
    // Renderizar l√≠nea de tiempo
    renderTimeline(
        appState.filters.timeline.student || 'group',
        appState.filters.timeline.competence
    );
}

        // Renderizar l√≠nea de tiempo
        function renderTimeline(studentId, competenceFilter = 'all') {
            if (!elements.evaluationTimeline) return;
            
            elements.evaluationTimeline.innerHTML = '';
            
            // Obtener evaluaciones con fechas
            const evaluationsWithDates = [];
            
            for (const evalName in appState.config.dates) {
                const date = appState.config.dates[evalName];
                if (!date) continue;
                
                // Filtrar por competencia si es necesario
                if (competenceFilter !== 'all') {
                    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
                    if (!evalCompetences.includes(competenceFilter)) continue;
                }
                
                evaluationsWithDates.push({
                    name: evalName,
                    date: new Date(date),
                    weight: appState.config.weights[evalName] || 0,
                    competences: appState.processedData.competenceMappings[evalName] || []
                });
            }
            
            // Ordenar por fecha
            evaluationsWithDates.sort((a, b) => a.date - b.date);
            
            if (evaluationsWithDates.length === 0) {
                elements.evaluationTimeline.innerHTML = '<div style="text-align: center; padding: 20px;">No hay evaluaciones con fechas asignadas.</div>';
                return;
            }
            
            // Obtener datos del estudiante o grupo
            let studentData = null;
            
            if (studentId !== 'group') {
                studentData = appState.processedData.students.find(s => s.id === studentId);
            }
            
            // Crear elementos de l√≠nea de tiempo
            evaluationsWithDates.forEach((eval, index) => {
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item';
                
                let grade = '';
                if (studentData) {
                    if (studentData[eval.name] !== undefined && studentData[eval.name] !== null) {
                        grade = `<div><strong>Nota:</strong> ${utils.formatNumber(studentData[eval.name])}</div>`;
                    } else {
                        grade = `<div><strong>Nota:</strong> Pendiente</div>`;
                    }
                } else {
                    // Calcular promedio grupal
                    const grades = [];
                    appState.processedData.students.forEach(student => {
                        if (student[eval.name] !== undefined && student[eval.name] !== null) {
                            grades.push(student[eval.name]);
                        }
                    });
                    
                    if (grades.length > 0) {
                        const avg = grades.reduce((sum, grade) => sum + grade, 0) / grades.length;
                        const totalStudents = appState.processedData.students.length;
                        grade = `
                            <div><strong>Promedio:</strong> ${utils.formatNumber(avg)}</div>
                            <div><strong>Estudiantes evaluados:</strong> ${grades.length} / ${totalStudents} 
                            (${Math.round((grades.length / totalStudents) * 100)}%)</div>
                        `;
                    } else {
                        grade = `<div><strong>Promedio:</strong> No disponible</div>`;
                    }
                }
                
                // Agregar competencias
                let competencesHtml = '';
                if (eval.competences.length > 0) {
                    competencesHtml = `
                        <div style="margin-top: 5px;">
                            <strong>Competencias:</strong>
                            <div class="competence-list">
                                ${eval.competences.map(comp => `<div class="competence-tag">${comp}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }
                
                timelineItem.innerHTML = `
                    <div class="timeline-content">
                        <h3>${eval.name}</h3>
                        <div class="timeline-date">${utils.formatDate(eval.date)}</div>
                        <div><strong>Peso:</strong> ${eval.weight}%</div>
                        ${grade}
                        ${competencesHtml}
                    </div>
                `;
                
                elements.evaluationTimeline.appendChild(timelineItem);
            });
        }

        // Inicializar la aplicaci√≥n
        function initApp() {
            // Event listeners para tabs
            if (elements.tabs) {
                elements.tabs.forEach(tab => {
                    tab.addEventListener('click', eventHandlers.tabClick);
                });
            }
            
            // Event listeners para archivos
            if (elements.studentsFile) {
                elements.studentsFile.addEventListener('change', eventHandlers.studentsFileChange);
            }
            if (elements.competencesFile) {
                elements.competencesFile.addEventListener('change', eventHandlers.competencesFileChange);
            }
            if (elements.loadFilesBtn) {
                elements.loadFilesBtn.addEventListener('click', eventHandlers.loadFiles);
            }
            
            // Event listeners para configuraci√≥n
            if (elements.groupSelect) {
                elements.groupSelect.addEventListener('change', eventHandlers.groupChange);
            }
            if (elements.competenceSheetSelect) {
                elements.competenceSheetSelect.addEventListener('change', eventHandlers.fieldSelectionChange);
            }
            if (elements.decimalPlaces) {
                elements.decimalPlaces.addEventListener('input', () => {
                    const value = parseInt(elements.decimalPlaces.value);
                    if (value < 2) elements.decimalPlaces.value = 2;
                    appState.config.decimalPlaces = value || 2;
                });
            }
            if (elements.passingGrade) {
                elements.passingGrade.addEventListener('input', () => {
                    appState.config.passingGrade = parseFloat(elements.passingGrade.value) || 3.0;
                });
            }
            if (elements.semesterSelect) {
                elements.semesterSelect.addEventListener('change', () => {
                    appState.config.semester = elements.semesterSelect.value;
                });
            }
            if (elements.saveConfigBtn) {
                elements.saveConfigBtn.addEventListener('click', eventHandlers.saveConfig);
            }
            
            // Event listeners para mapeo de competencias
            if (elements.competenceMappingGroup) {
                elements.competenceMappingGroup.addEventListener('change', renderCompetenceMapping);
            }
            if (elements.updateMappingBtn) {
                elements.updateMappingBtn.addEventListener('click', eventHandlers.updateCompetenceMapping);
            }
            
            // Event listeners para distribuci√≥n de pesos
            if (elements.distributeWeightsBtn) {
                elements.distributeWeightsBtn.addEventListener('click', eventHandlers.distributeWeights);
            }
            if (elements.clearWeightsBtn) {
                elements.clearWeightsBtn.addEventListener('click', eventHandlers.clearWeights);
            }
            
            // Event listeners para buscar estudiante
            if (elements.studentSearch) {
                elements.studentSearch.addEventListener('input', eventHandlers.searchStudent);
            }
            
            // Event listeners para filtros de reporte individual
            if (elements.individualStartDate || elements.individualEndDate) {
                // Se inicializan los datepickers en la funci√≥n initializeDatepickers
                // Los event listeners se agregan all√≠
            }
            
            // Event listeners para filtros de grupo
            if (elements.performanceFilter) {
                elements.performanceFilter.addEventListener('change', eventHandlers.filterByPerformance);
            }
            if (elements.competenceFilter) {
                elements.competenceFilter.addEventListener('change', eventHandlers.filterByPerformance);
            }
            // Event listeners para datepickers de grupo en initializeDatepickers
            
            // Event listeners para filtros de evaluaci√≥n
            if (elements.evaluationSelect) {
                elements.evaluationSelect.addEventListener('change', eventHandlers.selectEvaluation);
            }
            if (elements.evalCompetenceFilter) {
                elements.evalCompetenceFilter.addEventListener('change', eventHandlers.filterEvaluationByCompetence);
            }
            
            // Event listeners para filtros de l√≠nea de tiempo
            if (elements.timelineStudentSelect) {
                elements.timelineStudentSelect.addEventListener('change', eventHandlers.selectTimelineStudent);
            }
            if (elements.timelineCompetenceFilter) {
                elements.timelineCompetenceFilter.addEventListener('change', eventHandlers.filterTimelineByCompetence);
            }
            
            // Event listeners para exportar/imprimir reporte individual
            if (elements.previewIndividualBtn) {
                elements.previewIndividualBtn.addEventListener('click', eventHandlers.previewIndividualReport);
            }
            if (elements.exportPdfBtn) {
                elements.exportPdfBtn.addEventListener('click', eventHandlers.exportIndividualPdf);
            }
            if (elements.exportExcelBtn) {
                elements.exportExcelBtn.addEventListener('click', eventHandlers.exportIndividualExcel);
            }
            if (elements.printBtn) {
                elements.printBtn.addEventListener('click', eventHandlers.printIndividualReport);
            }
            
            // Event listeners para exportar/imprimir reporte grupal
            if (elements.previewGroupBtn) {
                elements.previewGroupBtn.addEventListener('click', eventHandlers.previewGroupReport);
            }
            if (elements.exportGroupPdfBtn) {
                elements.exportGroupPdfBtn.addEventListener('click', eventHandlers.exportGroupPdf);
            }
            if (elements.exportGroupExcelBtn) {
                elements.exportGroupExcelBtn.addEventListener('click', eventHandlers.exportGroupExcel);
            }
            if (elements.printGroupBtn) {
                elements.printGroupBtn.addEventListener('click', eventHandlers.printGroupReport);
            }
            
            // Event listeners para exportar/imprimir reporte por evaluaci√≥n
            if (elements.previewEvalBtn) {
                elements.previewEvalBtn.addEventListener('click', eventHandlers.previewEvaluationReport);
            }
            if (elements.exportEvalPdfBtn) {
                elements.exportEvalPdfBtn.addEventListener('click', eventHandlers.exportEvaluationPdf);
            }
            if (elements.exportEvalExcelBtn) {
                elements.exportEvalExcelBtn.addEventListener('click', eventHandlers.exportEvaluationExcel);
            }
            if (elements.printEvalBtn) {
                elements.printEvalBtn.addEventListener('click', eventHandlers.printEvaluationReport);
            }
            
            // Event listeners para exportar/imprimir l√≠nea de tiempo
            if (elements.previewTimelineBtn) {
                elements.previewTimelineBtn.addEventListener('click', eventHandlers.previewTimelineReport);
            }
            if (elements.exportTimelinePdfBtn) {
                elements.exportTimelinePdfBtn.addEventListener('click', eventHandlers.exportTimelinePdf);
            }
            if (elements.printTimelineBtn) {
                elements.printTimelineBtn.addEventListener('click', eventHandlers.printTimelineReport);
            }
            
            // Event listeners para previsualizaci√≥n
            if (elements.previewClose) {
                elements.previewClose.addEventListener('click', eventHandlers.closePreview);
            }
            if (elements.cancelPreviewBtn) {
                elements.cancelPreviewBtn.addEventListener('click', eventHandlers.closePreview);
            }
            if (elements.confirmExportBtn) {
                elements.confirmExportBtn.addEventListener('click', eventHandlers.confirmExport);
            }
        }

        // Iniciar la aplicaci√≥n cuando el DOM est√© cargado
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
