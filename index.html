<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema de Informes Acad√©micos</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flatpickr/4.6.13/flatpickr.min.css">
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2ecc71;
            --warning-color: #e74c3c;
            --text-color: #2c3e50;
            --light-gray: #ecf0f1;
            --border-color: #bdc3c7;
            --hover-color: #2980b9;
            --success-color: #27ae60;
            --info-color: #9b59b6;
            --dark-gray: #7f8c8d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
        }

        body {
            background-color: #f9f9f9;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        header h1 {
            color: white;
            font-size: 24px;
            margin-bottom: 5px;
        }

        header p {
            color: rgba(255, 255, 255, 0.9);
            font-size: 16px;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 1px solid transparent;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
            font-weight: 500;
        }

        .tab.active {
            background-color: white;
            border-color: var(--border-color);
            color: var(--primary-color);
            border-bottom: 2px solid var(--primary-color);
        }

        .tab:hover:not(.active) {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .tab-content {
            display: none;
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }

        .tab-content.active {
            display: block;
        }

        .file-upload {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .upload-box {
            border: 2px dashed var(--border-color);
            padding: 30px;
            text-align: center;
            border-radius: 5px;
            transition: all 0.3s ease;
            background-color: var(--light-gray);
        }

        .upload-box:hover {
            border-color: var(--primary-color);
            background-color: rgba(52, 152, 219, 0.05);
        }

        .upload-box p {
            margin-bottom: 15px;
            font-size: 16px;
        }

        .file-btn {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-btn:hover {
            background-color: var(--hover-color);
        }

        .hidden {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            font-size: 14px;
        }

        .config-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 100%;
            overflow-x: auto;
        }

        .config-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }

        .config-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .config-item label {
            font-weight: 500;
            font-size: 14px;
        }

        .config-item input, .config-item select, .config-item .flatpickr-input {
            padding: 8px 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            font-size: 14px;
        }

        .config-item input:focus, .config-item select:focus, .config-item .flatpickr-input:focus {
            border-color: var(--primary-color);
            outline: none;
        }

        .weight-container {
            display: flex;
            align-items: flex-start;
            flex-wrap: wrap;
            padding-bottom: 10px;
            gap: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .weight-item {
            display: flex;
            flex-direction: column;
            min-width: 200px;
            margin-bottom: 10px;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: 5px;
            border-left: 3px solid var(--primary-color);
        }

        .weight-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .weight-item-header h4 {
            font-size: 16px;
            color: var(--primary-color);
        }

        .weight-item-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .eval-date-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .eval-date-container label {
            font-size: 14px;
            font-weight: 500;
        }

        .competence-selector {
            margin-top: 10px;
            padding: 5px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid var(--border-color);
        }

        .competence-selector h5 {
            margin-bottom: 10px;
            color: var(--text-color);
            font-size: 14px;
        }

        .competence-checkbox-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            max-height: 120px;
            overflow-y: auto;
            padding: 5px;
        }

        .competence-checkbox {
            display: flex;
            align-items: center;
            padding: 3px 5px;
            background-color: var(--light-gray);
            border-radius: 3px;
            font-size: 12px;
        }

        .competence-checkbox input {
            margin-right: 5px;
        }

        .weight-actions {
            display: flex;
            gap: 10px;
            margin: 15px 0;
        }

        .weight-validation {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-size: 14px;
            display: none;
        }
        
        .field-selection {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background-color: var(--light-gray);
            border-radius: 5px;
        }
        
        .field-checkbox {
            display: flex;
            align-items: center;
            padding: 5px 10px;
            background-color: white;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .field-checkbox:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }
        
        .field-checkbox input {
            margin-right: 5px;
        }
        
        .field-checkbox.student-id {
            background-color: rgba(46, 204, 113, 0.1);
        }
        
        .field-checkbox.grade-field {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .weight-validation.valid {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--success-color);
            display: block;
        }

        .weight-validation.invalid {
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--warning-color);
            display: block;
        }

        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 16px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn:hover {
            background-color: var(--hover-color);
        }

        .btn:disabled {
            background-color: var(--light-gray);
            color: var(--text-color);
            cursor: not-allowed;
        }

        .btn-success {
            background-color: var(--secondary-color);
        }

        .btn-success:hover {
            background-color: var (--success-color);
        }

        .btn-warning {
            background-color: var(--warning-color);
        }

        .btn-warning:hover {
            background-color: #c0392b;
        }

        .btn-info {
            background-color: var(--info-color);
        }

        .btn-info:hover {
            background-color: #8e44ad;
        }

        .btn-sm {
            padding: 5px 10px;
            font-size: 12px;
        }

        .students-list {
            margin: 20px 0;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .student-item {
            padding: 10px 15px;
            border-bottom: 1px solid var (--light-gray);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .student-item:hover {
            background-color: rgba(52, 152, 219, 0.1);
        }

        .student-item.selected {
            background-color: rgba(52, 152, 219, 0.2);
            border-left: 3px solid var(--primary-color);
        }

        .report-container {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .report-header {
            border-bottom: 1px solid var(--light-gray);
            padding-bottom: 10px;
            margin-bottom: 20px;
        }

        .report-body {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }

        .report-section {
            margin-bottom: 10px;
        }

        .report-section h3 {
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 1px solid var (--light-gray);
        }

        .grades-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }

        .grades-table th, .grades-table td {
            border: 1px solid var(--border-color);
            padding: 8px 12px;
            text-align: left;
        }

        .grades-table th {
            background-color: var(--light-gray);
            font-weight: 500;
        }

        .chart-container {
            height: 300px;
            margin-bottom: 5px;
        }

        .competence-container {
            margin-top: 20px;
        }

        .competence-item {
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: rgba(52, 152, 219, 0.1);
        }

        .competence-progress {
            margin-top: 5px;
            background-color: var(--light-gray);
            height: 10px;
            border-radius: 5px;
            overflow: hidden;
        }

        .competence-progress-bar {
            height: 100%;
            background-color: var(--primary-color);
            border-radius: 5px;
        }

        .prediction-container {
            padding: 15px;
            background-color: rgba(46, 204, 113, 0.1);
            border-radius: 4px;
            margin-top: 20px;
        }

        .prediction-value {
            font-size: 18px;
            font-weight: 500;
            color: var (--secondary-color);
            margin-top: 10px;
        }

        .export-options {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .group-report-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }

        .stat-card {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .stat-card h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 500;
            color: var(--primary-color);
        }

        .stat-description {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .risk-students {
            margin-top: 20px;
        }

        .risk-students h3 {
            margin-bottom: 10px;
        }

        .risk-student-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 10px;
            border-bottom: 1px solid var (--light-gray);
        }

        .risk-student-item .name {
            font-weight: 500;
        }

        .risk-student-item .grade {
            color: var(--warning-color);
        }

        .filter-container {
            margin-bottom: 10px;
            padding: 15px;
            background-color: var(--light-gray);
            border-radius: 1px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .filter-item {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 150px;
        }

        .evaluation-report {
            margin-top: 20px;
        }

        .indicator {
            margin-top: 5px;
            padding-left: 20px;
            font-size: 14px;
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.8);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .spinner {
            border: 5px solid var(--light-gray);
            border-top: 5px solid var(--primary-color);
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin-bottom: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .message {
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 15px;
            font-size: 14px;
        }

        .message.error {
            background-color: rgba(231, 76, 60, 0.2);
            color: var(--warning-color);
        }

        .message.success {
            background-color: rgba(46, 204, 113, 0.2);
            color: var(--success-color);
        }

        .message.info {
            background-color: rgba(52, 152, 219, 0.2);
            color: var(--primary-color);
        }

        .competence-mapping-container {
            margin-top: 20px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
        }

        .competence-mapping-header {
            background-color: var(--light-gray);
            padding: 10px 15px;
            font-weight: 500;
        }

        .competence-mapping-body {
            padding: 15px;
            max-height: 400px;
            overflow-y: auto;
        }

        .competence-mapping-item {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--light-gray);
        }

        .competence-mapping-item:last-child {
            margin-bottom: 0;
            padding-bottom: 0;
            border-bottom: none;
        }

        .competence-mapping-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .competence-mapping-title h4 {
            font-size: 16px;
            color: var(--primary-color);
        }

        .competence-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .competence-tag {
            background-color: rgba(52, 152, 219, 0.1);
            color: var(--primary-color);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
        }

        .date-tag {
            background-color: rgba(155, 89, 182, 0.1);
            color: var(--info-color);
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .timeline-container {
            margin-top: 20px;
            padding: 20px;
            background-color: white;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .timeline-header {
            margin-bottom: 20px;
        }

        .timeline {
            position: relative;
            max-width: 1200px;
            margin: 0 auto;
        }

        .timeline::after {
            content: '';
            position: absolute;
            width: 6px;
            background-color: var(--light-gray);
            top: 0;
            bottom: 0;
            left: 50%;
            margin-left: -3px;
        }

        .timeline-item {
            padding: 10px 40px;
            position: relative;
            background-color: inherit;
            width: 50%;
        }

        .timeline-item:nth-child(odd) {
            left: 0;
        }

        .timeline-item:nth-child(even) {
            left: 50%;
        }

        .timeline-content {
            padding: 15px;
            background-color: white;
            position: relative;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            border-left: 4px solid var(--primary-color);
        }

        .timeline-item:nth-child(even) .timeline-content {
            border-left: none;
            border-right: 4px solid var(--secondary-color);
        }

        .timeline-content h3 {
            margin-bottom: 5px;
            color: var(--primary-color);
        }

        .timeline-item:nth-child(even) .timeline-content h3 {
            color: var(--secondary-color);
        }

        .timeline-date {
            color: var(--dark-gray);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .timeline-item::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: white;
            border: 4px solid var(--primary-color);
            top: 15px;
            right: -12px;
            border-radius: 50%;
            z-index: 1;
        }

        .timeline-item:nth-child(even)::after {
            left: -12px;
            border-color: var(--secondary-color);
        }

        .preview-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            display: flex;
            justify-content: center;
            align-items: center;
            display: none;
        }

        .preview-content {
            background-color: white;
            border-radius: 5px;
            width: 80%;
            max-width: 900px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .preview-header {
            padding: 15px 20px;
            background-color: var(--primary-color);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-radius: 5px 5px 0 0;
        }

        .preview-body {
            padding: 20px;
        }

        .preview-close {
            color: white;
            font-size: 20px;
            cursor: pointer;
        }

        .preview-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 15px 20px;
            background-color: var(--light-gray);
            border-radius: 0 0 5px 5px;
        }

        .competence-filter-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .competence-filter-tag {
            background-color: var(--light-gray);
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .competence-filter-tag:hover {
            background-color: rgba(52, 152, 219, 0.2);
        }

        .competence-filter-tag.active {
            background-color: var(--primary-color);
            color: white;
        }

        .date-range-filter {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .date-range-filter input {
            max-width: 120px;
        }

        @media (max-width: 768px) {
            .report-body {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-direction: column;
                border-bottom: none;
            }

            .tab {
                border-radius: 0;
                margin-right: 0;
                border: 1px solid var(--border-color);
                margin-bottom: 2px;
            }

            .tab.active {
                border-bottom: 1px solid var(--primary-color);
            }

            .config-row {
                grid-template-columns: 1fr;
            }

            .timeline::after {
                left: 31px;
            }

            .timeline-item {
                width: 100%;
                padding-left: 70px;
                padding-right: 25px;
            }

            .timeline-item:nth-child(even) {
                left: 0;
            }

            .timeline-item::after {
                left: 18px;
                top: 15px;
            }

            .timeline-item:nth-child(even)::after {
                left: 18px;
            }

            .timeline-item:nth-child(even) .timeline-content {
                border-right: none;
                border-left: 4px solid var(--secondary-color);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Sistema de Informes Acad√©micos</h1>
            <p>Generaci√≥n de informes acad√©micos basados en competencias y evaluaciones</p>
        </header>

        <div class="tabs">
            <div class="tab active" data-tab="upload">Carga de Archivos</div>
            <div class="tab" data-tab="config">Configuraci√≥n</div>
            <div class="tab" data-tab="mapping">Mapeo de Competencias</div>
            <div class="tab" data-tab="individual">Reporte Individual</div>
            <div class="tab" data-tab="group">Reporte Grupal</div>
            <div class="tab" data-tab="evaluation">Reporte por Evaluaci√≥n</div>
            <div class="tab" data-tab="timeline">L√≠nea de Tiempo</div>
        </div>

        <div id="messageContainer"></div>

        <!-- Tab: Carga de Archivos -->
        <div class="tab-content active" id="upload">
            <div class="file-upload">
                <div class="upload-box">
                    <p>Archivo de Notas de Estudiantes (.xlsx, .xls, .csv)</p>
                    <label class="file-btn">
                        Seleccionar Archivo
                        <input type="file" id="studentsFile" class="hidden" accept=".xlsx,.xls,.csv">
                    </label>
                    <div id="studentsFileInfo" class="file-info"></div>
                </div>

                <div class="upload-box">
                    <p>Archivo de Competencias y Criterios (.xlsx, .xls, .csv)</p>
                    <label class="file-btn">
                        Seleccionar Archivo
                        <input type="file" id="competencesFile" class="hidden" accept=".xlsx,.xls,.csv">
                    </label>
                    <div id="competencesFileInfo" class="file-info"></div>
                </div>

                <button id="loadFilesBtn" class="btn" disabled>Cargar Archivos</button>
            </div>
        </div>

        <!-- Tab: Configuraci√≥n -->
        <div class="tab-content" id="config">
            <div class="config-container">
                <div class="config-row">
                    <div class="config-item">
                        <label for="decimalPlaces">Decimales a mostrar</label>
                        <input type="number" id="decimalPlaces" min="2" value="2">
                    </div>

                    <div class="config-item">
                        <label for="passingGrade">Nota m√≠nima aprobatoria</label>
                        <input type="number" id="passingGrade" min="0" step="0.01" value="3.00">
                    </div>

                    <div class="config-item">
                        <label for="groupSelect">Grupo</label>
                        <select id="groupSelect">
                            <option value="">Seleccione un grupo</option>
                        </select>
                    </div>

                    <div class="config-item">
                        <label for="semesterSelect">Semestre/Periodo</label>
                        <select id="semesterSelect">
                            <option value="2025-1">2025-1</option>
                            
                        <option value="2024-2">2024-2</option>
                        <option value="2024-1">2024-1</option>
                        <option value="2023-2">2023-2</option>
</select>
</div>
</div>

<div class="config-row" id="fieldSelectionContainer">
<h3>Selecci√≥n de Campos</h3>
<p>Seleccione los campos que desea incluir en el an√°lisis:</p>
<div id="availableFields" class="field-selection">
<!-- Los campos disponibles se generar√°n din√°micamente -->
</div>
</div>

<h3>Pesos y Fechas de Evaluaciones</h3>
<div class="weight-container" id="weightContainer">
<!-- Los pesos de evaluaci√≥n se generar√°n din√°micamente -->
</div>

<div class="weight-actions">
<button id="distributeWeightsBtn" class="btn">Distribuir Pesos Equitativamente</button>
<button id="clearWeightsBtn" class="btn btn-warning">Limpiar Pesos</button>
</div>

<div id="weightValidation" class="weight-validation">
Los pesos deben sumar exactamente 100%
</div>

<button id="saveConfigBtn" class="btn btn-success">Guardar Configuraci√≥n</button>
</div>
</div>

<!-- Tab: Mapeo de Competencias -->
<div class="tab-content" id="mapping">
<div class="config-row">
<div class="config-item">
<label for="competenceSheetSelect">Hoja de Competencias</label>
<select id="competenceSheetSelect">
<option value="">Seleccione una hoja</option>
</select>
</div>
<div class="config-item">
<label for="competenceMappingGroup">Filtrar por grupo</label>
<select id="competenceMappingGroup">
<option value="">Todos los grupos</option>
</select>
</div>
</div>

<div class="competence-mapping-container">
<div class="competence-mapping-header">
Mapeo de Competencias a Evaluaciones
</div>
<div class="competence-mapping-body" id="competenceMappingBody">
<!-- El mapeo de competencias se generar√° din√°micamente -->
</div>
</div>

<button id="updateMappingBtn" class="btn btn-success" style="margin-top: 20px;">Actualizar Mapeo</button>
</div>

<!-- Tab: Reporte Individual -->
<div class="tab-content" id="individual">
<div class="filter-container">
<div class="filter-item">
<label for="studentSearch">Buscar estudiante</label>
<input type="text" id="studentSearch" placeholder="Nombre del estudiante">
</div>

<div class="filter-item">
<label>Filtrar por competencia</label>
<div id="individualCompetenceFilter" class="competence-filter-group">
<!-- Los filtros de competencia se generar√°n din√°micamente -->
</div>
</div>

<div class="filter-item">
<label>Rango de fechas</label>
<div class="date-range-filter">
<input type="text" id="individualStartDate" placeholder="Fecha inicial" class="flatpickr-input">
<span>a</span>
<input type="text" id="individualEndDate" placeholder="Fecha final" class="flatpickr-input">
</div>
</div>
</div>

<div class="students-list" id="studentsList">
<!-- La lista de estudiantes se generar√° din√°micamente -->
</div>

<div class="report-container" id="individualReport">
<div class="report-header">
<h2 id="studentName">Seleccione un estudiante</h2>
<div id="studentInfo" style="color: var(--dark-gray);"></div>
</div>
<!-- Elimino el grid de dos columnas para el reporte individual -->
<div class="report-section">
<h3>Evaluaciones</h3>
<table class="grades-table" id="gradesTable">
<thead>
    <tr>
        <th>Evaluaci√≥n</th>
        <th>Fecha</th>
        <th>Nota</th>
        <th>Peso</th>
        <th>Contribuci√≥n</th>
        <th>Competencias</th>
      </tr>
</thead>
<tbody>
    <!-- Las evaluaciones se generar√°n din√°micamente -->
</tbody>
</table>
</div>

<!-- Competencias debajo de la tabla, ocupando todo el ancho -->
<div class="report-section" style="margin-top: 10px;">
  <div style="display: flex; align-items: center; margin-bottom: 8px;">
    <h3 style="margin: 0;">Competencias</h3>
    <span id="competenceSelectorContainer" style="margin-left: 16px;"></span>
  </div>
  <div class="competence-container" id="competenceContainer" style="margin-top: 10px;">
    <!-- Las competencias se generar√°n din√°micamente -->
  </div>
</div>

<div class="prediction-container" id="predictionContainer">
<h3>Predicci√≥n</h3>
<p>Para aprobar el curso, este estudiante necesita obtener:</p>
<div id="predictionResults">
<!-- Las predicciones se generar√°n din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewIndividualBtn" class="btn btn-info">Vista Previa</button>
<button id="exportPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printBtn" class="btn">Imprimir</button>
</div>
</div>
</div>

<!-- Tab: Reporte Grupal -->
<div class="tab-content" id="group">
<div class="filter-container">
<div class="filter-item">
<label for="performanceFilter">Filtrar por rendimiento</label>
<select id="performanceFilter">
<option value="all">Todos</option>
<option value="high">Alto</option>
<option value="medium">Medio</option>
<option value="low">Bajo</option>
</select>
</div>

<div class="filter-item">
<label for="competenceFilter">Filtrar por competencia</label>
<select id="competenceFilter">
<option value="all">Todas</option>
</select>
</div>

<div class="filter-item">
<label>Rango de fechas</label>
<div class="date-range-filter">
<input type="text" id="groupStartDate" placeholder="Fecha inicial" class="flatpickr-input">
<span>a</span>
<input type="text" id="groupEndDate" placeholder="Fecha final" class="flatpickr-input">
</div>
</div>
</div>

<div class="group-report-container" id="groupStatsContainer">
<!-- Las estad√≠sticas grupales se generar√°n din√°micamente -->
</div>

<div class="chart-container">
<canvas id="groupChart"></canvas>
</div>

<div class="chart-container">
<h3>Rendimiento por Competencia</h3>
<canvas id="competenceChart"></canvas>
</div>

<div class="risk-students" id="riskStudentsContainer">
<h3>Estudiantes en riesgo</h3>
<div id="riskStudentsList">
<!-- Los estudiantes en riesgo se generar√°n din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewGroupBtn" class="btn btn-info">Vista Previa</button>
<button id="exportGroupPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportGroupExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printGroupBtn" class="btn">Imprimir</button>
</div>
</div>

<!-- Tab: Reporte por Evaluaci√≥n -->
<div class="tab-content" id="evaluation">
<div class="filter-container">
<div class="filter-item">
<label for="evaluationSelect">Seleccionar evaluaci√≥n</label>
<select id="evaluationSelect">
<option value="">Seleccione una evaluaci√≥n</option>
</select>
</div>

<div class="filter-item">
<label for="evalCompetenceFilter">Filtrar por competencia</label>
<select id="evalCompetenceFilter">
<option value="all">Todas las competencias</option>
</select>
</div>
</div>

<div class="evaluation-report" id="evaluationReportContainer">
<!-- El reporte por evaluaci√≥n se generar√° din√°micamente -->
</div>

<div class="chart-container">
<canvas id="evaluationChart"></canvas>
</div>

<div class="chart-container">
<h3>Rendimiento por Competencia en esta Evaluaci√≥n</h3>
<canvas id="evalCompetenceChart"></canvas>
</div>

<div class="export-options">
<button id="previewEvalBtn" class="btn btn-info">Vista Previa</button>
<button id="exportEvalPdfBtn" class="btn">Exportar a PDF</button>
<button id="exportEvalExcelBtn" class="btn btn-success">Exportar a Excel</button>
<button id="printEvalBtn" class="btn">Imprimir</button>
</div>
</div>

<!-- Tab: L√≠nea de Tiempo -->
<div class="tab-content" id="timeline">
<div class="filter-container">
<div class="filter-item">
<label for="timelineStudentSelect">Seleccionar estudiante</label>
<select id="timelineStudentSelect">
<option value="group">Rendimiento grupal</option>
</select>
</div>

<div class="filter-item">
<label for="timelineCompetenceFilter">Filtrar por competencia</label>
<select id="timelineCompetenceFilter">
<option value="all">Todas las competencias</option>
</select>
</div>
</div>

<div class="timeline-container">
<div class="timeline-header">
<h3>L√≠nea de Tiempo de Evaluaciones</h3>
</div>
<div class="timeline" id="evaluationTimeline">
<!-- La l√≠nea de tiempo se generar√° din√°micamente -->
</div>
</div>

<div class="export-options">
<button id="previewTimelineBtn" class="btn btn-info">Vista Previa</button>
<button id="exportTimelinePdfBtn" class="btn">Exportar a PDF</button>
<button id="printTimelineBtn" class="btn">Imprimir</button>
</div>
</div>
</div>

<!-- Contenedor de Previsualizaci√≥n -->
<div class="preview-container" id="previewContainer">
<div class="preview-content">
<div class="preview-header">
<h2 id="previewTitle">Vista Previa</h2>
<span class="preview-close" id="previewClose">&times;</span>
</div>
<div class="preview-body" id="previewBody">
<!-- El contenido de previsualizaci√≥n se generar√° din√°micamente -->
</div>
<div class="preview-actions">
<button id="cancelPreviewBtn" class="btn btn-warning">Cancelar</button>
<button id="confirmExportBtn" class="btn btn-success">Confirmar Exportaci√≥n</button>
</div>
</div>
</div>

<div class="loading" id="loadingIndicator">
<div class="spinner"></div>
<p>Procesando datos...</p>
</div>




<script>
// Estado global de la aplicaci√≥n
const appState = {
    studentsData: null,
    competencesData: null,
    competenceSheets: [],
    config: {
        decimalPlaces: 2,
        passingGrade: 3.00,
        weights: {},
        dates: {},
        selectedGroup: '',
        semester: '2025-1',
        selectedFields: [],
        studentIdFields: []
    },
    processedData: {
        students: [],
        competences: [],
        evaluations: [],
        indicators: {},
        competenceMappings: {}
    },
    currentStudent: null,
    charts: {},
    datepickers: {},
    filters: {
        individual: {
            competences: [],
            dateRange: { start: null, end: null }
        },
        group: {
            performance: 'all',
            competence: 'all',
            dateRange: { start: null, end: null }
        },
        evaluation: {
            selectedEval: '',
            competence: 'all'
        },
        timeline: {
            student: 'group',
            competence: 'all'
        }
    },
    exportData: {
        type: '',
        content: null,
        filename: ''
    }
};

// Elementos DOM
const elements = {
    tabs: document.querySelectorAll('.tab'),
    tabContents: document.querySelectorAll('.tab-content'),
    studentsFile: document.getElementById('studentsFile'),
    competencesFile: document.getElementById('competencesFile'),
    studentsFileInfo: document.getElementById('studentsFileInfo'),
    competencesFileInfo: document.getElementById('competencesFileInfo'),
    loadFilesBtn: document.getElementById('loadFilesBtn'),
    groupSelect: document.getElementById('groupSelect'),
    semesterSelect: document.getElementById('semesterSelect'),
    decimalPlaces: document.getElementById('decimalPlaces'),
    passingGrade: document.getElementById('passingGrade'),
    weightContainer: document.getElementById('weightContainer'),
    weightValidation: document.getElementById('weightValidation'),
    availableFields: document.getElementById('availableFields'),
    distributeWeightsBtn: document.getElementById('distributeWeightsBtn'),
    clearWeightsBtn: document.getElementById('clearWeightsBtn'),
    saveConfigBtn: document.getElementById('saveConfigBtn'),
    competenceSheetSelect: document.getElementById('competenceSheetSelect'),
    competenceMappingGroup: document.getElementById('competenceMappingGroup'),
    competenceMappingBody: document.getElementById('competenceMappingBody'),
    updateMappingBtn: document.getElementById('updateMappingBtn'),
    studentSearch: document.getElementById('studentSearch'),
    individualCompetenceFilter: document.getElementById('individualCompetenceFilter'),
    individualStartDate: document.getElementById('individualStartDate'),
    individualEndDate: document.getElementById('individualEndDate'),
    studentsList: document.getElementById('studentsList'),
    studentName: document.getElementById('studentName'),
    studentInfo: document.getElementById('studentInfo'),
    gradesTable: document.getElementById('gradesTable'),
    competenceContainer: document.getElementById('competenceContainer'),
    predictionContainer: document.getElementById('predictionContainer'),
    predictionResults: document.getElementById('predictionResults'),
    previewIndividualBtn: document.getElementById('previewIndividualBtn'),
    exportPdfBtn: document.getElementById('exportPdfBtn'),
    exportExcelBtn: document.getElementById('exportExcelBtn'),
    printBtn: document.getElementById('printBtn'),
    performanceFilter: document.getElementById('performanceFilter'),
    competenceFilter: document.getElementById('competenceFilter'),
    groupStartDate: document.getElementById('groupStartDate'),
    groupEndDate: document.getElementById('groupEndDate'),
    groupStatsContainer: document.getElementById('groupStatsContainer'),
    groupChart: document.getElementById('groupChart'),
    competenceChart: document.getElementById('competenceChart'),
    riskStudentsContainer: document.getElementById('riskStudentsContainer'),
    riskStudentsList: document.getElementById('riskStudentsList'),
    previewGroupBtn: document.getElementById('previewGroupBtn'),
    exportGroupPdfBtn: document.getElementById('exportGroupPdfBtn'),
    exportGroupExcelBtn: document.getElementById('exportGroupExcelBtn'),
    printGroupBtn: document.getElementById('printGroupBtn'),
    evaluationSelect: document.getElementById('evaluationSelect'),
    evalCompetenceFilter: document.getElementById('evalCompetenceFilter'),
    evaluationReportContainer: document.getElementById('evaluationReportContainer'),
    evaluationChart: document.getElementById('evaluationChart'),
    evalCompetenceChart: document.getElementById('evalCompetenceChart'),
    previewEvalBtn: document.getElementById('previewEvalBtn'),
    exportEvalPdfBtn: document.getElementById('exportEvalPdfBtn'),
    exportEvalExcelBtn: document.getElementById('exportEvalExcelBtn'),
    printEvalBtn: document.getElementById('printEvalBtn'),
    timelineStudentSelect: document.getElementById('timelineStudentSelect'),
    timelineCompetenceFilter: document.getElementById('timelineCompetenceFilter'),
    evaluationTimeline: document.getElementById('evaluationTimeline'),
    previewTimelineBtn: document.getElementById('previewTimelineBtn'),
    exportTimelinePdfBtn: document.getElementById('exportTimelinePdfBtn'),
    printTimelineBtn: document.getElementById('printTimelineBtn'),
    previewContainer: document.getElementById('previewContainer'),
    previewTitle: document.getElementById('previewTitle'),
    previewBody: document.getElementById('previewBody'),
    previewClose: document.getElementById('previewClose'),
    cancelPreviewBtn: document.getElementById('cancelPreviewBtn'),
    confirmExportBtn: document.getElementById('confirmExportBtn'),
    loadingIndicator: document.getElementById('loadingIndicator'),
    messageContainer: document.getElementById('messageContainer')
};

// Funciones auxiliares
const utils = {
    // Mostrar mensaje
    showMessage: (message, type = 'info') => {
        if (!elements.messageContainer) return;

        elements.messageContainer.innerHTML = `
        <div class="message ${type}">
        ${message}
        </div>
        `;
        setTimeout(() => {
            if (elements.messageContainer) {
                elements.messageContainer.innerHTML = '';
            }
        }, 5000);
    },

    // Mostrar cargando
    showLoading: () => {
        if (elements.loadingIndicator) {
            elements.loadingIndicator.style.display = 'flex';
        }
    },

    // Ocultar cargando
    hideLoading: () => {
        if (elements.loadingIndicator) {
            elements.loadingIndicator.style.display = 'none';
        }
    },

    // Formatear n√∫mero seg√∫n configuraci√≥n
    formatNumber: (number) => {
        if (number === undefined || number === null) return 'N/A';
        const decimalPlaces = appState.config.decimalPlaces || 2;
        return Number(number).toFixed(decimalPlaces);
    },

    // Formatear fecha
    formatDate: (dateStr) => {
        if (!dateStr) return 'No asignada';
        try {
            // A√±adir T00:00:00 para evitar problemas de zona horaria al parsear
            const date = new Date(dateStr + 'T00:00:00');
            if (isNaN(date.getTime())) return 'Fecha inv√°lida';
            return date.toLocaleDateString('es-ES', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric'
            });
        } catch (e) {
            return 'Fecha inv√°lida';
        }
    },

    // Verificar si los pesos suman 100% (o menos)
    validateWeights: () => {
        const weights = appState.config.weights || {};
        const sum = Object.values(weights).reduce((acc, val) => acc + (parseFloat(val)||0), 0);
        // Validamos que sum ‚â§ 100 con peque√±a tolerancia
        const isValid = sum <= 100 + 0.001;
        if (elements.weightValidation) {
          elements.weightValidation.classList.toggle('valid', isValid);
          elements.weightValidation.classList.toggle('invalid', !isValid);
          elements.weightValidation.textContent = isValid
            ? `Los pesos suman ${sum.toFixed(1)}% (v√°lido)`
            : `Los pesos suman ${sum.toFixed(1)}% (deben ser ‚â§ 100%)`;
        }
        return isValid;
    },

    // --- INICIO FUNCI√ìN CORREGIDA ---
    // Calcular nota final ponderada para un estudiante
    // Devuelve la nota promedio obtenida en las evaluaciones consideradas (completadas y que pasan los filtros),
    // en la escala original de las notas (ej. 0-5).
    calculateFinalGrade: (student, filterCompetences = [], dateRange = {}) => {
        // 1. Validaciones iniciales
        if (!student) {
            console.warn("CalculateFinalGrade: No se proporcionaron datos del estudiante.");
            return 0;
        }
        if (!appState.config.weights || Object.keys(appState.config.weights).length === 0) {
            console.warn("CalculateFinalGrade: No hay pesos configurados en appState.config.weights.");
            return 0; // No se puede calcular si no hay pesos definidos
        }

        let sumWeightedGrades = 0;             // Suma de (nota * peso) para evaluaciones v√°lidas
        let sumConsideredWeights = 0;          // Suma de los pesos de las evaluaciones v√°lidas

        // 2. Iterar sobre TODAS las evaluaciones definidas en la configuraci√≥n
        for (const evalKey in appState.config.weights) {
            // Obtener el peso de esta evaluaci√≥n (asegur√°ndose de que sea un n√∫mero)
            const weight = (parseFloat(appState.config.weights[evalKey]) || 0) / 100;

            // Si el peso es 0, no tiene sentido incluirla en el c√°lculo
            if (weight <= 0) {
                continue;
            }

            // --- Aplicar Filtros ---

            // 3. Filtrar por Competencia
            if (filterCompetences.length > 0) {
                const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
                // Si esta evaluaci√≥n NO tiene NINGUNA de las competencias buscadas, la saltamos
                if (!evalCompetences.some(comp => filterCompetences.includes(comp))) {
                    continue;
                }
            }

            // 4. Filtrar por Rango de Fechas
            if (dateRange.start && dateRange.end) {
                const evalDateStr = appState.config.dates[evalKey];
                if (evalDateStr) { // Solo filtrar si la evaluaci√≥n tiene fecha
                    try {
                        // Convertir las fechas para compararlas correctamente
                        // A√±adir T00:00:00 puede ayudar a evitar problemas de zona horaria al comparar solo fechas
                        const evalDate = new Date(evalDateStr + 'T00:00:00');
                        const startDate = new Date(dateRange.start + 'T00:00:00');
                        // Usar T23:59:59 para incluir todo el d√≠a final
                        const endDate = new Date(dateRange.end + 'T23:59:59');

                        // Si la fecha de la evaluaci√≥n est√° fuera del rango, la saltamos
                        if (evalDate < startDate || evalDate > endDate) {
                            continue;
                        }
                    } catch (e) {
                        console.error(`Error al parsear o comparar fechas para la evaluaci√≥n '${evalKey}':`, e);
                        // Podr√≠as decidir saltar la evaluaci√≥n si hay error de fecha
                        continue;
                    }
                } else {
                    // Si el filtro de fecha est√° activo pero la evaluaci√≥n no tiene fecha, la saltamos
                    continue;
                }
            }

            // --- Fin Aplicar Filtros ---

            // 5. Verificar si el estudiante tiene nota para esta evaluaci√≥n (y si pasa los filtros)
            const gradeValue = student[evalKey];

            // Considerar la evaluaci√≥n solo si tiene una nota v√°lida (no undefined, null, o string vac√≠o)
            if (gradeValue !== undefined && gradeValue !== null && gradeValue !== '') {
                const grade = parseFloat(gradeValue); // Asegurarse de que la nota sea un n√∫mero

                // Si la conversi√≥n a n√∫mero fue exitosa
                if (!isNaN(grade)) {
                    // Acumular la nota ponderada y el peso considerado
                    sumWeightedGrades += grade * weight;
                    sumConsideredWeights += weight;
                } else {
                     console.warn(`La nota para '${evalKey}' no es un n√∫mero v√°lido:`, gradeValue);
                }
            }
            // Si no hay nota, simplemente no se incluye en sumWeightedGrades ni sumConsideredWeights
        } // Fin del bucle for...in

        // 6. Calcular y devolver el resultado
        // Si la suma de pesos considerados es 0 (ninguna evaluaci√≥n v√°lida encontrada o completada), devolver 0
        if (sumConsideredWeights === 0) {
            return 0;
        }

        // Calcular la nota promedio basada SOLAMENTE en las evaluaciones consideradas.
        // Esto da la nota promedio actual del estudiante en la escala original (ej. 0-5),
        // ponderada seg√∫n los pesos de las evaluaciones incluidas.
        const finalGrade = sumWeightedGrades / sumConsideredWeights;

        // Devolver la nota en la escala original (ej. 0-5)
        return finalGrade;

        /* --- NOTA SOBRE C√ÅLCULOS ALTERNATIVOS ---
           Si quisieras calcular la contribuci√≥n de estas notas al TOTAL del curso (asumiendo que el total es 100% o 1.0),
           necesitar√≠as calcular `courseTotalWeight` (la suma de TODOS los pesos definidos) fuera del bucle
           y luego podr√≠as devolver `sumWeightedGrades / courseTotalWeight`.
           Pero la implementaci√≥n actual (dividir por `sumConsideredWeights`) es m√°s com√∫n para mostrar
           una "nota actual" basada en lo que se ha completado y filtrado.
        */
    },
    // --- FIN FUNCI√ìN CORREGIDA ---

    // Calcular estad√≠sticas de grupo
    calculateGroupStats: (students, filterCompetences = [], dateRange = {}) => {
        if (!students || students.length === 0) return null;

        // Usar la funci√≥n corregida para obtener las notas (en escala original, ej. 0-5)
        const grades = students.map(student =>
            utils.calculateFinalGrade(student, filterCompetences, dateRange)
        ).filter(grade => !isNaN(grade) && grade !== 0); // Filtrar estudiantes sin evaluaciones v√°lidas

        if (grades.length === 0) return {
            totalStudents: students.length,
            evaluatedStudents: 0,
            average: 0,
            min: 0,
            max: 0,
            stdDev: 0,
            studentsAtRisk: 0
        };

        const sum = grades.reduce((acc, grade) => acc + grade, 0);
        const avg = sum / grades.length;
        const min = Math.min(...grades);
        const max = Math.max(...grades);

        // Calcular desviaci√≥n est√°ndar
        const squaredDiffs = grades.map(grade => Math.pow(grade - avg, 2));
        const avgSquaredDiff = squaredDiffs.reduce((acc, val) => acc + val, 0) / grades.length;
        const stdDev = Math.sqrt(avgSquaredDiff);

        // Contar estudiantes por debajo de la nota m√≠nima
        const passingGrade = appState.config.passingGrade || 3.0;
        const studentsAtRisk = grades.filter(grade => grade < passingGrade).length;

        return {
            totalStudents: students.length,
            evaluatedStudents: grades.length,
            average: avg,
            min: min,
            max: max,
            stdDev: stdDev,
            studentsAtRisk: studentsAtRisk
        };
    },

    // Predecir nota requerida en evaluaciones restantes
    predictRequiredGrade: (student, filterCompetences = []) => {
        if (!student || !appState.config.weights) {
          return { possible: false, message: "No hay datos suficientes para predicci√≥n" };
        }
        let completedContribution = 0, completedWeight = 0;
        let pendingEvals = [];
        let totalCourseWeight = 0; // Peso total del curso seg√∫n configuraci√≥n

        for (const evalKey in appState.config.weights) {
            const weight = (parseFloat(appState.config.weights[evalKey]) || 0) / 100;
            totalCourseWeight += weight; // Sumar siempre al peso total del curso

            // Aplicar filtros de competencia si existen
            if (filterCompetences.length > 0) {
                const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
                if (!evalCompetences.some(comp => filterCompetences.includes(comp))) {
                    continue; // Saltar si no cumple filtro de competencia
                }
            }

            const gradeValue = student[evalKey];
            if (gradeValue !== undefined && gradeValue !== null && gradeValue !== '') {
                const grade = parseFloat(gradeValue);
                if (!isNaN(grade)) {
                    completedContribution += grade * weight;
                    completedWeight += weight;
                } else {
                    // Si hay un valor pero no es n√∫mero, considerar pendiente
                    pendingEvals.push(evalKey);
                }
            } else {
                // Si no hay nota, considerar pendiente
                pendingEvals.push(evalKey);
            }
        }

        const passing = appState.config.passingGrade || 3.0;
        const remainingWeight = totalCourseWeight - completedWeight;

        // Si ya se complet√≥ todo el peso del curso
        if (remainingWeight <= 0.001) { // Usar tolerancia
            const currentFinalGrade = completedWeight > 0 ? completedContribution / completedWeight : 0;
            return currentFinalGrade >= passing
                ? { possible: true, message: `Ya aprob√≥ con ${utils.formatNumber(currentFinalGrade)}.`, requiredGrade: 0, evaluations: [] }
                : { possible: false, message: `No hay evaluaciones pendientes o peso restante. Nota final: ${utils.formatNumber(currentFinalGrade)}` };
        }

        // Calcular la suma ponderada necesaria para alcanzar la nota de aprobaci√≥n sobre el peso total
        const neededTotalContribution = passing * totalCourseWeight;
        const requiredSumFromPending = neededTotalContribution - completedContribution;

        // Si ya se alcanz√≥ o super√≥ la nota necesaria con lo completado
        if (requiredSumFromPending <= 0) {
             const currentFinalGrade = completedWeight > 0 ? completedContribution / completedWeight : 0;
             return { possible: true, message: `Ya alcanz√≥ la nota m√≠nima con ${utils.formatNumber(currentFinalGrade)}.`, requiredGrade: 0, evaluations: [] };
        }

        // Calcular la nota promedio necesaria en las evaluaciones pendientes
        const requiredGrade = requiredSumFromPending / remainingWeight;

        // Asumiendo que la nota m√°xima es 5.0
        if (requiredGrade > 5.0) {
            return {
                possible: false,
                message: `Necesitar√≠a un promedio de ${utils.formatNumber(requiredGrade)} en las evaluaciones restantes, lo cual es imposible (m√°x 5.0).`
            };
        }
        if (requiredGrade < 0) {
             return { possible: true, message: `Ya aprob√≥. Cualquier nota en las pendientes mantiene la aprobaci√≥n.`, requiredGrade: 0, evaluations: [] };
        }

        return {
            possible: true,
            message: `Necesita obtener un promedio de al menos ${utils.formatNumber(requiredGrade)} en las siguientes evaluaciones pendientes para alcanzar ${utils.formatNumber(passing)}:`,
            requiredGrade: requiredGrade,
            evaluations: pendingEvals
        };
    },

    // Calcular rendimiento por competencia
    calculateCompetencePerformance: (students, competences, dateRange = {}) => {
        const compPerformance = {};

        // Inicializar estructura para cada competencia
        const uniqueCompetences = utils.getUniqueCompetences();
        uniqueCompetences.forEach(comp => {
            compPerformance[comp] = {
                totalStudents: 0, // Estudiantes con al menos una nota en evals de esta comp
                passStudents: 0,  // Estudiantes que aprueban esta competencia
                sum: 0,           // Suma de los promedios de los estudiantes en esta comp
                count: 0,         // N√∫mero de estudiantes con promedio calculado para esta comp
                average: 0        // Promedio general de la competencia
            };
        });

        // Analizar cada estudiante
        students.forEach(student => {
            uniqueCompetences.forEach(comp => {
                // Obtener evaluaciones relacionadas con esta competencia que pasan el filtro de fecha
                const relatedEvals = [];
                for (const evalKey in appState.processedData.competenceMappings) {
                    const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
                    if (evalCompetences.includes(comp)) {
                        // Verificar filtro de fecha si es necesario
                        let includeEval = true;
                        if (dateRange.start && dateRange.end) {
                            const evalDateStr = appState.config.dates[evalKey];
                            if (evalDateStr) {
                                try {
                                    const evalDate = new Date(evalDateStr + 'T00:00:00');
                                    const startDate = new Date(dateRange.start + 'T00:00:00');
                                    const endDate = new Date(dateRange.end + 'T23:59:59');
                                    if (evalDate < startDate || evalDate > endDate) {
                                        includeEval = false;
                                    }
                                } catch (e) {
                                    console.error('Error al comparar fechas en calculateCompetencePerformance:', e);
                                    includeEval = false; // Excluir si hay error de fecha
                                }
                            } else {
                                includeEval = false; // Excluir si no tiene fecha y el filtro est√° activo
                            }
                        }
                        if (includeEval) {
                            relatedEvals.push(evalKey);
                        }
                    }
                }

                // Calcular promedio del estudiante para ESTA competencia (basado en evals relacionadas y filtradas)
                let studentCompSum = 0;
                let studentEvalCount = 0;
                relatedEvals.forEach(evalName => {
                    const gradeValue = student[evalName];
                    if (gradeValue !== undefined && gradeValue !== null && gradeValue !== '') {
                        const grade = parseFloat(gradeValue);
                        if (!isNaN(grade)) {
                            studentCompSum += grade;
                            studentEvalCount++;
                        }
                    }
                });

                // Si el estudiante tiene al menos una nota en las evaluaciones de esta competencia
                if (studentEvalCount > 0) {
                    const studentAvgForComp = studentCompSum / studentEvalCount;
                    compPerformance[comp].sum += studentAvgForComp;
                    compPerformance[comp].count++; // Contar estudiante para el promedio general
                    compPerformance[comp].totalStudents++; // Contar estudiante que participa en esta competencia

                    // Verificar si el estudiante aprueba esta competencia espec√≠fica
                    if (studentAvgForComp >= appState.config.passingGrade) {
                        compPerformance[comp].passStudents++;
                    }
                }
            });
        });

        // Calcular promedios finales para cada competencia
        uniqueCompetences.forEach(comp => {
            if (compPerformance[comp].count > 0) {
                compPerformance[comp].average = compPerformance[comp].sum / compPerformance[comp].count;
            }
        });

        return compPerformance;
    },

    // --- INICIO FUNCI√ìN CORREGIDA (sin HTML) ---
    // Calcular rendimiento por competencia en una evaluaci√≥n espec√≠fica
    calculateEvaluationCompetencePerformance: (students, evalName) => {
        const compPerformance = {};

        // Obtener las competencias asociadas a esta evaluaci√≥n
        const evalCompetences = appState.processedData.competenceMappings[evalName] || [];

        // Inicializar estructura para cada competencia
        evalCompetences.forEach(comp => {
            compPerformance[comp] = {
                totalStudents: 0, // Estudiantes con nota en ESTA evaluaci√≥n
                passStudents: 0,  // Estudiantes que aprueban ESTA evaluaci√≥n (si aplica a la competencia)
                sum: 0,           // Suma de notas de ESTA evaluaci√≥n para esta competencia
                average: 0        // Promedio de ESTA evaluaci√≥n para esta competencia
            };
        });

        // Analizar cada estudiante
        students.forEach(student => {
            const gradeValue = student[evalName];
            // Considerar solo si el estudiante tiene nota para ESTA evaluaci√≥n
            if (gradeValue !== undefined && gradeValue !== null && gradeValue !== '') {
                 const grade = parseFloat(gradeValue);
                 if (!isNaN(grade)) {
                    // Atribuir la nota a cada competencia asociada a la evaluaci√≥n
                    evalCompetences.forEach(comp => {
                        compPerformance[comp].sum += grade;
                        compPerformance[comp].totalStudents++;
                        // Contar si aprueba basado en la nota de ESTA evaluaci√≥n
                        if (grade >= appState.config.passingGrade) {
                            compPerformance[comp].passStudents++;
                        }
                    });
                 }
            }
        });

        // Calcular promedios finales para cada competencia DENTRO de esta evaluaci√≥n
        evalCompetences.forEach(comp => {
            if (compPerformance[comp].totalStudents > 0) {
                compPerformance[comp].average = compPerformance[comp].sum / compPerformance[comp].totalStudents;
            }
        });

        return compPerformance;
    },
    // --- FIN FUNCI√ìN CORREGIDA ---

    // Obtener evaluaciones filtradas por competencia
    getFilteredEvaluations: (competenceFilter) => {
        if (!competenceFilter || competenceFilter === 'all') {
            return appState.processedData.evaluations || [];
        }

        return (appState.processedData.evaluations || []).filter(evalName => {
            const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
            return evalCompetences.includes(competenceFilter);
        });
    },

    // Obtener competencias √∫nicas
    getUniqueCompetences: () => {
        if (!appState.processedData.competences) return [];
        const competences = new Set();
        // Usar los datos procesados que ya tienen 'Competencia' normalizado
        appState.processedData.competences.forEach(c => {
            if (c.Competencia) competences.add(c.Competencia);
        });
        // Tambi√©n a√±adir competencias que solo existan en el mapeo (si las hubiera)
        Object.values(appState.processedData.competenceMappings || {}).forEach(compList => {
            compList.forEach(comp => competences.add(comp));
        });
        return Array.from(competences).sort(); // Devolver ordenadas alfab√©ticamente
    },

    // Mostrar vista previa
    showPreview: (title, content, exportType, filename) => {
        if (!elements.previewContainer || !elements.previewTitle || !elements.previewBody) return;
        elements.previewTitle.textContent = title;
        // Envolver el contenido en un div con fondo blanco y padding para mejor visualizaci√≥n
        elements.previewBody.innerHTML = `<div style='background:#fff; padding: 20px; border-radius: 5px;'>${content}</div>`;
        elements.previewContainer.style.display = 'flex';
        appState.exportData = {
            type: exportType,
            content: content, // Guardar el contenido original para exportar
            filename: filename
        };
    },

    // Cerrar vista previa
    closePreview: () => {
        if (elements.previewContainer) {
            elements.previewContainer.style.display = 'none';
        }
        if (elements.previewBody) {
            elements.previewBody.innerHTML = '';
        }
        appState.exportData = { type: '', content: null, filename: '' };
    },

    // Exportar a PDF
    exportToPdf: (content, filename) => {
        utils.showLoading();

        setTimeout(() => { // Dar tiempo para que se muestre el loading
            try {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF('p', 'mm', 'a4');

                // Crear un div temporal para renderizar el contenido HTML
                const tempDiv = document.createElement('div');
                // Aplicar estilos b√°sicos para que se parezca m√°s al original
                tempDiv.innerHTML = `
                    <style>
                        /* Incluir estilos b√°sicos relevantes aqu√≠ */
                        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 10pt; line-height: 1.4; }
                        h1, h2, h3 { margin-bottom: 0.5em; color: #3498db; }
                        h2 { font-size: 1.5em; } h3 { font-size: 1.2em; }
                        table { border-collapse: collapse; width: 100%; margin-bottom: 1em; font-size: 9pt; }
                        th, td { border: 1px solid #bdc3c7; padding: 4px 6px; text-align: left; }
                        th { background-color: #ecf0f1; font-weight: bold; }
                        .stat-card { border: 1px solid #ecf0f1; padding: 10px; margin-bottom: 10px; border-radius: 4px; }
                        .stat-value { font-size: 1.5em; font-weight: bold; color: #3498db; }
                        .competence-tag { background-color: #e0f2f7; color: #3498db; padding: 2px 5px; border-radius: 3px; font-size: 8pt; display: inline-block; margin: 2px; }
                        .competence-item { border: 1px solid #ecf0f1; padding: 10px; margin-bottom: 10px; border-radius: 4px; }
                        .competence-progress { background-color: #ecf0f1; height: 8px; border-radius: 4px; overflow: hidden; margin-top: 5px; }
                        .competence-progress-bar { height: 100%; background-color: #3498db; }
                        .timeline-item { margin-bottom: 15px; padding-left: 20px; position: relative; }
                        .timeline-content { border-left: 3px solid #3498db; padding: 10px; background: #f9f9f9; border-radius: 4px; }
                        .timeline-date { font-size: 9pt; color: #7f8c8d; }
                        img { max-width: 100%; height: auto; } /* Para las im√°genes de los gr√°ficos */
                    </style>
                    ${content}
                `;
                // Establecer un ancho fijo para el renderizado (A4 menos m√°rgenes)
                tempDiv.style.width = '190mm';
                tempDiv.style.padding = '0'; // El padding ya est√° en el contenido
                tempDiv.style.position = 'absolute';
                tempDiv.style.left = '-9999px'; // Fuera de la vista
                tempDiv.style.top = '-9999px';
                document.body.appendChild(tempDiv);

                html2canvas(tempDiv, {
                    scale: 2, // Aumentar escala para mejor resoluci√≥n
                    useCORS: true // Si hay im√°genes externas
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/jpeg', 0.9); // Usar JPEG para tama√±o
                    const imgWidth = 190; // Ancho en mm (A4 menos m√°rgenes de 10mm)
                    const pageHeight = 297 - 20; // Alto A4 menos m√°rgenes
                    const imgHeight = canvas.height * imgWidth / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 10; // Margen superior

                    doc.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    while (heightLeft > 0) {
                        position = heightLeft - imgHeight + 10; // Ajustar posici√≥n para la siguiente p√°gina
                        doc.addPage();
                        doc.addImage(imgData, 'JPEG', 10, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    doc.save(filename);
                    document.body.removeChild(tempDiv); // Limpiar
                    utils.hideLoading();
                    utils.showMessage('PDF exportado correctamente.', 'success');

                }).catch(err => {
                    document.body.removeChild(tempDiv); // Limpiar en caso de error
                    utils.hideLoading();
                    utils.showMessage('Error al generar imagen para PDF: ' + err.message, 'error');
                    console.error("Error html2canvas:", err);
                });

            } catch (error) {
                utils.hideLoading();
                utils.showMessage('Error al exportar a PDF: ' + error.message, 'error');
                console.error("Error jsPDF:", error);
            }
        }, 100); // Peque√±o retraso
    },

    // Exportar a Excel
    exportToExcel: (data, filename) => {
        utils.showLoading();

        setTimeout(() => { // Dar tiempo para que se muestre el loading
            try {
                // Asegurarse de que 'data' sea un array de objetos
                if (!Array.isArray(data) || data.length === 0 || typeof data[0] !== 'object') {
                    throw new Error('Formato de datos inv√°lido para Excel. Se esperaba un array de objetos.');
                }

                const worksheet = XLSX.utils.json_to_sheet(data);
                const workbook = XLSX.utils.book_new();

                XLSX.utils.book_append_sheet(workbook, worksheet, 'Reporte');

                // Guardar el archivo
                XLSX.writeFile(workbook, filename);

                utils.hideLoading();
                utils.showMessage('Excel exportado correctamente.', 'success');
            } catch (error) {
                utils.hideLoading();
                utils.showMessage('Error al exportar a Excel: ' + error.message, 'error');
                console.error("Error XLSX:", error);
            }
        }, 100); // Peque√±o retraso
    },

    // Imprimir contenido
    printContent: (content) => {
        // Crear un iframe oculto
        const printFrame = document.createElement('iframe');
        printFrame.style.position = 'absolute';
        printFrame.style.width = '0';
        printFrame.style.height = '0';
        printFrame.style.border = '0';
        document.body.appendChild(printFrame);

        // Escribir el contenido y estilos en el iframe
        printFrame.contentDocument.open();
        printFrame.contentDocument.write(`
            <!DOCTYPE html>
            <html>
            <head>
                <title>Imprimir</title>
                <style>
                    /* Estilos b√°sicos para impresi√≥n */
                    @media print {
                        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 10pt; line-height: 1.3; }
                        h1, h2, h3 { page-break-after: avoid; }
                        table { border-collapse: collapse; width: 100%; page-break-inside: avoid; }
                        th, td { border: 1px solid #ccc; padding: 4px; text-align: left; }
                        th { background-color: #eee; }
                        img { max-width: 100%; height: auto; page-break-inside: avoid; }
                        .no-print { display: none; } /* Clase para ocultar elementos en impresi√≥n */
                        /* A√±adir m√°s estilos espec√≠ficos si es necesario */
                         .stat-card { border: 1px solid #eee; padding: 8px; margin-bottom: 8px; page-break-inside: avoid; }
                         .competence-item { border: 1px solid #eee; padding: 8px; margin-bottom: 8px; page-break-inside: avoid; }
                         .timeline-item { page-break-inside: avoid; margin-bottom: 10px; }
                    }
                    /* Estilos generales para visualizaci√≥n en iframe (opcional) */
                    body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
                    table { border-collapse: collapse; width: 100%; margin-bottom: 1em; }
                    th, td { border: 1px solid #ccc; padding: 4px; text-align: left; }
                    th { background-color: #eee; }
                </style>
            </head>
            <body>
                ${content}
            </body>
            </html>
        `);
        printFrame.contentDocument.close();

        // Esperar a que el contenido se cargue y luego imprimir
        printFrame.onload = () => {
            try {
                printFrame.contentWindow.focus(); // Necesario en algunos navegadores
                printFrame.contentWindow.print();
            } catch (e) {
                console.error("Error al intentar imprimir:", e);
                utils.showMessage("Error al iniciar la impresi√≥n.", "error");
            } finally {
                // Eliminar el iframe despu√©s de un tiempo prudencial
                setTimeout(() => {
                    document.body.removeChild(printFrame);
                }, 1000);
            }
        };
    }
};

// Controladores de eventos
const eventHandlers = {
    // Cambiar pesta√±a
    tabClick: (e) => {
        const tabId = e.target.getAttribute('data-tab');
        if (!tabId) return;

        // Actualizar clases activas
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        elements.tabContents.forEach(content => content.classList.remove('active'));

        e.target.classList.add('active');
        const tabContent = document.getElementById(tabId);
        if (tabContent) {
            tabContent.classList.add('active');
        }

        // Validaciones para cambio de pesta√±a
        if (['config', 'mapping', 'individual', 'group', 'evaluation', 'timeline'].includes(tabId) &&
            (!appState.studentsData || !appState.competencesData)) {
            utils.showMessage('Primero debe cargar los archivos en la pesta√±a "Carga de Archivos".', 'warning');
            // Forzar vuelta a la pesta√±a de carga
            elements.tabs.forEach(tab => tab.classList.remove('active'));
            elements.tabContents.forEach(content => content.classList.remove('active'));
            document.querySelector('[data-tab="upload"]').classList.add('active');
            document.getElementById('upload').classList.add('active');
            return;
        }

        if (['individual', 'group', 'evaluation', 'timeline'].includes(tabId) &&
            (!appState.processedData.students || !appState.processedData.students.length ||
             !appState.processedData.evaluations || !appState.processedData.evaluations.length ||
             Object.keys(appState.config.weights || {}).length === 0)) {
            utils.showMessage('Primero debe cargar archivos, seleccionar grupo/campos y guardar la configuraci√≥n con pesos definidos.', 'warning');
             // Forzar vuelta a la pesta√±a de config si ya se cargaron archivos
            if (appState.studentsData && appState.competencesData) {
                elements.tabs.forEach(tab => tab.classList.remove('active'));
                elements.tabContents.forEach(content => content.classList.remove('active'));
                document.querySelector('[data-tab="config"]').classList.add('active');
                document.getElementById('config').classList.add('active');
            }
            return;
        }

        // Inicializaciones espec√≠ficas por pesta√±a al cambiar a ella
        switch(tabId) {
            case 'config':
                // Si ya hay datos cargados, asegurar que la UI refleje el estado actual
                if (appState.studentsData && appState.config.selectedGroup) {
                    eventHandlers.groupChange(); // Renderiza campos y pesos
                }
                break;
            case 'mapping':
                // Renderizar mapeo si ya hay datos procesados
                if (appState.processedData.evaluations && appState.processedData.evaluations.length > 0) {
                    renderCompetenceMapping();
                }
                break;
            case 'individual':
                 // Asegurar que los filtros y datepickers est√©n inicializados
                if (appState.processedData.students && appState.processedData.students.length > 0) {
                    initializeCompetenceFilters();
                    initializeDatepickers();
                    // Renderizar lista si a√∫n no se ha hecho
                    if (elements.studentsList && elements.studentsList.children.length === 0) {
                         processData(); // Asegura que la lista de estudiantes est√© cargada
                    }
                    // Si hay un estudiante seleccionado, refrescar su reporte
                    if (appState.currentStudent) {
                        eventHandlers.selectStudent(appState.currentStudent);
                    }
                }
                break;
            case 'group':
                // Renderizar reporte grupal si hay datos
                if (appState.processedData.students && appState.processedData.students.length > 0) {
                    initializeDatepickers(); // Asegurar datepickers
                    eventHandlers.filterByPerformance(); // Renderiza con filtros actuales
                }
                break;
            case 'evaluation':
                 // Renderizar reporte de evaluaci√≥n si hay datos y una evaluaci√≥n seleccionada
                if (appState.processedData.evaluations && appState.processedData.evaluations.length > 0) {
                    // Si hay una evaluaci√≥n seleccionada en el filtro, renderizarla
                    if (appState.filters.evaluation.selectedEval) {
                         renderEvaluationReport(appState.filters.evaluation.selectedEval,
                            appState.filters.evaluation.competence !== 'all' ? [appState.filters.evaluation.competence] : []);
                    } else {
                        // Limpiar el reporte si no hay evaluaci√≥n seleccionada
                        if (elements.evaluationReportContainer) elements.evaluationReportContainer.innerHTML = '<div class="message info">Seleccione una evaluaci√≥n para ver el reporte.</div>';
                        // Limpiar gr√°ficos
                        if (appState.charts.evaluationChart) appState.charts.evaluationChart.destroy();
                        if (appState.charts.evalCompetenceChart) appState.charts.evalCompetenceChart.destroy();
                    }
                }
                break;
            case 'timeline':
                // Renderizar l√≠nea de tiempo si hay datos
                if (appState.processedData.students && appState.processedData.students.length > 0) {
                    renderTimelinePage(); // Renderiza selectores y la l√≠nea de tiempo
                }
                break;
        }
    },

    // Manejar cambio en archivo de estudiantes
    studentsFileChange: (e) => {
        const file = e.target.files[0];
        if (!file) {
            if (elements.studentsFileInfo) elements.studentsFileInfo.textContent = '';
            eventHandlers.checkFilesLoaded();
            return;
        }

        if (elements.studentsFileInfo) {
            elements.studentsFileInfo.textContent = `Archivo seleccionado: ${file.name}`;
        }
        eventHandlers.checkFilesLoaded();
    },

    // Manejar cambio en archivo de competencias
    competencesFileChange: (e) => {
        const file = e.target.files[0];
        if (!file) {
            if (elements.competencesFileInfo) elements.competencesFileInfo.textContent = '';
            eventHandlers.checkFilesLoaded();
            return;
        }

        if (elements.competencesFileInfo) {
            elements.competencesFileInfo.textContent = `Archivo seleccionado: ${file.name}`;
        }
        eventHandlers.checkFilesLoaded();
    },

    // Verificar si ambos archivos est√°n cargados
    checkFilesLoaded: () => {
        const studentsFile = elements.studentsFile ? elements.studentsFile.files[0] : null;
        const competencesFile = elements.competencesFile ? elements.competencesFile.files[0] : null;

        if (elements.loadFilesBtn) {
            elements.loadFilesBtn.disabled = !(studentsFile && competencesFile);
        }
    },

    // Cargar archivos
    loadFiles: async () => {
        utils.showLoading();
        console.log('Iniciando carga de archivos...');

        try {
            const studentsFile = elements.studentsFile ? elements.studentsFile.files[0] : null;
            const competencesFile = elements.competencesFile ? elements.competencesFile.files[0] : null;

            if (!studentsFile || !competencesFile) {
                throw new Error('Debe seleccionar ambos archivos.');
            }

            console.log('Leyendo archivo de estudiantes:', studentsFile.name);
            const studentsData = await readExcelOrCsvFile(studentsFile);
            appState.studentsData = studentsData;
            console.log('Datos de estudiantes cargados:', studentsData);

            console.log('Leyendo archivo de competencias:', competencesFile.name);
            const competencesData = await readExcelOrCsvFile(competencesFile);
            appState.competencesData = competencesData;
            appState.competenceSheets = Object.keys(competencesData);
            console.log('Datos de competencias cargados:', competencesData);

            // Limpiar datos procesados anteriores
            appState.processedData = { students: [], competences: [], evaluations: [], indicators: {}, competenceMappings: {} };
            appState.config.weights = {};
            appState.config.dates = {};
            appState.config.selectedFields = [];
            appState.config.studentIdFields = [];
            appState.currentStudent = null;

            // Configurar grupos disponibles
            if (elements.groupSelect) {
                elements.groupSelect.innerHTML = '<option value="">Seleccione un grupo</option>';
                if (appState.studentsData) {
                    Object.keys(appState.studentsData).forEach(group => {
                        elements.groupSelect.innerHTML += `<option value="${group}">${group}</option>`;
                    });
                }
                // Resetear selecci√≥n
                elements.groupSelect.value = '';
                appState.config.selectedGroup = '';
            }

             // Limpiar contenedor de campos y pesos
            if (elements.availableFields) elements.availableFields.innerHTML = '';
            if (elements.weightContainer) elements.weightContainer.innerHTML = '';
            if (elements.weightValidation) {
                elements.weightValidation.textContent = '';
                elements.weightValidation.className = 'weight-validation';
            }


            // Configurar hojas de competencias
            if (elements.competenceSheetSelect) {
                elements.competenceSheetSelect.innerHTML = '<option value="">Seleccione una hoja</option>';
                appState.competenceSheets.forEach(sheet => {
                    elements.competenceSheetSelect.innerHTML += `<option value="${sheet}">${sheet}</option>`;
                });
                 elements.competenceSheetSelect.value = ''; // Resetear selecci√≥n
            }

            utils.showMessage('Archivos cargados. Seleccione un grupo en la pesta√±a Configuraci√≥n.', 'success');

            // Cambiar a la pesta√±a de configuraci√≥n
            elements.tabs.forEach(tab => tab.classList.remove('active'));
            elements.tabContents.forEach(content => content.classList.remove('active'));

            const configTab = document.querySelector('[data-tab="config"]');
            const configContent = document.getElementById('config');

            if (configTab) configTab.classList.add('active');
            if (configContent) configContent.classList.add('active');

        } catch (error) {
            utils.showMessage(`Error al cargar los archivos: ${error.message}`, 'error');
            console.error("Error en loadFiles:", error);
        } finally {
            utils.hideLoading();
        }
    },

    // Manejar cambio de grupo
    groupChange: () => {
        const selectedGroup = elements.groupSelect ? elements.groupSelect.value : '';
        console.log('Grupo seleccionado:', selectedGroup);

        // Limpiar datos anteriores si no se selecciona grupo
        if (!selectedGroup) {
            appState.config.selectedGroup = '';
            if (elements.availableFields) elements.availableFields.innerHTML = '';
            if (elements.weightContainer) elements.weightContainer.innerHTML = '';
             if (elements.weightValidation) {
                elements.weightValidation.textContent = '';
                elements.weightValidation.className = 'weight-validation';
            }
            appState.config.weights = {};
            appState.config.dates = {};
            appState.config.selectedFields = [];
            appState.config.studentIdFields = [];
            return;
        }

        appState.config.selectedGroup = selectedGroup;

        // Obtener datos del grupo seleccionado
        const groupData = appState.studentsData ? appState.studentsData[selectedGroup] : null;
        if (!groupData || !groupData.length) {
            utils.showMessage(`El grupo "${selectedGroup}" no contiene datos.`, 'warning');
            if (elements.availableFields) elements.availableFields.innerHTML = '';
            if (elements.weightContainer) elements.weightContainer.innerHTML = '';
            return;
        }

        // Obtener todos los campos disponibles del primer estudiante (asumiendo que son consistentes)
        const firstRow = groupData[0];
        const allFields = firstRow ? Object.keys(firstRow) : [];
        console.log('Campos disponibles:', allFields);

        // Generar selector de campos
        if (elements.availableFields) {
            elements.availableFields.innerHTML = ''; // Limpiar antes de a√±adir

            allFields.forEach(field => {
                // Heur√≠stica mejorada para identificar campos
                const lowerField = field.toLowerCase();
                const isLikelyId = lowerField.includes('id') || lowerField.includes('identifica') || lowerField.includes('c√≥digo') || lowerField.includes('codigo') || lowerField.includes('documento');
                const isLikelyName = lowerField.includes('nombre') || lowerField.includes('name') || lowerField.includes('estudiante') || lowerField.includes('apellido');
                const isLikelyGrade = !isLikelyId && !isLikelyName &&
                                    (lowerField.includes('eval') || lowerField.includes('nota') ||
                                     lowerField.includes('grade') || lowerField.includes('calif') ||
                                     lowerField.includes('parcial') || lowerField.includes('quiz') ||
                                     lowerField.includes('taller') || lowerField.includes('proyecto') ||
                                     lowerField.match(/^p\d+$/) || // P1, P2...
                                     lowerField.match(/^t\d+$/) || // T1, T2...
                                     lowerField.match(/^q\d+$/) || // Q1, Q2...
                                     lowerField.match(/^c\d+$/) || // C1, C2...
                                     lowerField.match(/^e\d+$/) || // E1, E2...
                                     lowerField.match(/^act\d+$/) || // Act1, Act2...
                                     /\d/.test(field)); // Contiene n√∫meros

                // Marcar por defecto campos de ID y Notas
                const isStudentIdField = isLikelyId || isLikelyName;
                const isGradeField = isLikelyGrade;
                const checked = isStudentIdField || isGradeField;

                const className = isStudentIdField ? 'student-id' : (isGradeField ? 'grade-field' : '');
                const checkboxId = `field-${field.replace(/[^a-zA-Z0-9]/g, '-')}`; // ID v√°lido

                const fieldDiv = document.createElement('div');
                fieldDiv.className = `field-checkbox ${className}`;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.className = 'field-select';
                checkbox.setAttribute('data-field', field);
                checkbox.checked = checked;

                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.textContent = field;

                fieldDiv.appendChild(checkbox);
                fieldDiv.appendChild(label);

                elements.availableFields.appendChild(fieldDiv);
            });

            // Event listeners para los checkboxes (re-asignar despu√©s de crear)
            document.querySelectorAll('.field-select').forEach(checkbox => {
                checkbox.removeEventListener('change', eventHandlers.fieldSelectionChange); // Prevenir duplicados
                checkbox.addEventListener('change', eventHandlers.fieldSelectionChange);
            });

            // Actualizar campos seleccionados y UI de pesos/fechas inmediatamente
            eventHandlers.fieldSelectionChange();
        }
    },

    // Manejar cambio en selecci√≥n de campos
    fieldSelectionChange: () => {
        const selectedFields = [];
        const studentIdFields = [];
        const gradeFields = []; // Campos identificados como notas

        document.querySelectorAll('.field-select').forEach(checkbox => {
            const field = checkbox.getAttribute('data-field');
            if (field) {
                if (checkbox.checked) {
                    selectedFields.push(field);
                    if (checkbox.closest('.field-checkbox').classList.contains('student-id')) {
                        studentIdFields.push(field);
                    }
                    // Considerar como campo de nota si est√° marcado y no es ID
                    if (!checkbox.closest('.field-checkbox').classList.contains('student-id')) {
                         gradeFields.push(field);
                    }
                }
            }
        });

        console.log('Campos seleccionados:', selectedFields);
        console.log('Campos ID:', studentIdFields);
        console.log('Campos de Notas:', gradeFields);

        // Guardar campos seleccionados
        appState.config.selectedFields = selectedFields;
        appState.config.studentIdFields = studentIdFields;

        // Actualizar contenedor de pesos usando solo los 'gradeFields'
        if (elements.weightContainer) {
            elements.weightContainer.innerHTML = ''; // Limpiar

            gradeFields.forEach(evalName => {
                // Usar valores existentes si ya estaban en config (pueden venir de carga previa)
                const currentWeight = parseFloat(appState.config.weights[evalName]) || 0;
                const currentDate = appState.config.dates[evalName] || '';

                const weightItem = document.createElement('div');
                weightItem.className = 'weight-item';
                weightItem.innerHTML = `
                    <div class="weight-item-header">
                        <h4>${evalName}</h4>
                    </div>
                    <div class="weight-item-content">
                        <div>
                            <label for="weight-${evalName}">Peso (%)</label>
                            <input type="number" id="weight-${evalName}"
                                data-eval="${evalName}"
                                class="weight-input"
                                min="0" max="100" step="0.1"
                                value="${currentWeight}">
                        </div>
                        <div class="eval-date-container">
                            <label for="date-${evalName}">Fecha:</label>
                            <input type="text" id="date-${evalName}"
                                data-eval="${evalName}"
                                class="date-input flatpickr-input"
                                placeholder="Seleccionar fecha"
                                value="${currentDate}">
                        </div>
                        <!-- El selector de competencias se maneja en la pesta√±a de Mapeo -->
                    </div>
                `;

                elements.weightContainer.appendChild(weightItem);

                // Inicializar el selector de fecha para este input
                const dateInput = document.getElementById(`date-${evalName}`);
                if (dateInput) {
                    // Destruir instancia previa si existe
                    if (appState.datepickers[`date-${evalName}`]) {
                        appState.datepickers[`date-${evalName}`].destroy();
                    }
                    // Crear nueva instancia
                    appState.datepickers[`date-${evalName}`] = flatpickr(dateInput, {
                        dateFormat: "Y-m-d",
                        onChange: (selectedDates, dateStr, instance) => {
                            const evalKey = instance.element.getAttribute('data-eval');
                            if (evalKey) {
                                appState.config.dates[evalKey] = dateStr;
                                console.log(`Fecha actualizada para ${evalKey}: ${dateStr}`);
                                // Actualizar visualizaci√≥n si estamos en la pesta√±a de mapeo
                                if (document.getElementById('mapping')?.classList.contains('active')) {
                                    renderCompetenceMapping();
                                }
                            }
                        }
                    });
                    // Establecer fecha si ya existe en config
                    if (currentDate) {
                        appState.datepickers[`date-${evalName}`].setDate(currentDate, false);
                    }
                }
            });

            // Agregar event listeners a los nuevos inputs de peso
            document.querySelectorAll('.weight-input').forEach(input => {
                input.removeEventListener('input', eventHandlers.weightChange); // Prevenir duplicados
                input.addEventListener('input', eventHandlers.weightChange);
            });

            // Validar peso total inicial
            eventHandlers.weightChange(); // Llama a validateWeights internamente
        }
    },

    // Manejar cambio en los checkboxes de competencias (EN PESTA√ëA DE MAPEO)
    competenceCheckboxChange: (e) => {
        const evalName = e.target.getAttribute('data-eval');
        const compName = e.target.getAttribute('data-comp');
        const isChecked = e.target.checked;

        if (!evalName || !compName) return;

        // Inicializar el mapeo si es necesario
        if (!appState.processedData.competenceMappings) {
            appState.processedData.competenceMappings = {};
        }
        if (!appState.processedData.competenceMappings[evalName]) {
            appState.processedData.competenceMappings[evalName] = [];
        }

        // Actualizar el mapeo
        if (isChecked) {
            if (!appState.processedData.competenceMappings[evalName].includes(compName)) {
                appState.processedData.competenceMappings[evalName].push(compName);
            }
        } else {
            appState.processedData.competenceMappings[evalName] =
                appState.processedData.competenceMappings[evalName].filter(c => c !== compName);
        }
        console.log(`Mapeo actualizado para ${evalName}:`, appState.processedData.competenceMappings[evalName]);

        // Actualizar la vista de mapeo inmediatamente
        renderCompetenceMapping();
    },

    // Manejar cambio en pesos
    weightChange: () => {
        const weights = {};
        document.querySelectorAll('.weight-input').forEach(input => {
            const evalName = input.getAttribute('data-eval');
            // Usar 0 si el valor est√° vac√≠o o no es un n√∫mero v√°lido
            const weight = parseFloat(input.value);
            if (evalName) {
                weights[evalName] = isNaN(weight) || weight < 0 ? 0 : weight;
                 // Actualizar el valor del input si se corrigi√≥ a 0
                if (isNaN(weight) || weight < 0) input.value = 0;
            }
        });
        appState.config.weights = weights;
        console.log('Pesos actualizados:', appState.config.weights);
        // Validar si suman 100% (o menos)
        utils.validateWeights();
    },

    // Distribuir pesos equitativamente
    distributeWeights: () => {
        const weightInputs = document.querySelectorAll('.weight-input');
        if (weightInputs.length === 0) return;

        const equalWeight = (100 / weightInputs.length);
        // Usar un n√∫mero fijo de decimales para evitar problemas de redondeo
        const formattedWeight = parseFloat(equalWeight.toFixed(2));

        weightInputs.forEach(input => {
            const evalName = input.getAttribute('data-eval');
            input.value = formattedWeight; // Actualizar UI
            if (evalName) {
                appState.config.weights[evalName] = formattedWeight; // Actualizar estado
            }
        });

        console.log('Pesos distribuidos:', appState.config.weights);
        // Verificar peso total (puede que no sume exactamente 100 por redondeo)
        utils.validateWeights();
        utils.showMessage('Pesos distribuidos equitativamente.', 'success');
    },

    // Limpiar pesos
    clearWeights: () => {
        document.querySelectorAll('.weight-input').forEach(input => {
            input.value = 0; // Actualizar UI
            const evalName = input.getAttribute('data-eval');
            if (evalName) {
                appState.config.weights[evalName] = 0; // Actualizar estado
            }
        });
        console.log('Pesos limpiados:', appState.config.weights);
        // Verificar peso total
        utils.validateWeights();
        utils.showMessage('Pesos limpiados.', 'info');
    },

    // Guardar configuraci√≥n
    saveConfig: () => {
        console.log('Guardando configuraci√≥n...');
        // Verificar si se seleccion√≥ un grupo
        if (!appState.config.selectedGroup) {
            utils.showMessage('Debe seleccionar un grupo.', 'error');
            return;
        }

        // Verificar si se seleccionaron campos de notas
        const gradeFields = appState.config.selectedFields.filter(
            field => !appState.config.studentIdFields.includes(field)
        );
        if (gradeFields.length === 0) {
            utils.showMessage('Debe seleccionar al menos un campo de evaluaci√≥n/nota.', 'error');
            return;
        }

        // Verificar si los pesos son v√°lidos (<= 100%)
        if (!utils.validateWeights()) {
            utils.showMessage('La suma de los pesos debe ser menor o igual a 100%.', 'error');
            return;
        }

        // Guardar configuraci√≥n general (decimales, nota aprobatoria, semestre)
        appState.config.decimalPlaces = parseInt(elements.decimalPlaces.value) || 2;
        appState.config.passingGrade = parseFloat(elements.passingGrade.value) || 3.00;
        appState.config.semester = elements.semesterSelect ? elements.semesterSelect.value : '2025-1';

        console.log('Configuraci√≥n a guardar:', appState.config);

        // Procesar datos con la configuraci√≥n actual
        utils.showLoading();
        setTimeout(() => { // Simular procesamiento as√≠ncrono
            try {
                processData(); // Esta funci√≥n actualiza appState.processedData
                utils.hideLoading();
                utils.showMessage('Configuraci√≥n guardada y datos procesados.', 'success');
                console.log('Datos procesados:', appState.processedData);

                // Cambiar a la pesta√±a de mapeo de competencias
                elements.tabs.forEach(tab => tab.classList.remove('active'));
                elements.tabContents.forEach(content => content.classList.remove('active'));

                const mappingTab = document.querySelector('[data-tab="mapping"]');
                const mappingContent = document.getElementById('mapping');

                if (mappingTab) mappingTab.classList.add('active');
                if (mappingContent) mappingContent.classList.add('active');

                // Renderizar el mapeo de competencias
                renderCompetenceMapping();

            } catch (error) {
                utils.hideLoading();
                utils.showMessage('Error al procesar los datos: ' + error.message, 'error');
                console.error("Error en saveConfig > processData:", error);
            }
        }, 100); // Peque√±o delay
    },

    // Actualizar mapeo de competencias (bot√≥n en pesta√±a Mapeo)
    updateCompetenceMapping: () => {
        // Aqu√≠ podr√≠as a√±adir validaciones si fueran necesarias
        console.log('Mapeo de competencias guardado:', appState.processedData.competenceMappings);
        utils.showMessage('Mapeo de competencias actualizado.', 'success');

        // Opcional: Cambiar a la siguiente pesta√±a relevante (ej. Reporte Individual)
        elements.tabs.forEach(tab => tab.classList.remove('active'));
        elements.tabContents.forEach(content => content.classList.remove('active'));

        const individualTab = document.querySelector('[data-tab="individual"]');
        const individualContent = document.getElementById('individual');

        if (individualTab) individualTab.classList.add('active');
        if (individualContent) individualContent.classList.add('active');

        // Inicializar/Refrescar la pesta√±a individual
        initializeCompetenceFilters();
        initializeDatepickers();
        // Renderizar lista si no est√°
        if (elements.studentsList && elements.studentsList.children.length === 0) {
             processData();
        }
        // Si hay estudiante seleccionado, refrescar
        if (appState.currentStudent) {
            eventHandlers.selectStudent(appState.currentStudent);
        }
    },

    // B√∫squeda de estudiante
    searchStudent: () => {
        const searchTerm = elements.studentSearch ? elements.studentSearch.value.toLowerCase().trim() : '';
        const students = appState.processedData.students || [];

        if (elements.studentsList) {
            // Optimizaci√≥n: usar requestAnimationFrame para b√∫squedas frecuentes
            requestAnimationFrame(() => {
                elements.studentsList.innerHTML = ''; // Limpiar lista

                const fragment = document.createDocumentFragment();
                let count = 0;

                students.forEach(student => {
                    // Buscar en el nombre (asegurarse que 'Nombre' existe)
                    const name = student.Nombre || '';
                    if (name.toLowerCase().includes(searchTerm)) {
                        const studentElement = document.createElement('div');
                        studentElement.className = 'student-item';
                        studentElement.dataset.id = student.id;
                        studentElement.textContent = name;
                        // Marcar si es el estudiante actualmente seleccionado
                        if (appState.currentStudent && appState.currentStudent.id === student.id) {
                            studentElement.classList.add('selected');
                        }
                        studentElement.addEventListener('click', () => eventHandlers.selectStudent(student));
                        fragment.appendChild(studentElement);
                        count++;
                    }
                });

                if (count === 0) {
                    elements.studentsList.innerHTML = '<div class="student-item">No se encontraron estudiantes.</div>';
                } else {
                    elements.studentsList.appendChild(fragment);
                }
            });
        }
    },

    // Seleccionar estudiante
    selectStudent: (student) => {
        if (!student || !student.id) {
            console.warn("Intento de seleccionar estudiante inv√°lido:", student);
            return;
        }
        console.log("Seleccionando estudiante:", student.Nombre, student.id);

        appState.currentStudent = student;

        // Marcar estudiante seleccionado en la lista (m√°s eficiente)
        document.querySelectorAll('.student-item').forEach(item => {
            item.classList.toggle('selected', item.dataset.id === student.id);
        });

        // Actualizar UI con info del estudiante
        if (elements.studentName) {
            elements.studentName.textContent = student.Nombre || 'Estudiante sin nombre';
        }
        if (elements.studentInfo) {
            elements.studentInfo.textContent = `Grupo: ${appState.config.selectedGroup || 'N/A'} | Semestre: ${appState.config.semester || 'N/A'}`;
        }

        // Aplicar filtros actuales para este estudiante
        eventHandlers.filterIndividualByCompetence(); // Esta funci√≥n llama a los renders
    },

    // Filtrar reporte individual (por competencia o fecha)
    filterIndividualByCompetence: () => {
        if (!appState.currentStudent) {
             // Limpiar reporte si no hay estudiante seleccionado
            if (elements.gradesTable?.querySelector('tbody')) elements.gradesTable.querySelector('tbody').innerHTML = '';
            if (elements.competenceContainer) elements.competenceContainer.innerHTML = '';
            if (elements.predictionResults) elements.predictionResults.innerHTML = '';
            if (elements.studentName) elements.studentName.textContent = 'Seleccione un estudiante';
            if (elements.studentInfo) elements.studentInfo.textContent = '';
            return;
        }

        // Obtener filtros activos
        const activeCompetences = getActiveCompetenceFilters('individualCompetenceFilter');
        const dateRange = {
            start: elements.individualStartDate ? elements.individualStartDate.value : null,
            end: elements.individualEndDate ? elements.individualEndDate.value : null
        };

        // Validar rango de fechas
        if (dateRange.start && dateRange.end) {
            try {
                const startDate = new Date(dateRange.start + 'T00:00:00');
                const endDate = new Date(dateRange.end + 'T00:00:00');
                if (startDate > endDate) {
                    utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'warning');
                    // Podr√≠amos resetear las fechas o simplemente no aplicar el filtro de fecha
                    dateRange.start = null;
                    dateRange.end = null;
                    if (elements.individualStartDate) appState.datepickers.individualStartDate?.clear();
                    if (elements.individualEndDate) appState.datepickers.individualEndDate?.clear();
                }
            } catch (e) {
                console.error('Error al validar fechas:', e);
                // No aplicar filtro de fecha si hay error
                dateRange.start = null;
                dateRange.end = null;
            }
        }

        console.log("Filtrando reporte individual:", { student: appState.currentStudent.Nombre, competences: activeCompetences, dateRange });

        // Almacenar filtros en el estado
        appState.filters.individual.competences = activeCompetences;
        appState.filters.individual.dateRange = dateRange;

        // Re-renderizar las secciones del reporte individual con los filtros
        renderStudentGrades(appState.currentStudent, activeCompetences, dateRange);
        renderStudentCompetences(appState.currentStudent, activeCompetences, dateRange);
        renderPrediction(appState.currentStudent, activeCompetences); // La predicci√≥n podr√≠a depender de las competencias filtradas
    },

    // Filtrar reporte grupal (por rendimiento, competencia o fecha)
    filterByPerformance: () => {
        console.log("Filtrando reporte grupal...");

        // Obtener valores de los filtros
        const performanceValue = elements.performanceFilter ? elements.performanceFilter.value : 'all';
        const competenceValue = elements.competenceFilter ? elements.competenceFilter.value : 'all';
        const dateRange = {
            start: elements.groupStartDate ? elements.groupStartDate.value : null,
            end: elements.groupEndDate ? elements.groupEndDate.value : null
        };

        // Validar rango de fechas
        if (dateRange.start && dateRange.end) {
            try {
                const startDate = new Date(dateRange.start + 'T00:00:00');
                const endDate = new Date(dateRange.end + 'T00:00:00');
                if (startDate > endDate) {
                    utils.showMessage('La fecha inicial no puede ser mayor que la fecha final.', 'warning');
                    dateRange.start = null;
                    dateRange.end = null;
                    if (elements.groupStartDate) appState.datepickers.groupStartDate?.clear();
                    if (elements.groupEndDate) appState.datepickers.groupEndDate?.clear();
                }
            } catch (e) {
                console.error('Error al validar fechas:', e);
                dateRange.start = null;
                dateRange.end = null;
            }
        }

        // Almacenar filtros en el estado
        appState.filters.group.performance = performanceValue;
        appState.filters.group.competence = competenceValue;
        appState.filters.group.dateRange = dateRange;

        console.log("Filtros grupales:", appState.filters.group);

        const students = appState.processedData.students || [];
        let filteredStudents = students;
        const filterCompetencesArray = competenceValue !== 'all' ? [competenceValue] : [];

        // 1. Filtrar por Competencia (si aplica, afecta el c√°lculo de la nota para rendimiento)
        // No filtramos la lista de estudiantes aqu√≠, sino que pasamos el filtro de competencia
        // a calculateFinalGrade para que la nota se calcule sobre esas competencias.

        // 2. Filtrar por Rendimiento (basado en la nota calculada con filtros de competencia/fecha)
        if (performanceValue !== 'all') {
            const passingGrade = appState.config.passingGrade || 3.0;
            // Definir umbrales claros (ej. Bajo < 3.0, Medio 3.0-3.9, Alto >= 4.0)
            const mediumThreshold = passingGrade; // Incluye la nota de aprobaci√≥n
            const highThreshold = 4.0; // Ejemplo, podr√≠a ser passingGrade + 1

            filteredStudents = filteredStudents.filter(s => {
                // Calcular la nota final considerando filtros de competencia y fecha
                const grade = utils.calculateFinalGrade(s, filterCompetencesArray, dateRange);

                switch (performanceValue) {
                    case 'high':
                        return grade >= highThreshold;
                    case 'medium':
                        return grade >= mediumThreshold && grade < highThreshold;
                    case 'low':
                        return grade < mediumThreshold;
                    default:
                        return true; // No deber√≠a pasar, pero por seguridad
                }
            });
        }

        console.log(`Estudiantes despu√©s de filtrar por rendimiento (${performanceValue}):`, filteredStudents.length);

        // Renderizar el reporte grupal con los estudiantes filtrados y pasando los filtros originales
        renderGroupReport(filteredStudents, filterCompetencesArray, dateRange);
    },


    // Seleccionar evaluaci√≥n para reporte
    selectEvaluation: () => {
        const evalName = elements.evaluationSelect ? elements.evaluationSelect.value : '';
        // No hacer nada si no se selecciona una evaluaci√≥n v√°lida
        if (!evalName) {
             if (elements.evaluationReportContainer) elements.evaluationReportContainer.innerHTML = '<div class="message info">Seleccione una evaluaci√≥n para ver el reporte.</div>';
             // Limpiar gr√°ficos
             if (appState.charts.evaluationChart) appState.charts.evaluationChart.destroy();
             if (appState.charts.evalCompetenceChart) appState.charts.evalCompetenceChart.destroy();
             appState.filters.evaluation.selectedEval = '';
             return;
        }

        // Obtener filtro de competencia actual para esta pesta√±a
        const competenceValue = elements.evalCompetenceFilter ?
            elements.evalCompetenceFilter.value : 'all';

        // Guardar selecci√≥n en el estado
        appState.filters.evaluation.selectedEval = evalName;
        appState.filters.evaluation.competence = competenceValue;

        console.log("Seleccionada evaluaci√≥n:", evalName, "con filtro de competencia:", competenceValue);

        // Renderizar el reporte para la evaluaci√≥n seleccionada
        renderEvaluationReport(evalName, competenceValue !== 'all' ? [competenceValue] : []);
    },

    // Filtrar reporte de evaluaci√≥n por competencia
    filterEvaluationByCompetence: () => {
        const evalName = appState.filters.evaluation.selectedEval; // Usar la evaluaci√≥n ya seleccionada
        if (!evalName) {
            // Si no hay evaluaci√≥n seleccionada, no hacer nada (o mostrar mensaje)
            return;
        }

        const competenceValue = elements.evalCompetenceFilter ?
            elements.evalCompetenceFilter.value : 'all';

        // Actualizar filtro de competencia en el estado
        appState.filters.evaluation.competence = competenceValue;

        console.log("Filtrando reporte de evaluaci√≥n", evalName, "por competencia:", competenceValue);

        // Re-renderizar el reporte con el nuevo filtro de competencia
        renderEvaluationReport(evalName, competenceValue !== 'all' ? [competenceValue] : []);
    },

    // Seleccionar estudiante para l√≠nea de tiempo
    selectTimelineStudent: () => {
        const studentValue = elements.timelineStudentSelect ?
            elements.timelineStudentSelect.value : 'group';
        const competenceValue = appState.filters.timeline.competence; // Mantener filtro de competencia

        appState.filters.timeline.student = studentValue;

        console.log("Seleccionado para l√≠nea de tiempo:", studentValue);

        renderTimeline(studentValue, competenceValue);
    },

    // Filtrar l√≠nea de tiempo por competencia
    filterTimelineByCompetence: () => {
        const studentValue = appState.filters.timeline.student; // Mantener estudiante/grupo
        const competenceValue = elements.timelineCompetenceFilter ?
            elements.timelineCompetenceFilter.value : 'all';

        appState.filters.timeline.competence = competenceValue;

        console.log("Filtrando l√≠nea de tiempo por competencia:", competenceValue);

        renderTimeline(studentValue, competenceValue);
    },

    // --- Funciones de Vista Previa y Exportaci√≥n ---
    // (Se mantienen similares, pero asegur√°ndose de usar el contenido actualizado y filtros)

    // Vista previa de reporte individual
    previewIndividualReport: () => {
        if (!appState.currentStudent) {
            utils.showMessage('Debe seleccionar un estudiante.', 'error');
            return;
        }
        // Usar los filtros actuales almacenados en el estado
        const activeCompetences = appState.filters.individual.competences;
        const dateRange = appState.filters.individual.dateRange;

        // Generar el contenido HTML del reporte con los filtros aplicados
        // Es mejor clonar el contenedor y REGENERAR su contenido interno
        // basado en los datos filtrados, en lugar de clonar directamente el HTML visible.

        let reportContent = `<div id="individualReportPreview" style="padding: 20px; background: white; border-radius: 5px;">`; // Contenedor para preview

        // 1. Cabecera
        reportContent += `
            <div class="report-header">
                <h2>${appState.currentStudent.Nombre || 'Estudiante sin nombre'}</h2>
                <div style="color: var(--dark-gray);">Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</div>
            </div>`;

        // 2. Tabla de Evaluaciones (regenerada con filtros)
        reportContent += `
            <div class="report-section">
                <h3>Evaluaciones</h3>
                <table class="grades-table">
                    <thead>
                        <tr>
                            <th>Evaluaci√≥n</th>
                            <th>Fecha</th>
                            <th>Nota</th>
                            <th>Peso</th>
                            <th>Contribuci√≥n</th>
                            <th>Competencias</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${generateStudentGradesHtml(appState.currentStudent, activeCompetences, dateRange)}
                    </tbody>
                </table>
            </div>`;

        // 3. Competencias (regeneradas con filtros)
        reportContent += `
            <div class="report-section" style="margin-top: 10px;">
                <h3>Competencias</h3>
                <div class="competence-container">
                    ${generateStudentCompetencesHtml(appState.currentStudent, activeCompetences, dateRange)}
                </div>
            </div>`;

        // 4. Predicci√≥n (regenerada con filtros)
        reportContent += `
            <div class="prediction-container" style="margin-top: 20px;">
                <h3>Predicci√≥n</h3>
                <p>Para aprobar el curso (${utils.formatNumber(appState.config.passingGrade)}), este estudiante necesita obtener:</p>
                <div>
                    ${generatePredictionHtml(appState.currentStudent, activeCompetences)}
                </div>
            </div>`;

        reportContent += `</div>`; // Cerrar contenedor preview

        utils.showPreview(
            `Vista Previa - Reporte de ${appState.currentStudent.Nombre || 'Estudiante'}`,
            reportContent,
            'pdf', // Tipo de exportaci√≥n por defecto al confirmar
            `reporte_${(appState.currentStudent.Nombre || 'estudiante').replace(/\s+/g, '_')}.pdf`
        );
    },

    // Exportar reporte individual a PDF
    exportIndividualPdf: () => {
        if (!appState.currentStudent) {
            utils.showMessage('Debe seleccionar un estudiante.', 'error');
            return;
        }
        // Usar filtros actuales
        const activeCompetences = appState.filters.individual.competences;
        const dateRange = appState.filters.individual.dateRange;

        // Generar contenido HTML actualizado para exportar
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`; // Contenedor con m√°rgenes para PDF
        reportContent += `
            <div class="report-header">
                <h2>${appState.currentStudent.Nombre || 'Estudiante sin nombre'}</h2>
                <div style="color: #555; font-size: 10pt;">Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</div>
            </div>
            <div class="report-section">
                <h3>Evaluaciones</h3>
                <table class="grades-table">
                    <thead><tr><th>Evaluaci√≥n</th><th>Fecha</th><th>Nota</th><th>Peso</th><th>Contribuci√≥n</th><th>Competencias</th></tr></thead>
                    <tbody>${generateStudentGradesHtml(appState.currentStudent, activeCompetences, dateRange)}</tbody>
                </table>
            </div>
            <div class="report-section">
                <h3>Competencias</h3>
                <div class="competence-container">${generateStudentCompetencesHtml(appState.currentStudent, activeCompetences, dateRange)}</div>
            </div>
            <div class="prediction-container">
                <h3>Predicci√≥n</h3>
                <p>Para aprobar (${utils.formatNumber(appState.config.passingGrade)}), necesita:</p>
                <div>${generatePredictionHtml(appState.currentStudent, activeCompetences)}</div>
            </div>
        `;
        reportContent += `</div>`;

        const filename = `reporte_${(appState.currentStudent.Nombre || 'estudiante').replace(/\s+/g, '_')}.pdf`;
        utils.exportToPdf(reportContent, filename);
    },

    // Exportar reporte individual a Excel
    exportIndividualExcel: () => {
        if (!appState.currentStudent) {
            utils.showMessage('Debe seleccionar un estudiante.', 'error');
            return;
        }
        // Usar filtros actuales
        const activeCompetences = appState.filters.individual.competences;
        const dateRange = appState.filters.individual.dateRange;
        const student = appState.currentStudent;

        const excelData = [];

        // Informaci√≥n del estudiante
        excelData.push({ "Campo": "Estudiante", "Valor": student.Nombre });
        excelData.push({ "Campo": "Grupo", "Valor": appState.config.selectedGroup });
        excelData.push({ "Campo": "Semestre", "Valor": appState.config.semester });
        excelData.push({ "Campo": "Filtro Competencias", "Valor": activeCompetences.length > 0 ? activeCompetences.join(', ') : 'Todas' });
        excelData.push({ "Campo": "Filtro Fechas", "Valor": dateRange.start && dateRange.end ? `${utils.formatDate(dateRange.start)} - ${utils.formatDate(dateRange.end)}` : 'Todas' });
        excelData.push({}); // Fila vac√≠a

        // Evaluaciones
        excelData.push({ "Campo": "--- EVALUACIONES ---" });
        excelData.push({
            "Evaluaci√≥n": "Evaluaci√≥n", "Fecha": "Fecha", "Nota": "Nota",
            "Peso (%)": "Peso (%)", "Contribuci√≥n": "Contribuci√≥n", "Competencias": "Competencias"
        });

        let totalWeight = 0;
        let completedWeight = 0;
        let totalContribution = 0;

        for (const evalName in appState.config.weights) {
            // Aplicar filtros
            let includeEval = true;
            const evalCompetencesList = appState.processedData.competenceMappings[evalName] || [];
            if (activeCompetences.length > 0) {
                if (!evalCompetencesList.some(comp => activeCompetences.includes(comp))) {
                    includeEval = false;
                }
            }
            if (includeEval && dateRange.start && dateRange.end) {
                const evalDateStr = appState.config.dates[evalName];
                if (evalDateStr) {
                    try {
                        const evalDate = new Date(evalDateStr + 'T00:00:00');
                        const startDate = new Date(dateRange.start + 'T00:00:00');
                        const endDate = new Date(dateRange.end + 'T23:59:59');
                        if (evalDate < startDate || evalDate > endDate) {
                            includeEval = false;
                        }
                    } catch (e) { includeEval = false; }
                } else { includeEval = false; }
            }

            if (includeEval) {
                const weight = parseFloat(appState.config.weights[evalName]) || 0;
                totalWeight += weight / 100; // Sumar peso considerado
                const gradeValue = student[evalName];
                const grade = (gradeValue !== undefined && gradeValue !== null && gradeValue !== '' && !isNaN(parseFloat(gradeValue))) ? parseFloat(gradeValue) : null;
                const contribution = grade !== null ? grade * (weight / 100) : null;
                const evalDate = appState.config.dates[evalName] || '';

                if (grade !== null) {
                    completedWeight += weight / 100;
                    totalContribution += contribution;
                }

                excelData.push({
                    "Evaluaci√≥n": evalName,
                    "Fecha": utils.formatDate(evalDate),
                    "Nota": grade !== null ? utils.formatNumber(grade) : "Pendiente",
                    "Peso (%)": utils.formatNumber(weight),
                    "Contribuci√≥n": grade !== null ? utils.formatNumber(contribution) : "N/A",
                    "Competencias": evalCompetencesList.join(', ')
                });
            }
        }

        // Calcular nota final basada en filtros
        const finalGrade = completedWeight > 0 ? totalContribution / completedWeight : 0;

        excelData.push({}); // Fila vac√≠a
        excelData.push({ "Evaluaci√≥n": "TOTAL", "Peso (%)": utils.formatNumber(totalWeight * 100), "Contribuci√≥n": utils.formatNumber(totalContribution) });
        excelData.push({ "Evaluaci√≥n": "NOTA ACTUAL", "Nota": utils.formatNumber(finalGrade), "Peso (%)": `${utils.formatNumber(completedWeight * 100)}% completado` });
        excelData.push({}); // Fila vac√≠a

        // Competencias
        excelData.push({ "Campo": "--- COMPETENCIAS ---" });
        excelData.push({ "Competencia": "Competencia", "Promedio": "Promedio", "Evaluaciones": "Evaluaciones Relacionadas" });

        const studentCompetences = calculateStudentCompetences(student, activeCompetences, dateRange); // Necesita funci√≥n auxiliar
        studentCompetences.forEach(compData => {
             excelData.push({
                "Competencia": compData.name,
                "Promedio": compData.average !== null ? utils.formatNumber(compData.average) : "Sin datos",
                "Evaluaciones": compData.relatedEvals.join(', ')
            });
            // Opcional: A√±adir indicadores
            const indicators = appState.processedData.indicators[compData.name] || [];
            if (indicators.length > 0) {
                 excelData.push({ "Competencia": "", "Promedio": "Indicadores:", "Evaluaciones": indicators.join('; ') });
            }
        });
        excelData.push({}); // Fila vac√≠a

        // Predicci√≥n
        excelData.push({ "Campo": "--- PREDICCI√ìN ---" });
        const prediction = utils.predictRequiredGrade(student, activeCompetences);
        excelData.push({ "Predicci√≥n": prediction.message });
        if (prediction.possible && prediction.requiredGrade > 0) {
            excelData.push({ "Nota Requerida": utils.formatNumber(prediction.requiredGrade) });
            excelData.push({ "Evaluaciones Pendientes": prediction.evaluations.join(', ') });
        }

        const filename = `reporte_${(student.Nombre || 'estudiante').replace(/\s+/g, '_')}.xlsx`;
        utils.exportToExcel(excelData, filename);
    },

    // Imprimir reporte individual
    printIndividualReport: () => {
        if (!appState.currentStudent) {
            utils.showMessage('Debe seleccionar un estudiante.', 'error');
            return;
        }
        // Usar filtros actuales
        const activeCompetences = appState.filters.individual.competences;
        const dateRange = appState.filters.individual.dateRange;

        // Generar contenido HTML actualizado para imprimir
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`; // Contenedor con m√°rgenes
        reportContent += `
            <div class="report-header">
                <h2>${appState.currentStudent.Nombre || 'Estudiante sin nombre'}</h2>
                <div style="color: #555; font-size: 10pt;">Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</div>
            </div>
            <div class="report-section">
                <h3>Evaluaciones</h3>
                <table class="grades-table">
                    <thead><tr><th>Evaluaci√≥n</th><th>Fecha</th><th>Nota</th><th>Peso</th><th>Contribuci√≥n</th><th>Competencias</th></tr></thead>
                    <tbody>${generateStudentGradesHtml(appState.currentStudent, activeCompetences, dateRange)}</tbody>
                </table>
            </div>
            <div class="report-section">
                <h3>Competencias</h3>
                <div class="competence-container">${generateStudentCompetencesHtml(appState.currentStudent, activeCompetences, dateRange)}</div>
            </div>
            <div class="prediction-container">
                <h3>Predicci√≥n</h3>
                <p>Para aprobar (${utils.formatNumber(appState.config.passingGrade)}), necesita:</p>
                <div>${generatePredictionHtml(appState.currentStudent, activeCompetences)}</div>
            </div>
        `;
        reportContent += `</div>`;

        utils.printContent(reportContent);
    },

    // Vista previa de reporte grupal
    previewGroupReport: () => {
        // Usar filtros actuales
        const performanceFilter = appState.filters.group.performance;
        const competenceFilter = appState.filters.group.competence;
        const dateRange = appState.filters.group.dateRange;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Obtener estudiantes filtrados (reaplicar filtro de rendimiento)
        const students = appState.processedData.students || [];
        let filteredStudents = students;
        if (performanceFilter !== 'all') {
            const passingGrade = appState.config.passingGrade || 3.0;
            const mediumThreshold = passingGrade;
            const highThreshold = 4.0;
            filteredStudents = filteredStudents.filter(s => {
                const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                switch (performanceFilter) {
                    case 'high': return grade >= highThreshold;
                    case 'medium': return grade >= mediumThreshold && grade < highThreshold;
                    case 'low': return grade < mediumThreshold;
                    default: return true;
                }
            });
        }

        // Generar contenido HTML para la vista previa
        let reportContent = `<div style="padding: 20px; background: white; border-radius: 5px;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
                <p>Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros aplicados:</strong>
                    <ul>
                        <li>Rendimiento: ${performanceFilter === 'all' ? 'Todos' : performanceFilter}</li>
                        <li>Competencia: ${competenceFilter === 'all' ? 'Todas' : competenceFilter}</li>
                        <li>Fechas: ${dateRange.start && dateRange.end ? `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}</li>
                    </ul>
                </div>
            </div>
        `;

        // A√±adir estad√≠sticas (regenerar HTML)
        reportContent += generateGroupStatsHtml(filteredStudents, competenceValue, dateRange);

        // A√±adir gr√°ficos como im√°genes (si existen)
        reportContent += `<div style="margin: 20px 0;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.groupChart) {
            try { reportContent += `<img src="${appState.charts.groupChart.toBase64Image()}" style="max-width:100%; height:auto;">`; }
            catch (e) { reportContent += `<p>Error al generar gr√°fico.</p>`; console.error(e); }
        } else { reportContent += `<p>No hay datos para el gr√°fico.</p>`; }
        reportContent += `</div>`;

        reportContent += `<div style="margin: 20px 0;"><h3>Rendimiento por Competencia</h3>`;
        if (appState.charts.competenceChart) {
             try { reportContent += `<img src="${appState.charts.competenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; }
             catch (e) { reportContent += `<p>Error al generar gr√°fico.</p>`; console.error(e); }
        } else { reportContent += `<p>No hay datos para el gr√°fico.</p>`; }
        reportContent += `</div>`;

        // A√±adir lista de estudiantes en riesgo (regenerar HTML)
        reportContent += `<div style="margin: 20px 0;"><h3>Estudiantes en Riesgo</h3>`;
        reportContent += generateRiskStudentsHtml(filteredStudents, competenceValue, dateRange);
        reportContent += `</div>`;

        reportContent += `</div>`; // Cerrar contenedor

        utils.showPreview(
            'Vista Previa - Reporte Grupal',
            reportContent,
            'pdf',
            `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.pdf`
        );
    },

    // Exportar reporte grupal a PDF
    exportGroupPdf: () => {
        // Usar filtros actuales
        const performanceFilter = appState.filters.group.performance;
        const competenceFilter = appState.filters.group.competence;
        const dateRange = appState.filters.group.dateRange;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Obtener estudiantes filtrados
        const students = appState.processedData.students || [];
        let filteredStudents = students;
         if (performanceFilter !== 'all') {
            const passingGrade = appState.config.passingGrade || 3.0;
            const mediumThreshold = passingGrade;
            const highThreshold = 4.0;
            filteredStudents = filteredStudents.filter(s => {
                const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                switch (performanceFilter) {
                    case 'high': return grade >= highThreshold;
                    case 'medium': return grade >= mediumThreshold && grade < highThreshold;
                    case 'low': return grade < mediumThreshold;
                    default: return true;
                }
            });
        }

        // Generar contenido HTML para PDF
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
                <p>Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Rendimiento: ${performanceFilter}, Competencia: ${competenceFilter}, Fechas: ${dateRange.start && dateRange.end ? `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}
                </div>
            </div>
        `;
        reportContent += generateGroupStatsHtml(filteredStudents, competenceValue, dateRange);
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.groupChart) {
            try { reportContent += `<img src="${appState.charts.groupChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Rendimiento por Competencia</h3>`;
        if (appState.charts.competenceChart) {
            try { reportContent += `<img src="${appState.charts.competenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Estudiantes en Riesgo</h3>`;
        reportContent += generateRiskStudentsHtml(filteredStudents, competenceValue, dateRange);
        reportContent += `</div>`;
        reportContent += `</div>`;

        const filename = `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.pdf`;
        utils.exportToPdf(reportContent, filename);
    },

    // Exportar reporte grupal a Excel
    exportGroupExcel: () => {
        // Usar filtros actuales
        const performanceFilter = appState.filters.group.performance;
        const competenceFilter = appState.filters.group.competence;
        const dateRange = appState.filters.group.dateRange;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Obtener estudiantes filtrados
        const students = appState.processedData.students || [];
        let filteredStudents = students;
         if (performanceFilter !== 'all') {
            const passingGrade = appState.config.passingGrade || 3.0;
            const mediumThreshold = passingGrade;
            const highThreshold = 4.0;
            filteredStudents = filteredStudents.filter(s => {
                const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                switch (performanceFilter) {
                    case 'high': return grade >= highThreshold;
                    case 'medium': return grade >= mediumThreshold && grade < highThreshold;
                    case 'low': return grade < mediumThreshold;
                    default: return true;
                }
            });
        }

        const excelData = [];

        // Info y Filtros
        excelData.push({ "Campo": "Grupo", "Valor": appState.config.selectedGroup });
        excelData.push({ "Campo": "Semestre", "Valor": appState.config.semester });
        excelData.push({ "Campo": "Filtro Rendimiento", "Valor": performanceFilter });
        excelData.push({ "Campo": "Filtro Competencia", "Valor": competenceFilter });
        excelData.push({ "Campo": "Filtro Fechas", "Valor": dateRange.start && dateRange.end ? `${utils.formatDate(dateRange.start)} - ${utils.formatDate(dateRange.end)}` : 'Todas' });
        excelData.push({});

        // Estad√≠sticas
        excelData.push({ "Campo": "--- ESTAD√çSTICAS ---" });
        const stats = utils.calculateGroupStats(filteredStudents, competenceValue, dateRange);
        if (stats) {
            excelData.push({ "Estad√≠stica": "Total Estudiantes (Grupo)", "Valor": stats.totalStudents });
            excelData.push({ "Estad√≠stica": "Estudiantes (Filtrados)", "Valor": filteredStudents.length });
            excelData.push({ "Estad√≠stica": "Estudiantes Evaluados (Filtrados)", "Valor": stats.evaluatedStudents });
            excelData.push({ "Estad√≠stica": "Promedio (Filtrados)", "Valor": utils.formatNumber(stats.average) });
            excelData.push({ "Estad√≠stica": "Nota M√≠nima (Filtrados)", "Valor": utils.formatNumber(stats.min) });
            excelData.push({ "Estad√≠stica": "Nota M√°xima (Filtrados)", "Valor": utils.formatNumber(stats.max) });
            excelData.push({ "Estad√≠stica": "Desv. Est√°ndar (Filtrados)", "Valor": utils.formatNumber(stats.stdDev) });
            excelData.push({ "Estad√≠stica": "Estudiantes en Riesgo (Filtrados)", "Valor": stats.studentsAtRisk });
        }
        excelData.push({});

        // Rendimiento por Competencia (calculado sobre TODOS los estudiantes, pero considerando filtros de fecha)
        excelData.push({ "Campo": "--- RENDIMIENTO POR COMPETENCIA (Grupo Completo) ---" });
        excelData.push({ "Competencia": "Competencia", "Promedio": "Promedio", "Tasa Aprob. (%)": "Tasa Aprob. (%)", "Evaluados": "Evaluados" });
        const compPerformance = utils.calculateCompetencePerformance(students, [], dateRange); // Usar todos los estudiantes, aplicar filtro fecha
        const competencesToExport = competenceValue.length > 0 ? competenceValue : utils.getUniqueCompetences();
        competencesToExport.forEach(comp => {
            const perf = compPerformance[comp];
            if (perf && perf.count > 0) {
                const passRate = perf.totalStudents > 0 ? (perf.passStudents / perf.totalStudents) * 100 : 0;
                excelData.push({
                    "Competencia": comp,
                    "Promedio": utils.formatNumber(perf.average),
                    "Tasa Aprob. (%)": utils.formatNumber(passRate),
                    "Evaluados": perf.totalStudents
                });
            } else if (perf) {
                 excelData.push({ "Competencia": comp, "Promedio": "Sin datos", "Tasa Aprob. (%)": "N/A", "Evaluados": 0 });
            }
        });
        excelData.push({});

        // Lista de Estudiantes Filtrados
        excelData.push({ "Campo": "--- LISTA ESTUDIANTES (Filtrados) ---" });
        excelData.push({ "Nombre": "Nombre", "Nota Final": "Nota Final", "Estado": "Estado" });
        filteredStudents.sort((a, b) => (a.Nombre || '').localeCompare(b.Nombre || '')).forEach(student => {
            const finalGrade = utils.calculateFinalGrade(student, competenceValue, dateRange);
            const status = finalGrade >= appState.config.passingGrade ? "Aprobado" : "Reprobado";
            excelData.push({
                "Nombre": student.Nombre,
                "Nota Final": utils.formatNumber(finalGrade),
                "Estado": status
            });
        });

        const filename = `reporte_grupal_${appState.config.selectedGroup.replace(/\s+/g, '_')}.xlsx`;
        utils.exportToExcel(excelData, filename);
    },

    // Imprimir reporte grupal
    printGroupReport: () => {
        // Usar filtros actuales
        const performanceFilter = appState.filters.group.performance;
        const competenceFilter = appState.filters.group.competence;
        const dateRange = appState.filters.group.dateRange;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Obtener estudiantes filtrados
        const students = appState.processedData.students || [];
        let filteredStudents = students;
         if (performanceFilter !== 'all') {
            const passingGrade = appState.config.passingGrade || 3.0;
            const mediumThreshold = passingGrade;
            const highThreshold = 4.0;
            filteredStudents = filteredStudents.filter(s => {
                const grade = utils.calculateFinalGrade(s, competenceValue, dateRange);
                switch (performanceFilter) {
                    case 'high': return grade >= highThreshold;
                    case 'medium': return grade >= mediumThreshold && grade < highThreshold;
                    case 'low': return grade < mediumThreshold;
                    default: return true;
                }
            });
        }

        // Generar contenido HTML para imprimir
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte Grupal - ${appState.config.selectedGroup}</h2>
                <p>Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Rendimiento: ${performanceFilter}, Competencia: ${competenceFilter}, Fechas: ${dateRange.start && dateRange.end ? `${utils.formatDate(dateRange.start)} a ${utils.formatDate(dateRange.end)}` : 'Todas'}
                </div>
            </div>
        `;
        reportContent += generateGroupStatsHtml(filteredStudents, competenceValue, dateRange);
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.groupChart) {
            try { reportContent += `<img src="${appState.charts.groupChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Rendimiento por Competencia</h3>`;
        if (appState.charts.competenceChart) {
            try { reportContent += `<img src="${appState.charts.competenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Estudiantes en Riesgo</h3>`;
        reportContent += generateRiskStudentsHtml(filteredStudents, competenceValue, dateRange);
        reportContent += `</div>`;
        reportContent += `</div>`;

        utils.printContent(reportContent);
    },

    // Vista previa de reporte por evaluaci√≥n
    previewEvaluationReport: () => {
        const evalName = appState.filters.evaluation.selectedEval;
        if (!evalName) {
            utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
            return;
        }
        const competenceFilter = appState.filters.evaluation.competence;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Generar contenido HTML para la vista previa
        let reportContent = `<div style="padding: 20px; background: white; border-radius: 5px;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceFilter}
                </div>
            </div>
        `;
        // A√±adir estad√≠sticas y lista (regenerar HTML)
        reportContent += generateEvaluationStatsHtml(evalName, competenceValue);

        // A√±adir gr√°ficos como im√°genes
        reportContent += `<div style="margin: 20px 0;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.evaluationChart) {
            try { reportContent += `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        } else { reportContent += `<p>No hay datos para el gr√°fico.</p>`; }
        reportContent += `</div>`;

        reportContent += `<div style="margin: 20px 0;"><h3>Rendimiento por Competencia (en esta Eval)</h3>`;
        if (appState.charts.evalCompetenceChart) {
            try { reportContent += `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        } else { reportContent += `<p>No hay datos para el gr√°fico.</p>`; }
        reportContent += `</div>`;

        reportContent += `</div>`; // Cerrar contenedor

        utils.showPreview(
            `Vista Previa - Reporte de Evaluaci√≥n ${evalName}`,
            reportContent,
            'pdf',
            `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.pdf`
        );
    },

    // Exportar reporte de evaluaci√≥n a PDF
    exportEvaluationPdf: () => {
        const evalName = appState.filters.evaluation.selectedEval;
        if (!evalName) {
            utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
            return;
        }
        const competenceFilter = appState.filters.evaluation.competence;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Generar contenido HTML para PDF
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceFilter}
                </div>
            </div>
        `;
        reportContent += generateEvaluationStatsHtml(evalName, competenceValue);
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.evaluationChart) {
            try { reportContent += `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Rendimiento por Competencia (en esta Eval)</h3>`;
        if (appState.charts.evalCompetenceChart) {
            try { reportContent += `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `</div>`;

        const filename = `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.pdf`;
        utils.exportToPdf(reportContent, filename);
    },

    // Exportar reporte de evaluaci√≥n a Excel
    exportEvaluationExcel: () => {
        const evalName = appState.filters.evaluation.selectedEval;
        if (!evalName) {
            utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
            return;
        }
        const competenceFilter = appState.filters.evaluation.competence;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];
        const students = appState.processedData.students || [];

        const evalData = students.map(student => ({
            id: student.id,
            name: student.Nombre,
            grade: student[evalName] !== undefined && student[evalName] !== null && student[evalName] !== '' ? parseFloat(student[evalName]) : null
        })).filter(item => item.grade !== null);

        if (evalData.length === 0) {
            utils.showMessage('No hay datos de calificaci√≥n para esta evaluaci√≥n.', 'warning');
            return;
        }

        const excelData = [];

        // Info y Filtros
        excelData.push({ "Campo": "Evaluaci√≥n", "Valor": evalName });
        excelData.push({ "Campo": "Grupo", "Valor": appState.config.selectedGroup });
        excelData.push({ "Campo": "Semestre", "Valor": appState.config.semester });
        excelData.push({ "Campo": "Fecha", "Valor": utils.formatDate(appState.config.dates[evalName]) });
        excelData.push({ "Campo": "Peso (%)", "Valor": appState.config.weights[evalName] });
        excelData.push({ "Campo": "Filtro Competencia", "Valor": competenceFilter });
        excelData.push({});

        // Estad√≠sticas
        excelData.push({ "Campo": "--- ESTAD√çSTICAS ---" });
        const grades = evalData.map(item => item.grade);
        const sum = grades.reduce((acc, grade) => acc + grade, 0);
        const avg = sum / grades.length;
        const min = Math.min(...grades);
        const max = Math.max(...grades);
        const stdDev = Math.sqrt(grades.map(g => Math.pow(g - avg, 2)).reduce((a, b) => a + b, 0) / grades.length);
        const passingGrade = appState.config.passingGrade;
        const studentsAtRisk = grades.filter(g => g < passingGrade).length;
        const weight = (parseFloat(appState.config.weights[evalName]) || 0) / 100;
        const currentContribution = avg * weight;
        const maxContribution = 5 * weight; // Asumiendo nota m√°xima 5

        excelData.push({ "Estad√≠stica": "Estudiantes Evaluados", "Valor": evalData.length });
        excelData.push({ "Estad√≠stica": "Promedio", "Valor": utils.formatNumber(avg) });
        excelData.push({ "Estad√≠stica": "Nota M√≠nima", "Valor": utils.formatNumber(min) });
        excelData.push({ "Estad√≠stica": "Nota M√°xima", "Valor": utils.formatNumber(max) });
        excelData.push({ "Estad√≠stica": "Desv. Est√°ndar", "Valor": utils.formatNumber(stdDev) });
        excelData.push({ "Estad√≠stica": `Estudiantes < ${passingGrade}`, "Valor": studentsAtRisk });
        excelData.push({ "Estad√≠stica": "Contribuci√≥n Actual", "Valor": `${utils.formatNumber(currentContribution)} / ${utils.formatNumber(maxContribution)}` });
        excelData.push({});

        // Competencias Evaluadas (filtradas)
        excelData.push({ "Campo": "--- COMPETENCIAS EVALUADAS ---" });
        excelData.push({ "Competencia": "Competencia", "Promedio": "Promedio", "Tasa Aprob. (%)": "Tasa Aprob. (%)", "Evaluados": "Evaluados" });
        const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
        const competencesToExport = competenceValue.length > 0 ? evalCompetences.filter(c => competenceValue.includes(c)) : evalCompetences;
        const compPerformance = utils.calculateEvaluationCompetencePerformance(students, evalName);

        competencesToExport.forEach(comp => {
            const perf = compPerformance[comp];
            if (perf && perf.totalStudents > 0) {
                const passRate = (perf.passStudents / perf.totalStudents) * 100;
                excelData.push({
                    "Competencia": comp,
                    "Promedio": utils.formatNumber(perf.average),
                    "Tasa Aprob. (%)": utils.formatNumber(passRate),
                    "Evaluados": perf.totalStudents
                });
                // Opcional: Indicadores
                const indicators = appState.processedData.indicators[comp] || [];
                 if (indicators.length > 0) {
                     excelData.push({ "Competencia": "", "Promedio": "Indicadores:", "Tasa Aprob. (%)": indicators.join('; ') });
                 }
            } else if (perf) {
                 excelData.push({ "Competencia": comp, "Promedio": "Sin datos", "Tasa Aprob. (%)": "N/A", "Evaluados": 0 });
            }
        });
        excelData.push({});

        // Lista de Calificaciones
        excelData.push({ "Campo": "--- CALIFICACIONES ---" });
        excelData.push({ "Estudiante": "Estudiante", "Calificaci√≥n": "Calificaci√≥n" });
        evalData.sort((a, b) => (a.name || '').localeCompare(b.name || '')).forEach(item => {
            excelData.push({
                "Estudiante": item.name,
                "Calificaci√≥n": utils.formatNumber(item.grade)
            });
        });

        const filename = `reporte_evaluacion_${evalName.replace(/\s+/g, '_')}.xlsx`;
        utils.exportToExcel(excelData, filename);
    },

    // Imprimir reporte de evaluaci√≥n
    printEvaluationReport: () => {
        const evalName = appState.filters.evaluation.selectedEval;
        if (!evalName) {
            utils.showMessage('Debe seleccionar una evaluaci√≥n.', 'error');
            return;
        }
        const competenceFilter = appState.filters.evaluation.competence;
        const competenceValue = competenceFilter !== 'all' ? [competenceFilter] : [];

        // Generar contenido HTML para imprimir
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>Reporte de Evaluaci√≥n - ${evalName}</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceFilter}
                </div>
            </div>
        `;
        reportContent += generateEvaluationStatsHtml(evalName, competenceValue);
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Distribuci√≥n de Calificaciones</h3>`;
        if (appState.charts.evaluationChart) {
            try { reportContent += `<img src="${appState.charts.evaluationChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `<div style="margin: 20px 0; page-break-before: auto;"><h3>Rendimiento por Competencia (en esta Eval)</h3>`;
        if (appState.charts.evalCompetenceChart) {
            try { reportContent += `<img src="${appState.charts.evalCompetenceChart.toBase64Image()}" style="max-width:100%; height:auto;">`; } catch (e) { console.error(e); }
        }
        reportContent += `</div>`;
        reportContent += `</div>`;

        utils.printContent(reportContent);
    },

    // Vista previa de la l√≠nea de tiempo
    previewTimelineReport: () => {
        const studentValue = appState.filters.timeline.student;
        const competenceValue = appState.filters.timeline.competence;
        let studentName = "Rendimiento grupal";
        if (studentValue !== 'group') {
            const student = appState.processedData.students.find(s => s.id === studentValue);
            if (student) studentName = student.Nombre;
        }

        // Generar contenido HTML para la vista previa
        let reportContent = `<div style="padding: 20px; background: white; border-radius: 5px;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>L√≠nea de Tiempo de Evaluaciones</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <p>Vista: ${studentName}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceValue}
                </div>
            </div>
            <div class="timeline-container">
                <div class="timeline">
                    ${generateTimelineHtml(studentValue, competenceValue)}
                </div>
            </div>
        `;
        reportContent += `</div>`;

        utils.showPreview(
            'Vista Previa - L√≠nea de Tiempo',
            reportContent,
            'pdf',
            `linea_tiempo_${studentValue === 'group' ? 'grupo' : 'estudiante_' + studentName.replace(/\s+/g, '_')}.pdf`
        );
    },

    // Exportar l√≠nea de tiempo a PDF
    exportTimelinePdf: () => {
        const studentValue = appState.filters.timeline.student;
        const competenceValue = appState.filters.timeline.competence;
        let studentName = "Rendimiento grupal";
        if (studentValue !== 'group') {
            const student = appState.processedData.students.find(s => s.id === studentValue);
            if (student) studentName = student.Nombre;
        }

        // Generar contenido HTML para PDF
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>L√≠nea de Tiempo de Evaluaciones</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <p>Vista: ${studentName}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceValue}
                </div>
            </div>
            <div class="timeline-container">
                <div class="timeline">
                    ${generateTimelineHtml(studentValue, competenceValue)}
                </div>
            </div>
        `;
        reportContent += `</div>`;

        const filename = `linea_tiempo_${studentValue === 'group' ? 'grupo' : 'estudiante_' + studentName.replace(/\s+/g, '_')}.pdf`;
        utils.exportToPdf(reportContent, filename);
    },

    // Imprimir l√≠nea de tiempo
    printTimelineReport: () => {
        const studentValue = appState.filters.timeline.student;
        const competenceValue = appState.filters.timeline.competence;
        let studentName = "Rendimiento grupal";
        if (studentValue !== 'group') {
            const student = appState.processedData.students.find(s => s.id === studentValue);
            if (student) studentName = student.Nombre;
        }

        // Generar contenido HTML para imprimir
        let reportContent = `<div style="padding: 10mm; width: 190mm;">`;
        reportContent += `
            <div style="margin-bottom: 20px;">
                <h2>L√≠nea de Tiempo de Evaluaciones</h2>
                <p>Grupo: ${appState.config.selectedGroup} | Semestre: ${appState.config.semester}</p>
                <p>Vista: ${studentName}</p>
                <div style="margin-top: 10px; font-size: 0.9em;">
                    <strong>Filtros:</strong> Competencia: ${competenceValue}
                </div>
            </div>
            <div class="timeline-container">
                <div class="timeline">
                    ${generateTimelineHtml(studentValue, competenceValue)}
                </div>
            </div>
        `;
        reportContent += `</div>`;

        utils.printContent(reportContent);
    },

    // Cerrar previsualizaci√≥n
    closePreview: () => {
        utils.closePreview();
    },

    // Confirmar exportaci√≥n desde previsualizaci√≥n
    confirmExport: () => {
        if (!appState.exportData.type || !appState.exportData.filename) {
            utils.closePreview();
            return;
        }

        // Re-llamar a la funci√≥n de exportaci√≥n espec√≠fica basada en el tipo y nombre de archivo
        const filename = appState.exportData.filename;
        const exportType = appState.exportData.type;

        if (exportType === 'pdf') {
            if (filename.includes('reporte_') && !filename.includes('grupal') && !filename.includes('evaluacion')) {
                eventHandlers.exportIndividualPdf();
            } else if (filename.includes('grupal')) {
                eventHandlers.exportGroupPdf();
            } else if (filename.includes('evaluacion')) {
                eventHandlers.exportEvaluationPdf();
            } else if (filename.includes('linea_tiempo')) {
                eventHandlers.exportTimelinePdf();
            }
        } else if (exportType === 'excel') {
             if (filename.includes('reporte_') && !filename.includes('grupal') && !filename.includes('evaluacion')) {
                eventHandlers.exportIndividualExcel();
            } else if (filename.includes('grupal')) {
                eventHandlers.exportGroupExcel();
            } else if (filename.includes('evaluacion')) {
                eventHandlers.exportEvaluationExcel();
            }
            // No hay exportaci√≥n Excel para l√≠nea de tiempo por ahora
        }

        utils.closePreview();
    }
};

// --- Funciones Auxiliares para Generar HTML ---

// Genera HTML para la tabla de notas del estudiante
function generateStudentGradesHtml(student, filterCompetences = [], dateRange = {}) {
    let html = '';
    let totalWeight = 0;
    let completedWeight = 0;
    let totalContribution = 0;

    for (const evalName in appState.config.weights) {
        // Aplicar filtros
        let includeEval = true;
        const evalCompetencesList = appState.processedData.competenceMappings[evalName] || [];
        if (filterCompetences.length > 0) {
            if (!evalCompetencesList.some(comp => filterCompetences.includes(comp))) {
                includeEval = false;
            }
        }
        if (includeEval && dateRange.start && dateRange.end) {
            const evalDateStr = appState.config.dates[evalName];
            if (evalDateStr) {
                try {
                    const evalDate = new Date(evalDateStr + 'T00:00:00');
                    const startDate = new Date(dateRange.start + 'T00:00:00');
                    const endDate = new Date(dateRange.end + 'T23:59:59');
                    if (evalDate < startDate || evalDate > endDate) {
                        includeEval = false;
                    }
                } catch (e) { includeEval = false; }
            } else { includeEval = false; }
        }

        if (includeEval) {
            const weight = parseFloat(appState.config.weights[evalName]) || 0;
            totalWeight += weight / 100;
            const gradeValue = student[evalName];
            const grade = (gradeValue !== undefined && gradeValue !== null && gradeValue !== '' && !isNaN(parseFloat(gradeValue))) ? parseFloat(gradeValue) : null;
            const contribution = grade !== null ? grade * (weight / 100) : null;
            const evalDate = appState.config.dates[evalName] || '';
            const competencesHtml = evalCompetencesList.length > 0
                ? evalCompetencesList.map(comp => `<span class="competence-tag">${comp}</span>`).join(' ')
                : '‚Äî';

            if (grade !== null) {
                completedWeight += weight / 100;
                totalContribution += contribution;
            }

            html += `
                <tr>
                    <td>${evalName}</td>
                    <td>${utils.formatDate(evalDate)}</td>
                    <td>${grade !== null ? utils.formatNumber(grade) : 'Pendiente'}</td>
                    <td>${utils.formatNumber(weight)}%</td>
                    <td>${grade !== null ? utils.formatNumber(contribution) : 'N/A'}</td>
                    <td>${competencesHtml}</td>
                </tr>
            `;
        }
    }

    const finalGrade = completedWeight > 0 ? totalContribution / completedWeight : 0;

    // Fila Total
    html += `
        <tr style="font-weight: bold; background-color: #f8f9fa;">
            <td>Total</td>
            <td></td>
            <td></td>
            <td>${utils.formatNumber(totalWeight * 100)}%</td>
            <td>${utils.formatNumber(totalContribution)}</td>
            <td></td>
        </tr>
    `;
    // Fila Nota Actual
    html += `
        <tr style="font-weight: bold; background-color: #e9ecef;">
            <td colspan="3">Nota actual (${utils.formatNumber(completedWeight * 100)}% completado)</td>
            <td colspan="3" style="text-align: right;">${utils.formatNumber(finalGrade)}</td>
        </tr>
    `;
    return html;
}

// Genera HTML para las competencias del estudiante
function generateStudentCompetencesHtml(student, filterCompetences = [], dateRange = {}) {
    let html = '';
    const studentCompetencesData = calculateStudentCompetences(student, filterCompetences, dateRange);

    if (studentCompetencesData.length === 0) {
        return '<div class="competence-item">No hay competencias para mostrar con los filtros aplicados.</div>';
    }

    studentCompetencesData.forEach(compData => {
        const achievementPercentage = compData.average !== null ? (compData.average / 5) * 100 : 0; // Asumiendo nota m√°x 5
        let mensaje = '';
        if (compData.average !== null) {
            if (compData.average >= appState.config.passingGrade) {
                mensaje = `<div style='color:var(--success-color); margin-top: 5px; font-size: 0.9em;'>¬°Buen desempe√±o!</div>`;
            } else {
                mensaje = `<div style='color:var(--warning-color); margin-top: 5px; font-size: 0.9em;'>Necesita mejorar.</div>`;
                // Podr√≠as a√±adir recomendaciones gen√©ricas o espec√≠ficas si las tuvieras
            }
        }

        html += `
            <div class="competence-item">
                <div><strong>${compData.name}</strong>${compData.average !== null ? ` - ${utils.formatNumber(compData.average)}` : ' - Sin datos'}</div>
                <div class="competence-progress">
                    <div class="competence-progress-bar" style="width: ${achievementPercentage}%"></div>
                </div>
                ${mensaje}
        `;

        // Indicadores
        const indicators = appState.processedData.indicators[compData.name] || [];
        if (indicators.length > 0) {
            html += `<div style="margin-top: 5px; font-size: 0.85em; color: #555;"><em>Indicadores: ${indicators.join('; ')}</em></div>`;
        }

        // Evaluaciones relacionadas
        if (compData.relatedEvals.length > 0) {
            html += `
                <div style="margin-top: 8px; font-size: 0.85em;">
                    <em>Evaluaciones:</em>
                    <div class="competence-list">${compData.relatedEvals.map(ev => `<span class="competence-tag">${ev}</span>`).join(' ')}</div>
                </div>
            `;
        }
        html += `</div>`;
    });
    return html;
}

// Genera HTML para la predicci√≥n del estudiante
function generatePredictionHtml(student, filterCompetences = []) {
    const prediction = utils.predictRequiredGrade(student, filterCompetences);
    let html = `<div class="prediction-message">${prediction.message}</div>`;

    if (prediction.possible && prediction.requiredGrade > 0) {
        html += prediction.evaluations.map(evalName => {
            const evalDate = appState.config.dates[evalName] ? ` (${utils.formatDate(appState.config.dates[evalName])})` : '';
            // Mostrar la nota promedio requerida, no individualmente por ahora
            // return `<div class="prediction-value">${evalName}${evalDate}: ${utils.formatNumber(prediction.requiredGrade)}</div>`;
            return `<span class="competence-tag">${evalName}${evalDate}</span>`;
        }).join(' ');
         html += `<div class="prediction-note" style="margin-top: 10px;">Promedio necesario en estas evaluaciones: <strong>${utils.formatNumber(prediction.requiredGrade)}</strong></div>`;
         html += `<div class="prediction-note">Nota final proyectada si se obtiene: <strong>${utils.formatNumber(appState.config.passingGrade)}</strong></div>`;

    } else if (prediction.possible && prediction.requiredGrade <= 0) {
        // Ya aprob√≥, no se muestra lista de evaluaciones
    }
    return html;
}

// Calcula los datos de competencias para un estudiante (usado por generateStudentCompetencesHtml y exportIndividualExcel)
function calculateStudentCompetences(student, filterCompetences = [], dateRange = {}) {
    const results = [];
    let competencesToCalculate = utils.getUniqueCompetences();

    // Filtrar por las competencias seleccionadas si aplica
    if (filterCompetences.length > 0) {
        competencesToCalculate = competencesToCalculate.filter(comp => filterCompetences.includes(comp));
    }

    competencesToCalculate.forEach(compName => {
        const relatedEvals = [];
        let studentCompSum = 0;
        let studentEvalCount = 0;

        for (const evalKey in appState.processedData.competenceMappings) {
            const evalCompetences = appState.processedData.competenceMappings[evalKey] || [];
            if (evalCompetences.includes(compName)) {
                // Aplicar filtro de fecha
                let includeEval = true;
                if (dateRange.start && dateRange.end) {
                    const evalDateStr = appState.config.dates[evalKey];
                    if (evalDateStr) {
                        try {
                            const evalDate = new Date(evalDateStr + 'T00:00:00');
                            const startDate = new Date(dateRange.start + 'T00:00:00');
                            const endDate = new Date(dateRange.end + 'T23:59:59');
                            if (evalDate < startDate || evalDate > endDate) {
                                includeEval = false;
                            }
                        } catch (e) { includeEval = false; }
                    } else { includeEval = false; }
                }

                if (includeEval) {
                    relatedEvals.push(evalKey);
                    const gradeValue = student[evalKey];
                    if (gradeValue !== undefined && gradeValue !== null && gradeValue !== '') {
                        const grade = parseFloat(gradeValue);
                        if (!isNaN(grade)) {
                            studentCompSum += grade;
                            studentEvalCount++;
                        }
                    }
                }
            }
        }

        // Solo a√±adir si hay evaluaciones relacionadas (incluso si no hay nota)
        if (relatedEvals.length > 0) {
             results.push({
                name: compName,
                average: studentEvalCount > 0 ? studentCompSum / studentEvalCount : null,
                relatedEvals: relatedEvals
            });
        }
    });

    // Ordenar por nombre de competencia
    results.sort((a, b) => a.name.localeCompare(b.name));
    return results;
}


// Genera HTML para las estad√≠sticas grupales
function generateGroupStatsHtml(students, filterCompetences = [], dateRange = {}) {
    const stats = utils.calculateGroupStats(students, filterCompetences, dateRange);
    let html = '<div class="group-report-container">'; // Usar grid layout

    if (!stats || stats.evaluatedStudents === 0) {
        html += `<div class="stat-card" style="grid-column: 1 / -1;"><p>No hay datos suficientes para calcular estad√≠sticas con los filtros aplicados.</p></div>`;
    } else {
        const passingGrade = appState.config.passingGrade || 3.0;
        const passCount = stats.evaluatedStudents - stats.studentsAtRisk;
        const passRate = stats.evaluatedStudents > 0 ? (passCount / stats.evaluatedStudents) * 100 : 0;
        const riskRate = stats.evaluatedStudents > 0 ? (stats.studentsAtRisk / stats.evaluatedStudents) * 100 : 0;

        html += `
            <div class="stat-card">
                <h3>Estudiantes (Filtrados)</h3>
                <div class="stat-value">${students.length}</div>
                <div class="stat-description">Total en la selecci√≥n actual</div>
            </div>
            <div class="stat-card">
                <h3>Evaluados</h3>
                <div class="stat-value">${stats.evaluatedStudents}</div>
                <div class="stat-description">Con al menos una nota v√°lida</div>
            </div>
            <div class="stat-card">
                <h3>Promedio</h3>
                <div class="stat-value">${utils.formatNumber(stats.average)}</div>
            </div>
            <div class="stat-card">
                <h3>Nota M√≠n.</h3>
                <div class="stat-value">${utils.formatNumber(stats.min)}</div>
            </div>
            <div class="stat-card">
                <h3>Nota M√°x.</h3>
                <div class="stat-value">${utils.formatNumber(stats.max)}</div>
            </div>
             <div class="stat-card">
                <h3>Desv. Est√°ndar</h3>
                <div class="stat-value">${utils.formatNumber(stats.stdDev)}</div>
            </div>
            <div class="stat-card" style="background-color: rgba(46, 204, 113, 0.1);">
                <h3>Aprobados (‚â• ${passingGrade})</h3>
                <div class="stat-value" style="color: var(--success-color);">${passCount}</div>
                <div class="stat-description">${utils.formatNumber(passRate)}% de los evaluados</div>
            </div>
            <div class="stat-card" style="background-color: rgba(231, 76, 60, 0.1);">
                <h3>En Riesgo (< ${passingGrade})</h3>
                <div class="stat-value" style="color: var(--warning-color);">${stats.studentsAtRisk}</div>
                <div class="stat-description">${utils.formatNumber(riskRate)}% de los evaluados</div>
            </div>
        `;
    }
    html += '</div>'; // Cerrar group-report-container
    return html;
}

// Genera HTML para la lista de estudiantes en riesgo
function generateRiskStudentsHtml(students, filterCompetences = [], dateRange = {}) {
    const passingGrade = appState.config.passingGrade || 3.0;
    const riskStudents = students.map(student => ({
        name: student.Nombre,
        grade: utils.calculateFinalGrade(student, filterCompetences, dateRange)
    })).filter(s => s.grade < passingGrade);

    riskStudents.sort((a, b) => a.grade - b.grade); // Ordenar por nota m√°s baja

    if (riskStudents.length === 0) {
        return '<div class="risk-student-item">No hay estudiantes en riesgo con los filtros aplicados.</div>';
    }

    return riskStudents.map(student => `
        <div class="risk-student-item">
            <span class="name">${student.name}</span>
            <span class="grade">${utils.formatNumber(student.grade)}</span>
        </div>
    `).join('');
}

// Genera HTML para las estad√≠sticas de evaluaci√≥n
function generateEvaluationStatsHtml(evalName, filterCompetences = []) {
    const students = appState.processedData.students || [];
    const evalData = students.map(student => ({
        id: student.id,
        name: student.Nombre,
        grade: student[evalName] !== undefined && student[evalName] !== null && student[evalName] !== '' ? parseFloat(student[evalName]) : null
    })).filter(item => item.grade !== null);

    let html = '';

    if (evalData.length === 0) {
        return '<div class="message error">No hay datos de calificaci√≥n para esta evaluaci√≥n.</div>';
    }

    const grades = evalData.map(item => item.grade);
    const sum = grades.reduce((acc, grade) => acc + grade, 0);
    const avg = sum / grades.length;
    const min = Math.min(...grades);
    const max = Math.max(...grades);
    const stdDev = Math.sqrt(grades.map(g => Math.pow(g - avg, 2)).reduce((a, b) => a + b, 0) / grades.length);
    const passingGrade = appState.config.passingGrade;
    const studentsAtRisk = grades.filter(g => g < passingGrade).length;
    const weight = (parseFloat(appState.config.weights[evalName]) || 0) / 100;
    const currentContribution = avg * weight;
    const maxContribution = 5 * weight; // Asumiendo nota m√°xima 5
    const evalDate = appState.config.dates[evalName] || 'No asignada';
    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
    const competencesToShow = filterCompetences.length > 0 ? evalCompetences.filter(c => filterCompetences.includes(c)) : evalCompetences;

    html += `
        <div class="report-section">
            <h3>Estad√≠sticas de ${evalName}</h3>
            <div style="margin-bottom: 10px; color: var(--dark-gray);">Fecha: ${utils.formatDate(evalDate)}</div>
            <div class="group-report-container">
                <div class="stat-card"><h3>Evaluados</h3><div class="stat-value">${evalData.length}</div></div>
                <div class="stat-card"><h3>Promedio</h3><div class="stat-value">${utils.formatNumber(avg)}</div></div>
                <div class="stat-card"><h3>M√≠nima</h3><div class="stat-value">${utils.formatNumber(min)}</div></div>
                <div class="stat-card"><h3>M√°xima</h3><div class="stat-value">${utils.formatNumber(max)}</div></div>
                <div class="stat-card"><h3>Desv. Est.</h3><div class="stat-value">${utils.formatNumber(stdDev)}</div></div>
                <div class="stat-card"><h3>En Riesgo (<${passingGrade})</h3><div class="stat-value">${studentsAtRisk}</div></div>
                <div class="stat-card"><h3>Peso</h3><div class="stat-value">${utils.formatNumber(weight * 100)}%</div></div>
                <div class="stat-card"><h3>Contribuci√≥n</h3><div class="stat-value">${utils.formatNumber(currentContribution)} / ${utils.formatNumber(maxContribution)}</div></div>
            </div>
        </div>
        <div class="report-section">
            <h3>Competencias Evaluadas</h3>
            <div class="competence-container">
    `;
    if (competencesToShow.length === 0) {
        html += `<div class="competence-item">No hay competencias ${filterCompetences.length > 0 ? 'filtradas' : ''} asociadas.</div>`;
    } else {
        competencesToShow.forEach(compName => {
            const indicators = appState.processedData.indicators[compName] || [];
            html += `<div class="competence-item"><div><strong>${compName}</strong></div>`;
            if (indicators.length > 0) {
                html += `<div style="font-size: 0.85em; color: #555;"><em>Indicadores: ${indicators.join('; ')}</em></div>`;
            }
            html += `</div>`;
        });
    }
    html += `</div></div>`;

    // Lista de calificaciones
    html += `
        <div class="report-section">
            <h3>Listado de Calificaciones</h3>
            <table class="grades-table" style="font-size: 0.9em;">
                <thead><tr><th>Estudiante</th><th>Calificaci√≥n</th></tr></thead>
                <tbody>
    `;
    evalData.sort((a, b) => (a.name || '').localeCompare(b.name || '')).forEach(item => {
        html += `<tr><td>${item.name}</td><td>${utils.formatNumber(item.grade)}</td></tr>`;
    });
    html += `</tbody></table></div>`;

    return html;
}

// Genera HTML para la l√≠nea de tiempo
function generateTimelineHtml(studentId, competenceFilter = 'all') {
    let html = '';
    const evaluationsWithDates = [];

    for (const evalName in appState.config.dates) {
        const date = appState.config.dates[evalName];
        if (!date) continue;

        let includeEval = true;
        const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
        if (competenceFilter !== 'all') {
            if (!evalCompetences.includes(competenceFilter)) {
                includeEval = false;
            }
        }

        if (includeEval) {
            evaluationsWithDates.push({
                name: evalName,
                date: new Date(date + 'T00:00:00'), // Asegurar parseo correcto
                weight: appState.config.weights[evalName] || 0,
                competences: evalCompetences
            });
        }
    }

    evaluationsWithDates.sort((a, b) => a.date - b.date);

    if (evaluationsWithDates.length === 0) {
        return '<div style="text-align: center; padding: 20px;">No hay evaluaciones con fechas para mostrar con los filtros aplicados.</div>';
    }

    let studentData = null;
    if (studentId !== 'group') {
        studentData = appState.processedData.students.find(s => s.id === studentId);
    }

    evaluationsWithDates.forEach((evalItem) => {
        let gradeInfo = '';
        if (studentData) {
            const gradeValue = studentData[evalItem.name];
            const grade = (gradeValue !== undefined && gradeValue !== null && gradeValue !== '' && !isNaN(parseFloat(gradeValue))) ? parseFloat(gradeValue) : null;
            gradeInfo = `<div><strong>Nota:</strong> ${grade !== null ? utils.formatNumber(grade) : 'Pendiente'}</div>`;
        } else {
            // Calcular promedio grupal
            const grades = appState.processedData.students.map(s => s[evalItem.name])
                .filter(g => g !== undefined && g !== null && g !== '')
                .map(g => parseFloat(g))
                .filter(g => !isNaN(g));
            if (grades.length > 0) {
                const avg = grades.reduce((sum, g) => sum + g, 0) / grades.length;
                gradeInfo = `<div><strong>Promedio Grupal:</strong> ${utils.formatNumber(avg)} (${grades.length} evaluados)</div>`;
            } else {
                gradeInfo = `<div><strong>Promedio Grupal:</strong> No disponible</div>`;
            }
        }

        let competencesHtml = '';
        if (evalItem.competences.length > 0) {
            competencesHtml = `
                <div style="margin-top: 5px; font-size: 0.9em;">
                    <strong>Competencias:</strong>
                    <div class="competence-list">${evalItem.competences.map(comp => `<span class="competence-tag">${comp}</span>`).join(' ')}</div>
                </div>`;
        }

        html += `
            <div class="timeline-item">
                <div class="timeline-content">
                    <h3>${evalItem.name}</h3>
                    <div class="timeline-date">${utils.formatDate(evalItem.date)}</div>
                    <div><strong>Peso:</strong> ${evalItem.weight}%</div>
                    ${gradeInfo}
                    ${competencesHtml}
                </div>
            </div>
        `;
    });

    return html;
}


// --- FIN Funciones Auxiliares para Generar HTML ---


// Funci√≥n adaptada para leer archivos Excel y CSV
async function readExcelOrCsvFile(file) {
    return new Promise((resolve, reject) => {
        if (typeof XLSX === 'undefined') {
            return reject(new Error('La librer√≠a XLSX no est√° disponible.'));
        }
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = new Uint8Array(e.target.result);
                const fileExtension = file.name.split('.').pop().toLowerCase();

                if (fileExtension === 'csv') {
                    // Detectar codificaci√≥n (simple heuristic)
                    let csvText;
                    try {
                        csvText = new TextDecoder('utf-8').decode(data);
                        // Simple check for UTF-8 validity (might fail for complex cases)
                        if (csvText.includes('')) throw new Error('Possible encoding issue');
                    } catch (utfError) {
                        try {
                             console.warn("UTF-8 decoding failed, trying latin1...");
                             csvText = new TextDecoder('iso-8859-1').decode(data); // Try latin1 as fallback
                        } catch (latinError) {
                             return reject(new Error('No se pudo decodificar el archivo CSV. Pruebe UTF-8 o ISO-8859-1.'));
                        }
                    }

                    const sheets = {};
                    const sheetName = file.name.replace(/\.[^/.]+$/, ""); // Nombre archivo sin extensi√≥n
                    const jsonData = csvToJson(csvText); // Usar funci√≥n mejorada
                    if (!jsonData || jsonData.length === 0) {
                        return reject(new Error('El archivo CSV est√° vac√≠o o no se pudo parsear correctamente. Verifique el delimitador (coma o punto y coma) y la codificaci√≥n.'));
                    }
                    sheets[sheetName] = jsonData;
                    resolve(sheets);
                } else if (fileExtension === 'xlsx' || fileExtension === 'xls') {
                    let workbook;
                    try {
                        workbook = XLSX.read(data, {
                            type: 'array',
                            cellDates: true, // Intentar parsear fechas
                            cellNF: false, // Evitar formatos num√©ricos complejos
                            cellStyles: false, // Ignorar estilos
                            dateNF: 'yyyy-mm-dd' // Formato preferido para fechas
                        });
                    } catch (err) {
                        console.error("Error reading Excel:", err);
                        return reject(new Error('No se pudo leer el archivo Excel. ¬øEst√° corrupto, protegido por contrase√±a o en un formato no soportado?'));
                    }
                    const sheets = {};
                    let hasData = false;
                    workbook.SheetNames.forEach(sheetName => {
                        const worksheet = workbook.Sheets[sheetName];
                        // Usar header: 1 para obtener array de arrays, luego procesar manualmente
                        // O usar sheet_to_json con raw: false para que intente convertir tipos
                        const jsonData = XLSX.utils.sheet_to_json(worksheet, {
                            raw: false, // Intentar convertir valores a tipos JS (n√∫meros, booleanos, fechas)
                            dateNF: 'yyyy-mm-dd' // Asegurar formato de fecha
                        });

                        // Limpiar datos: convertir n√∫meros string a n√∫meros float
                        const cleanedJsonData = jsonData.map(row => {
                            const newRow = {};
                            for (const key in row) {
                                let value = row[key];
                                // Intentar convertir a n√∫mero si parece n√∫mero pero es string
                                if (typeof value === 'string' && !isNaN(value) && value.trim() !== '') {
                                     // Evitar convertir IDs largos a notaci√≥n cient√≠fica
                                     if (!key.toLowerCase().includes('id') && !key.toLowerCase().includes('codigo')) {
                                        value = parseFloat(value);
                                     }
                                }
                                // Formatear fechas si son objetos Date
                                if (value instanceof Date) {
                                     value = value.toISOString().split('T')[0]; // Formato YYYY-MM-DD
                                }
                                newRow[key] = value;
                            }
                            return newRow;
                        });


                        if (cleanedJsonData && cleanedJsonData.length > 0) {
                            hasData = true;
                        }
                        sheets[sheetName] = cleanedJsonData;
                    });
                    if (!hasData) {
                        return reject(new Error('El archivo Excel parece no contener datos en ninguna hoja.'));
                    }
                    resolve(sheets);
                } else {
                    reject(new Error('Formato de archivo no soportado. Use .xlsx, .xls o .csv.'));
                }
            } catch (error) {
                console.error("Error processing file:", error);
                reject(new Error(`Error al procesar el archivo: ${error.message}`));
            }
        };
        reader.onerror = (error) => {
            console.error("Error reading file:", error);
            reject(new Error(`Error al leer el archivo: ${error.target.error?.message || 'Error desconocido'}`));
        };
        reader.readAsArrayBuffer(file);
    });
}

// Funci√≥n mejorada para convertir CSV a JSON
function csvToJson(csvText) {
    // Remover BOM si existe (com√∫n en CSV de Excel)
    if (csvText.charCodeAt(0) === 0xFEFF) {
        csvText = csvText.slice(1);
    }

    // Dividir en l√≠neas, manejando saltos de l√≠nea Windows y Unix
    const lines = csvText.split(/\r\n|\n/).filter(line => line.trim() !== ''); // Ignorar l√≠neas vac√≠as
    if (lines.length < 2) return []; // Necesita encabezados y al menos una l√≠nea de datos

    // Determinar delimitador (coma o punto y coma) basado en la primera l√≠nea (encabezados)
    const delimiter = lines[0].includes(';') ? ';' : ',';

    // Parsear encabezados: quitar comillas y espacios extra
    const headers = lines[0].split(delimiter).map(header => header.trim().replace(/^["']|["']$/g, '').trim());

    const result = [];
    // Procesar l√≠neas de datos
    for (let i = 1; i < lines.length; i++) {
        const obj = {};
        // Split robusto que maneja comillas (simple, no soporta comillas escapadas dentro de campos)
        const currentLineValues = lines[i].split(delimiter).map(val => val.trim().replace(/^["']|["']$/g, '').trim());

        // Si el n√∫mero de valores no coincide con encabezados, puede ser un error de parseo o l√≠nea corrupta
        if (currentLineValues.length !== headers.length) {
             console.warn(`L√≠nea ${i+1} ignorada: n√∫mero de campos (${currentLineValues.length}) no coincide con encabezados (${headers.length}). L√≠nea: "${lines[i]}"`);
             continue; // Saltar esta l√≠nea
        }

        for (let j = 0; j < headers.length; j++) {
            const header = headers[j];
            let value = currentLineValues[j];

            // Intentar convertir a n√∫mero si es posible (evitando IDs)
            if (!isNaN(value) && value !== '' && !header.toLowerCase().includes('id') && !header.toLowerCase().includes('codigo')) {
                value = parseFloat(value);
            }
            // Podr√≠amos a√±adir intento de conversi√≥n de fecha si es necesario
            // else if (/^\d{4}-\d{2}-\d{2}/.test(value)) { ... }

            obj[header] = value;
        }
        result.push(obj);
    }
    return result;
}


// Procesar datos despu√©s de cargar archivos y configuraci√≥n
function processData() {
    const selectedGroup = appState.config.selectedGroup;

    if (!selectedGroup || !appState.studentsData || !appState.studentsData[selectedGroup]) {
        throw new Error('Grupo no v√°lido o datos de estudiantes no cargados.');
    }

    // Obtener campos seleccionados y de ID
    const selectedFields = appState.config.selectedFields || [];
    const studentIdFields = appState.config.studentIdFields || [];
    const gradeFields = selectedFields.filter(field => !studentIdFields.includes(field)); // Campos de notas

    if (selectedFields.length === 0) {
        throw new Error('No hay campos seleccionados para procesar.');
    }
    if (studentIdFields.length === 0) {
        console.warn("No se seleccion√≥ un campo de ID de estudiante. Se usar√°n IDs gen√©ricos.");
    }
     if (gradeFields.length === 0) {
        throw new Error('No se seleccionaron campos de evaluaci√≥n/nota.');
    }

    // Procesar estudiantes
    const allStudents = appState.studentsData[selectedGroup];
    const students = allStudents.map((student, index) => {
        const processedStudent = { id: `student-${index}` }; // ID interno √∫nico

        // Copiar campos seleccionados, intentando convertir notas a n√∫mero
        selectedFields.forEach(field => {
            let value = student[field];
            // Si es un campo de nota y es string, intentar convertir a float
            if (gradeFields.includes(field) && typeof value === 'string' && !isNaN(value) && value.trim() !== '') {
                value = parseFloat(value);
            }
            // Si es undefined o null, mantenerlo as√≠ (no convertir a 0)
            processedStudent[field] = (value === undefined || value === null) ? value : value;
        });

        // Establecer nombre del estudiante (concatenar si hay varios campos ID)
        processedStudent.Nombre = studentIdFields
            .map(field => student[field] || '')
            .join(' ') // Unir con espacio
            .trim() || `Estudiante ${index + 1}`; // Nombre gen√©rico si no hay ID

        return processedStudent;
    });

    appState.processedData.students = students;

    // Procesar competencias (de todas las hojas del archivo de competencias)
    const allCompetencesData = [];
    if (appState.competencesData) {
        Object.values(appState.competencesData).forEach(sheetData => {
            if (Array.isArray(sheetData)) {
                const processedSheet = sheetData.map(item => {
                    const normalizedItem = {};
                    let competenciaKey = null;
                    let indicadorKey = null;
                    // Buscar claves que contengan 'competen' o 'indica' (insensible a may√∫sculas)
                    for (const key in item) {
                        const lowerKey = key.toLowerCase();
                        if (lowerKey.includes('competen')) competenciaKey = key;
                        if (lowerKey.includes('indica')) indicadorKey = key;
                    }
                    // Asignar si se encontraron
                    if (competenciaKey) normalizedItem.Competencia = item[competenciaKey];
                    if (indicadorKey) normalizedItem.Indicador = item[indicadorKey];
                    // Copiar otros campos si es necesario
                    // for (const key in item) { if (key !== competenciaKey && key !== indicadorKey) normalizedItem[key] = item[key]; }
                    return normalizedItem;
                }).filter(item => item.Competencia); // Solo incluir si tiene competencia
                allCompetencesData.push(...processedSheet);
            }
        });
    }
    appState.processedData.competences = allCompetencesData;

    // Obtener evaluaciones (son los gradeFields)
    appState.processedData.evaluations = gradeFields;

    // Procesar indicadores (agrupar por competencia)
    const indicators = {};
    allCompetencesData.forEach(comp => {
        if (comp.Competencia) {
            if (!indicators[comp.Competencia]) {
                indicators[comp.Competencia] = new Set(); // Usar Set para evitar duplicados
            }
            if (comp.Indicador) {
                indicators[comp.Competencia].add(comp.Indicador);
            }
        }
    });
    // Convertir Sets a Arrays
    appState.processedData.indicators = Object.fromEntries(
        Object.entries(indicators).map(([key, value]) => [key, Array.from(value)])
    );

    // Inicializar mapeo de competencias si no existe o si las evaluaciones cambiaron
    const currentEvalKeys = new Set(gradeFields);
    const mappedEvalKeys = new Set(Object.keys(appState.processedData.competenceMappings || {}));
    let resetMapping = !appState.processedData.competenceMappings || currentEvalKeys.size !== mappedEvalKeys.size ||
                       ![...currentEvalKeys].every(key => mappedEvalKeys.has(key));

    if (resetMapping) {
        console.log("Evaluaciones cambiaron, reiniciando mapeo de competencias.");
        const competenceMappings = {};
        gradeFields.forEach(evalName => {
            competenceMappings[evalName] = []; // Inicializar vac√≠o
        });
        appState.processedData.competenceMappings = competenceMappings;
    }

    // --- Actualizar UI con datos procesados ---

    // Cargar lista de estudiantes en UI (Reporte Individual y L√≠nea de Tiempo)
    const studentOptionsHtml = students.map(s => `<option value="${s.id}">${s.Nombre}</option>`).join('');
    if (elements.timelineStudentSelect) {
        elements.timelineStudentSelect.innerHTML = '<option value="group">Rendimiento grupal</option>' + studentOptionsHtml;
        elements.timelineStudentSelect.value = appState.filters.timeline.student || 'group'; // Restaurar selecci√≥n
    }
    if (elements.studentsList) { // Para reporte individual
        elements.studentsList.innerHTML = students.map(s =>
            `<div class="student-item" data-id="${s.id}">${s.Nombre}</div>`
        ).join('');
        // Re-a√±adir listeners a la lista
        elements.studentsList.querySelectorAll('.student-item').forEach(item => {
            item.addEventListener('click', () => {
                const studentId = item.dataset.id;
                const student = appState.processedData.students.find(s => s.id === studentId);
                if (student) eventHandlers.selectStudent(student);
            });
        });
         // Limpiar b√∫squeda y selecci√≥n previa
        if (elements.studentSearch) elements.studentSearch.value = '';
        appState.currentStudent = null;
        if (elements.studentName) elements.studentName.textContent = 'Seleccione un estudiante';
        if (elements.studentInfo) elements.studentInfo.textContent = '';
        if (elements.gradesTable?.querySelector('tbody')) elements.gradesTable.querySelector('tbody').innerHTML = '';
        if (elements.competenceContainer) elements.competenceContainer.innerHTML = '';
        if (elements.predictionResults) elements.predictionResults.innerHTML = '';
    }


    // Cargar lista de competencias √∫nicas para filtros
    const uniqueCompetences = utils.getUniqueCompetences();
    const competenceOptionsHtml = uniqueCompetences.map(comp => `<option value="${comp}">${comp}</option>`).join('');
    if (elements.competenceFilter) { // Filtro grupal
        elements.competenceFilter.innerHTML = '<option value="all">Todas</option>' + competenceOptionsHtml;
        elements.competenceFilter.value = appState.filters.group.competence || 'all'; // Restaurar
    }
    if (elements.evalCompetenceFilter) { // Filtro por evaluaci√≥n
        elements.evalCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>' + competenceOptionsHtml;
         elements.evalCompetenceFilter.value = appState.filters.evaluation.competence || 'all'; // Restaurar
    }
    if (elements.timelineCompetenceFilter) { // Filtro l√≠nea de tiempo
        elements.timelineCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>' + competenceOptionsHtml;
        elements.timelineCompetenceFilter.value = appState.filters.timeline.competence || 'all'; // Restaurar
    }
     // Filtro individual (selector)
    if (elements.individualCompetenceFilter) {
        const select = elements.individualCompetenceFilter.querySelector('select');
        if (select) {
            select.innerHTML = '<option value="all">Todas las competencias</option>' + competenceOptionsHtml;
            // Restaurar selecci√≥n si existe en el estado
            const currentFilter = appState.filters.individual.competences;
            select.value = currentFilter.length === 1 ? currentFilter[0] : 'all';
        } else {
             // Si no existe el select, inicializarlo (deber√≠a estar en initializeCompetenceFilters)
             initializeCompetenceFilters();
        }
    }


    // Cargar lista de evaluaciones para filtro "Reporte por Evaluaci√≥n"
    if (elements.evaluationSelect) {
        elements.evaluationSelect.innerHTML = '<option value="">Seleccione una evaluaci√≥n</option>' +
            gradeFields.map(evalName => `<option value="${evalName}">${evalName}</option>`).join('');
        elements.evaluationSelect.value = appState.filters.evaluation.selectedEval || ''; // Restaurar
    }

    // Opcional: Renderizar reporte grupal por defecto si estamos en esa pesta√±a
    if (document.getElementById('group')?.classList.contains('active')) {
        renderGroupReport(students);
    }
}


// Renderizar mapeo de competencias
function renderCompetenceMapping() {
    if (!elements.competenceMappingBody || !appState.processedData.evaluations) return;

    const selectedSheet = elements.competenceSheetSelect ? elements.competenceSheetSelect.value : '';
    // El filtro de grupo en esta pesta√±a no parece usarse, lo ignoramos por ahora.

    // Actualizar selector de hojas si es necesario
    if (elements.competenceSheetSelect && elements.competenceSheetSelect.options.length <= 1 && appState.competenceSheets.length > 0) {
         elements.competenceSheetSelect.innerHTML = '<option value="">Seleccione una hoja</option>';
         appState.competenceSheets.forEach(sheet => {
             elements.competenceSheetSelect.innerHTML += `<option value="${sheet}">${sheet}</option>`;
         });
    }

    elements.competenceMappingBody.innerHTML = ''; // Limpiar

    // Usar las evaluaciones procesadas (campos de notas)
    const evaluations = appState.processedData.evaluations || [];

    if (evaluations.length === 0) {
        elements.competenceMappingBody.innerHTML = '<div class="message info">No hay evaluaciones configuradas.</div>';
        return;
    }

    // Obtener todas las competencias √∫nicas disponibles (independiente de la hoja seleccionada por ahora)
    const uniqueCompetences = utils.getUniqueCompetences();

    evaluations.forEach(evalName => {
        const mappedCompetences = appState.processedData.competenceMappings[evalName] || [];
        const evalDate = appState.config.dates[evalName] || 'No asignada';

        const mappingItem = document.createElement('div');
        mappingItem.className = 'competence-mapping-item';
        mappingItem.innerHTML = `
            <div class="competence-mapping-title">
                <h4>${evalName}</h4>
                <div class="date-tag">
                    <span>Fecha:</span>
                    <span>${utils.formatDate(evalDate)}</span>
                </div>
            </div>
            <div class="competence-selector">
                <h5>Asociar/Desasociar Competencias:</h5>
                <div class="competence-checkbox-group" id="comp-mapping-group-${evalName}"></div>
            </div>
            <div style="margin-top: 10px;">
                <strong>Competencias asociadas actualmente:</strong>
                <div class="competence-list" style="margin-top:5px;">
                    ${mappedCompetences.length > 0
                        ? mappedCompetences.map(comp => `<span class='competence-tag'>${comp}</span>`).join('')
                        : '<em>Ninguna</em>'}
                </div>
            </div>
        `;
        elements.competenceMappingBody.appendChild(mappingItem);

        // A√±adir checkboxes para TODAS las competencias disponibles
        const competenceGroup = mappingItem.querySelector(`#comp-mapping-group-${evalName}`);
        if (competenceGroup) {
            uniqueCompetences.forEach(comp => {
                const checkboxId = `mapping-comp-${evalName}-${comp.replace(/\s+/g, '-')}`;
                const isChecked = mappedCompetences.includes(comp);
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = checkboxId;
                checkbox.className = 'comp-checkbox';
                checkbox.setAttribute('data-eval', evalName);
                checkbox.setAttribute('data-comp', comp);
                checkbox.checked = isChecked;
                // Usar el handler existente que actualiza el estado y re-renderiza
                checkbox.addEventListener('change', eventHandlers.competenceCheckboxChange);

                const label = document.createElement('label');
                label.className = 'competence-checkbox';
                label.htmlFor = checkboxId;
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(comp));

                // Mostrar indicadores como tooltip o texto peque√±o
                const indicators = appState.processedData.indicators[comp] || [];
                if (indicators.length > 0) {
                    label.title = `Indicadores: ${indicators.join('; ')}`; // Tooltip
                    // O a√±adir texto peque√±o:
                    // const indSpan = document.createElement('span');
                    // indSpan.style.fontSize = '11px'; indSpan.style.color = '#888'; indSpan.style.marginLeft = '4px';
                    // indSpan.textContent = `(${indicators.length} ind.)`;
                    // label.appendChild(indSpan);
                }
                competenceGroup.appendChild(label);
            });
        }
    });
}


// Inicializar filtros de competencias (ahora usa select para individual)
function initializeCompetenceFilters() {
    const uniqueCompetences = utils.getUniqueCompetences();
    const competenceOptionsHtml = uniqueCompetences.map(comp => `<option value="${comp}">${comp}</option>`).join('');

    // Filtro individual (asegurar que el select exista y est√© poblado)
    if (elements.individualCompetenceFilter) {
        let select = elements.individualCompetenceFilter.querySelector('select#competenceSelector');
        if (!select) {
            elements.individualCompetenceFilter.innerHTML = ''; // Limpiar por si hab√≠a tags
            select = document.createElement('select');
            select.id = 'competenceSelector';
            select.style.width = '100%'; // Ocupar ancho disponible
            select.addEventListener('change', eventHandlers.filterIndividualByCompetence);
            elements.individualCompetenceFilter.appendChild(select);
        }
        // Poblar o actualizar opciones
        select.innerHTML = '<option value="all">Todas las competencias</option>' + competenceOptionsHtml;
        // Restaurar selecci√≥n del estado
        const currentFilter = appState.filters.individual.competences;
        select.value = currentFilter.length === 1 ? currentFilter[0] : 'all';
    }

    // Otros filtros (grupal, evaluaci√≥n, timeline) ya se actualizan en processData
}

// Inicializar datepickers para filtros (asegurando que no se dupliquen)
function initializeDatepickers() {
    const initPicker = (element, configKey) => {
        if (!element) return;
        // Destruir instancia previa si existe
        if (appState.datepickers[configKey]) {
            appState.datepickers[configKey].destroy();
        }
        // Crear nueva instancia y guardarla
        appState.datepickers[configKey] = flatpickr(element, {
            dateFormat: "Y-m-d",
            onChange: (selectedDates, dateStr, instance) => {
                // Disparar el filtro correspondiente al cambiar la fecha
                const id = instance.element.id;
                if (id.includes('individual')) {
                    eventHandlers.filterIndividualByCompetence();
                } else if (id.includes('group')) {
                    eventHandlers.filterByPerformance();
                }
                // A√±adir m√°s si se usan datepickers en otras pesta√±as
            }
        });
         // Restaurar valor del estado si existe
         const dateRange = appState.filters[configKey.split(/(?=Start|End)/)[0].toLowerCase()]?.dateRange;
         const dateType = configKey.includes('Start') ? 'start' : 'end';
         if (dateRange && dateRange[dateType]) {
             appState.datepickers[configKey].setDate(dateRange[dateType], false);
         }

    };

    initPicker(elements.individualStartDate, 'individualStartDate');
    initPicker(elements.individualEndDate, 'individualEndDate');
    initPicker(elements.groupStartDate, 'groupStartDate');
    initPicker(elements.groupEndDate, 'groupEndDate');
    // A√±adir m√°s datepickers si los hubiera
}


// Obtener competencias activas del filtro individual (ahora usa select)
function getActiveCompetenceFilters(filterContainerId) { // filterContainerId ya no es tan relevante
    const select = document.querySelector('#individualCompetenceFilter select#competenceSelector');
    if (select && select.value !== 'all') {
        return [select.value]; // Devuelve un array con la competencia seleccionada
    }
    return []; // Devuelve array vac√≠o si es "Todas"
}


// Renderizar tabla de notas del estudiante (usando funci√≥n auxiliar HTML)
function renderStudentGrades(student, filterCompetences = [], dateRange = {}) {
    if (!elements.gradesTable) return;
    const tbody = elements.gradesTable.querySelector('tbody');
    if (!tbody) return;
    tbody.innerHTML = generateStudentGradesHtml(student, filterCompetences, dateRange);
}

// Renderizar competencias del estudiante (usando funci√≥n auxiliar HTML)
function renderStudentCompetences(student, filterCompetences = [], dateRange = {}) {
    if (!elements.competenceContainer) return;
    elements.competenceContainer.innerHTML = generateStudentCompetencesHtml(student, filterCompetences, dateRange);
}

// Renderizar predicci√≥n (usando funci√≥n auxiliar HTML)
function renderPrediction(student, filterCompetences = []) {
    if (!elements.predictionResults) return;
    elements.predictionResults.innerHTML = generatePredictionHtml(student, filterCompetences);
}


// Renderizar reporte grupal (ahora usa funciones auxiliares HTML y renderiza gr√°ficos)
function renderGroupReport(students, filterCompetences = [], dateRange = {}) {
    if (!elements.groupStatsContainer || !elements.riskStudentsList) return;

    // 1. Renderizar Estad√≠sticas
    elements.groupStatsContainer.innerHTML = generateGroupStatsHtml(students, filterCompetences, dateRange);

    // 2. Renderizar Lista de Estudiantes en Riesgo
    elements.riskStudentsList.innerHTML = generateRiskStudentsHtml(students, filterCompetences, dateRange);

    // 3. Renderizar Gr√°fico de Distribuci√≥n de Notas (basado en estudiantes filtrados)
    renderGroupChart(students, filterCompetences, dateRange);

    // 4. Renderizar Gr√°fico de Rendimiento por Competencia
    //    (calculado sobre TODOS los estudiantes, pero aplicando filtro de fecha)
    const allStudents = appState.processedData.students || [];
    const compPerformance = utils.calculateCompetencePerformance(allStudents, [], dateRange);
    renderCompetenceChart(allStudents, compPerformance, filterCompetences); // Pasar filtro de competencia para visualizaci√≥n
}


// Renderizar gr√°fico de grupo (distribuci√≥n de notas)
function renderGroupChart(students, filterCompetences = [], dateRange = {}) {
    if (!elements.groupChart) return;
    const ctx = elements.groupChart.getContext('2d');

    // Destruir gr√°fico anterior
    if (appState.charts.groupChart) {
        appState.charts.groupChart.destroy();
    }

    // Calcular notas finales de los estudiantes filtrados
    const grades = students.map(student =>
        utils.calculateFinalGrade(student, filterCompetences, dateRange)
    ).filter(grade => !isNaN(grade)); // Asegurar que sean n√∫meros

    if (grades.length === 0) {
         ctx.clearRect(0, 0, elements.groupChart.width, elements.groupChart.height); // Limpiar canvas
         ctx.font = "14px Segoe UI";
         ctx.textAlign = "center";
         ctx.fillText("No hay datos para mostrar el gr√°fico.", elements.groupChart.width / 2, 50);
        return;
    }

    // Definir rangos e intervalos
    const ranges = [
        { label: '0.0-0.9', min: 0.0, max: 0.99 },
        { label: '1.0-1.9', min: 1.0, max: 1.99 },
        { label: '2.0-2.9', min: 2.0, max: 2.99 },
        { label: '3.0-3.9', min: 3.0, max: 3.99 },
        { label: '4.0-5.0', min: 4.0, max: 5.0 }
    ];
    const passingGrade = appState.config.passingGrade;

    const labels = ranges.map(r => r.label);
    const dataCounts = ranges.map(range =>
        grades.filter(grade => grade >= range.min && grade <= range.max).length
    );
    const backgroundColors = ranges.map(range =>
        range.max < passingGrade ? 'rgba(231, 76, 60, 0.7)' : 'rgba(46, 204, 113, 0.7)' // Rojo si reprobado, verde si aprobado
    );
     const borderColors = ranges.map(range =>
        range.max < passingGrade ? 'rgba(231, 76, 60, 1)' : 'rgba(46, 204, 113, 1)'
    );


    appState.charts.groupChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'N√∫mero de Estudiantes',
                data: dataCounts,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'N√∫mero de Estudiantes' },
                    ticks: { precision: 0 } // Enteros en el eje Y
                },
                x: {
                    title: { display: true, text: 'Rango de Notas Finales' }
                }
            },
            plugins: {
                legend: { display: false },
                title: { display: true, text: 'Distribuci√≥n de Calificaciones Finales (Filtrado)' },
                tooltip: {
                    callbacks: { label: context => `Estudiantes: ${context.raw}` }
                }
            }
        }
    });
}

// Renderizar gr√°fico de competencias grupal
function renderCompetenceChart(students, compPerformance, filterCompetences = []) {
    if (!elements.competenceChart) return;
    const ctx = elements.competenceChart.getContext('2d');

    // Destruir gr√°fico anterior
    if (appState.charts.competenceChart) {
        appState.charts.competenceChart.destroy();
    }

    // Filtrar competencias a mostrar (las del filtro o todas si no hay filtro)
    let competencesToShow = utils.getUniqueCompetences();
    if (filterCompetences.length > 0) {
        competencesToShow = competencesToShow.filter(comp => filterCompetences.includes(comp));
    }

    // Filtrar competencias que tengan datos calculados
    competencesToShow = competencesToShow.filter(comp => compPerformance[comp] && compPerformance[comp].count > 0);

    if (competencesToShow.length === 0) {
        ctx.clearRect(0, 0, elements.competenceChart.width, elements.competenceChart.height);
        ctx.font = "14px Segoe UI";
        ctx.textAlign = "center";
        ctx.fillText("No hay datos de competencias para mostrar.", elements.competenceChart.width / 2, 50);
        return;
    }

    // Preparar datos
    const labels = competencesToShow;
    const averages = labels.map(comp => compPerformance[comp].average);
    const passRates = labels.map(comp => {
        const perf = compPerformance[comp];
        return perf.totalStudents > 0 ? (perf.passStudents / perf.totalStudents) * 100 : 0;
    });
    const passingGrade = appState.config.passingGrade;

    appState.charts.competenceChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Promedio',
                    data: averages,
                    backgroundColor: averages.map(avg => avg < passingGrade ? 'rgba(255, 193, 7, 0.7)' : 'rgba(52, 152, 219, 0.7)'), // Amarillo si < 3, Azul si >= 3
                    borderColor: averages.map(avg => avg < passingGrade ? 'rgba(255, 193, 7, 1)' : 'rgba(52, 152, 219, 1)'),
                    borderWidth: 1,
                    yAxisID: 'yAvg' // Eje izquierdo para promedio
                },
                {
                    label: 'Tasa Aprob. (%)',
                    data: passRates,
                    type: 'line', // L√≠nea para tasa de aprobaci√≥n
                    borderColor: 'rgba(46, 204, 113, 1)',
                    backgroundColor: 'rgba(46, 204, 113, 0.2)',
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'yRate' // Eje derecho para tasa
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                yAvg: { // Eje izquierdo
                    type: 'linear',
                    position: 'left',
                    beginAtZero: true,
                    suggestedMax: 5, // Nota m√°xima
                    title: { display: true, text: 'Promedio Nota' }
                },
                yRate: { // Eje derecho
                    type: 'linear',
                    position: 'right',
                    beginAtZero: true,
                    max: 100, // Porcentaje
                    title: { display: true, text: 'Tasa Aprobaci√≥n (%)' },
                    grid: { drawOnChartArea: false } // No dibujar rejilla para este eje
                },
                x: {
                    title: { display: true, text: 'Competencias' },
                     ticks: {
                        // Rotar etiquetas si son muchas o largas
                        // maxRotation: 90, minRotation: 45
                        autoSkip: false // Mostrar todas las etiquetas
                    }
                }
            },
            plugins: {
                title: { display: true, text: 'Rendimiento por Competencia (Grupo Completo)' },
                tooltip: { mode: 'index', intersect: false } // Mostrar tooltip para ambos datasets al pasar por √≠ndice
            }
        }
    });
}


// Renderizar reporte por evaluaci√≥n (usa auxiliar HTML y renderiza gr√°ficos)
function renderEvaluationReport(evalName, filterCompetences = []) {
    if (!elements.evaluationReportContainer) return;

    // 1. Renderizar Estad√≠sticas y Lista
    elements.evaluationReportContainer.innerHTML = generateEvaluationStatsHtml(evalName, filterCompetences);

    // 2. Renderizar Gr√°fico de Distribuci√≥n de Notas para esta evaluaci√≥n
    const students = appState.processedData.students || [];
    const evalData = students.map(student => ({
        grade: student[evalName] !== undefined && student[evalName] !== null && student[evalName] !== '' ? parseFloat(student[evalName]) : null
    })).filter(item => item.grade !== null);
    renderEvaluationChart(evalName, evalData);

    // 3. Renderizar Gr√°fico de Rendimiento por Competencia DENTRO de esta evaluaci√≥n
    const evalCompetences = appState.processedData.competenceMappings[evalName] || [];
    const competencesToShow = filterCompetences.length > 0 ? evalCompetences.filter(c => filterCompetences.includes(c)) : evalCompetences;
    if (competencesToShow.length > 0) {
        renderEvaluationCompetenceChart(evalName, evalData, competencesToShow);
    } else {
        // Limpiar gr√°fico si no hay competencias que mostrar
        if (appState.charts.evalCompetenceChart) {
            appState.charts.evalCompetenceChart.destroy();
            appState.charts.evalCompetenceChart = null;
             const ctx = elements.evalCompetenceChart?.getContext('2d');
             if(ctx) {
                ctx.clearRect(0, 0, elements.evalCompetenceChart.width, elements.evalCompetenceChart.height);
                ctx.font = "14px Segoe UI"; ctx.textAlign = "center";
                ctx.fillText("No hay competencias asociadas/filtradas.", elements.evalCompetenceChart.width / 2, 50);
             }
        }
    }
}


// Crear gr√°fico de distribuci√≥n para una evaluaci√≥n
function renderEvaluationChart(evalName, evalData) {
    if (!elements.evaluationChart) return;
    const ctx = elements.evaluationChart.getContext('2d');

    // Destruir gr√°fico anterior
    if (appState.charts.evaluationChart) {
        appState.charts.evaluationChart.destroy();
    }

    const grades = evalData.map(item => item.grade);

    if (grades.length === 0) {
        ctx.clearRect(0, 0, elements.evaluationChart.width, elements.evaluationChart.height);
        ctx.font = "14px Segoe UI"; ctx.textAlign = "center";
        ctx.fillText("No hay datos para mostrar el gr√°fico.", elements.evaluationChart.width / 2, 50);
        return;
    }

    // Rangos e intervalos
    const ranges = [
        { label: '0.0-0.9', min: 0.0, max: 0.99 },
        { label: '1.0-1.9', min: 1.0, max: 1.99 },
        { label: '2.0-2.9', min: 2.0, max: 2.99 },
        { label: '3.0-3.9', min: 3.0, max: 3.99 },
        { label: '4.0-5.0', min: 4.0, max: 5.0 }
    ];
    const passingGrade = appState.config.passingGrade;

    const labels = ranges.map(r => r.label);
    const dataCounts = ranges.map(range =>
        grades.filter(grade => grade >= range.min && grade <= range.max).length
    );
    const backgroundColors = ranges.map(range =>
        range.max < passingGrade ? 'rgba(231, 76, 60, 0.7)' : 'rgba(46, 204, 113, 0.7)'
    );
     const borderColors = ranges.map(range =>
        range.max < passingGrade ? 'rgba(231, 76, 60, 1)' : 'rgba(46, 204, 113, 1)'
    );

    appState.charts.evaluationChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: 'N√∫mero de Estudiantes',
                data: dataCounts,
                backgroundColor: backgroundColors,
                borderColor: borderColors,
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'N√∫mero de Estudiantes' },
                    ticks: { precision: 0 }
                },
                x: {
                    title: { display: true, text: `Rango de Notas - ${evalName}` }
                }
            },
            plugins: {
                legend: { display: false },
                title: { display: true, text: `Distribuci√≥n de Calificaciones - ${evalName}` },
                tooltip: {
                    callbacks: { label: context => `Estudiantes: ${context.raw}` }
                }
            }
        }
    });
}

// Crear gr√°fico de rendimiento por competencia EN evaluaci√≥n
function renderEvaluationCompetenceChart(evalName, evalData, competences) {
    if (!elements.evalCompetenceChart) return;
    const ctx = elements.evalCompetenceChart.getContext('2d');

    // Destruir gr√°fico anterior
    if (appState.charts.evalCompetenceChart) {
        appState.charts.evalCompetenceChart.destroy();
    }

    // Calcular rendimiento por competencia EN esta evaluaci√≥n
    const compPerformance = utils.calculateEvaluationCompetencePerformance(
        appState.processedData.students, // Pasar todos los estudiantes
        evalName
    );

    // Filtrar las competencias que realmente se van a mostrar
    const labels = competences.filter(comp => compPerformance[comp] && compPerformance[comp].totalStudents > 0);

    if (labels.length === 0) {
        ctx.clearRect(0, 0, elements.evalCompetenceChart.width, elements.evalCompetenceChart.height);
        ctx.font = "14px Segoe UI"; ctx.textAlign = "center";
        ctx.fillText("No hay datos de competencias para esta evaluaci√≥n.", elements.evalCompetenceChart.width / 2, 50);
        return;
    }

    const averages = labels.map(comp => compPerformance[comp].average);
    const passRates = labels.map(comp => {
        const perf = compPerformance[comp];
        return perf.totalStudents > 0 ? (perf.passStudents / perf.totalStudents) * 100 : 0;
    });
     const passingGrade = appState.config.passingGrade;

    appState.charts.evalCompetenceChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'Promedio',
                    data: averages,
                    backgroundColor: averages.map(avg => avg < passingGrade ? 'rgba(255, 193, 7, 0.7)' : 'rgba(52, 152, 219, 0.7)'),
                    borderColor: averages.map(avg => avg < passingGrade ? 'rgba(255, 193, 7, 1)' : 'rgba(52, 152, 219, 1)'),
                    borderWidth: 1,
                    yAxisID: 'yAvg'
                },
                {
                    label: 'Tasa Aprob. (%)',
                    data: passRates,
                    type: 'line',
                    borderColor: 'rgba(46, 204, 113, 1)',
                    backgroundColor: 'rgba(46, 204, 113, 0.2)',
                    fill: false,
                    tension: 0.1,
                    yAxisID: 'yRate'
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                yAvg: {
                    type: 'linear', position: 'left', beginAtZero: true, suggestedMax: 5,
                    title: { display: true, text: 'Promedio Nota' }
                },
                yRate: {
                    type: 'linear', position: 'right', beginAtZero: true, max: 100,
                    title: { display: true, text: 'Tasa Aprobaci√≥n (%)' },
                    grid: { drawOnChartArea: false }
                },
                x: {
                    title: { display: true, text: 'Competencias' }
                }
            },
            plugins: {
                title: { display: true, text: `Rendimiento por Competencia - ${evalName}` },
                tooltip: { mode: 'index', intersect: false }
            }
        }
    });
}


// Renderizar p√°gina de l√≠nea de tiempo (actualiza selectores y llama a renderTimeline)
function renderTimelinePage() {
    if (!elements.timelineStudentSelect || !elements.timelineCompetenceFilter) return;

    // Actualizar selector de estudiantes
    const studentOptionsHtml = (appState.processedData.students || [])
        .map(s => `<option value="${s.id}">${s.Nombre}</option>`).join('');
    elements.timelineStudentSelect.innerHTML = '<option value="group">Rendimiento grupal</option>' + studentOptionsHtml;
    elements.timelineStudentSelect.value = appState.filters.timeline.student || 'group'; // Restaurar

    // Actualizar selector de competencias
    const uniqueCompetences = utils.getUniqueCompetences();
    const competenceOptionsHtml = uniqueCompetences.map(comp => `<option value="${comp}">${comp}</option>`).join('');
    elements.timelineCompetenceFilter.innerHTML = '<option value="all">Todas las competencias</option>' + competenceOptionsHtml;
    elements.timelineCompetenceFilter.value = appState.filters.timeline.competence || 'all'; // Restaurar

    // Renderizar la l√≠nea de tiempo con los filtros actuales
    renderTimeline(
        appState.filters.timeline.student || 'group',
        appState.filters.timeline.competence || 'all'
    );
}

// Renderizar l√≠nea de tiempo (ahora usa funci√≥n auxiliar HTML)
function renderTimeline(studentId, competenceFilter = 'all') {
    if (!elements.evaluationTimeline) return;
    elements.evaluationTimeline.innerHTML = generateTimelineHtml(studentId, competenceFilter);
}


// Inicializar la aplicaci√≥n
function initApp() {
    console.log("Inicializando aplicaci√≥n...");

    // Event listeners para tabs
    elements.tabs.forEach(tab => {
        tab.addEventListener('click', eventHandlers.tabClick);
    });

    // Event listeners para carga de archivos
    elements.studentsFile?.addEventListener('change', eventHandlers.studentsFileChange);
    elements.competencesFile?.addEventListener('change', eventHandlers.competencesFileChange);
    // Asegurar que el listener del bot√≥n se a√±ade una sola vez y al bot√≥n correcto
    const loadBtn = document.getElementById('loadFilesBtn'); // Obtener referencia directa
    if (loadBtn) {
        // Remover listener previo si existe (m√°s seguro)
        const newLoadBtn = loadBtn.cloneNode(true);
        loadBtn.parentNode.replaceChild(newLoadBtn, loadBtn);
        elements.loadFilesBtn = newLoadBtn; // Actualizar referencia en elements
        newLoadBtn.addEventListener('click', eventHandlers.loadFiles);
        newLoadBtn.disabled = true; // Deshabilitar inicialmente
    }


    // Event listeners para configuraci√≥n
    elements.groupSelect?.addEventListener('change', eventHandlers.groupChange);
    elements.competenceSheetSelect?.addEventListener('change', renderCompetenceMapping); // Hoja afecta mapeo
    elements.decimalPlaces?.addEventListener('input', () => {
        const value = parseInt(elements.decimalPlaces.value);
        if (!isNaN(value) && value >= 0) appState.config.decimalPlaces = value;
        else elements.decimalPlaces.value = appState.config.decimalPlaces; // Revertir si inv√°lido
    });
    elements.passingGrade?.addEventListener('input', () => {
        const value = parseFloat(elements.passingGrade.value);
         if (!isNaN(value) && value >= 0 && value <= 5) appState.config.passingGrade = value; // Asumiendo max 5
         else elements.passingGrade.value = appState.config.passingGrade; // Revertir si inv√°lido
    });
    elements.semesterSelect?.addEventListener('change', () => {
        appState.config.semester = elements.semesterSelect.value;
    });
    elements.distributeWeightsBtn?.addEventListener('click', eventHandlers.distributeWeights);
    elements.clearWeightsBtn?.addEventListener('click', eventHandlers.clearWeights);
    elements.saveConfigBtn?.addEventListener('click', eventHandlers.saveConfig);

    // Event listeners para mapeo de competencias
    elements.competenceMappingGroup?.addEventListener('change', renderCompetenceMapping); // Grupo afecta mapeo? (Revisar l√≥gica si es necesario)
    elements.updateMappingBtn?.addEventListener('click', eventHandlers.updateCompetenceMapping);

    // Event listeners para reporte individual
    elements.studentSearch?.addEventListener('input', _.debounce(eventHandlers.searchStudent, 300)); // Debounce para no buscar en cada tecla
    // Los listeners para filtros de competencia y fecha se a√±aden en initializeCompetenceFilters e initializeDatepickers

    // Event listeners para reporte grupal
    elements.performanceFilter?.addEventListener('change', eventHandlers.filterByPerformance);
    elements.competenceFilter?.addEventListener('change', eventHandlers.filterByPerformance);
    // Los listeners para filtros de fecha se a√±aden en initializeDatepickers

    // Event listeners para reporte por evaluaci√≥n
    elements.evaluationSelect?.addEventListener('change', eventHandlers.selectEvaluation);
    elements.evalCompetenceFilter?.addEventListener('change', eventHandlers.filterEvaluationByCompetence);

    // Event listeners para l√≠nea de tiempo
    elements.timelineStudentSelect?.addEventListener('change', eventHandlers.selectTimelineStudent);
    elements.timelineCompetenceFilter?.addEventListener('change', eventHandlers.filterTimelineByCompetence);

    // Event listeners para botones de exportaci√≥n/impresi√≥n (agrupados por reporte)
    // Individual
    elements.previewIndividualBtn?.addEventListener('click', eventHandlers.previewIndividualReport);
    elements.exportPdfBtn?.addEventListener('click', eventHandlers.exportIndividualPdf);
    elements.exportExcelBtn?.addEventListener('click', eventHandlers.exportIndividualExcel);
    elements.printBtn?.addEventListener('click', eventHandlers.printIndividualReport);
    // Grupal
    elements.previewGroupBtn?.addEventListener('click', eventHandlers.previewGroupReport);
    elements.exportGroupPdfBtn?.addEventListener('click', eventHandlers.exportGroupPdf);
    elements.exportGroupExcelBtn?.addEventListener('click', eventHandlers.exportGroupExcel);
    elements.printGroupBtn?.addEventListener('click', eventHandlers.printGroupReport);
    // Evaluaci√≥n
    elements.previewEvalBtn?.addEventListener('click', eventHandlers.previewEvaluationReport);
    elements.exportEvalPdfBtn?.addEventListener('click', eventHandlers.exportEvaluationPdf);
    elements.exportEvalExcelBtn?.addEventListener('click', eventHandlers.exportEvaluationExcel);
    elements.printEvalBtn?.addEventListener('click', eventHandlers.printEvaluationReport);
    // L√≠nea de Tiempo
    elements.previewTimelineBtn?.addEventListener('click', eventHandlers.previewTimelineReport);
    elements.exportTimelinePdfBtn?.addEventListener('click', eventHandlers.exportTimelinePdf);
    elements.printTimelineBtn?.addEventListener('click', eventHandlers.printTimelineReport);

    // Event listeners para previsualizaci√≥n
    elements.previewClose?.addEventListener('click', eventHandlers.closePreview);
    elements.cancelPreviewBtn?.addEventListener('click', eventHandlers.closePreview);
    elements.confirmExportBtn?.addEventListener('click', eventHandlers.confirmExport);

    // Inicializar estado de botones y UI
    eventHandlers.checkFilesLoaded(); // Deshabilitar bot√≥n de carga si no hay archivos
    // Ocultar secciones de reporte inicialmente
    // ... (c√≥digo si es necesario para ocultar reportes hasta que haya datos)

    console.log("Aplicaci√≥n inicializada.");
}

// Iniciar la aplicaci√≥n cuando el DOM est√© cargado
document.addEventListener('DOMContentLoaded', initApp);


// --- C√≥digo del Modal de Competencias (Parece estar fuera de initApp, lo dejamos as√≠) ---
// 1. MODAL PARA ASOCIAR COMPETENCIAS (Este c√≥digo parece estar a√±adido al final, lo mantenemos pero revisamos)
if (!document.getElementById('competenceModal')) {
    const competenceModal = document.createElement('div');
    competenceModal.id = 'competenceModal';
    // Estilos b√°sicos para el modal
    competenceModal.style.cssText = `
        display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background-color: rgba(0,0,0,0.5); z-index: 2000;
        justify-content: center; align-items: center;
    `;
    competenceModal.innerHTML = `
      <div id="competenceModalContent" style="background:#fff; width: 90%; max-width: 500px; max-height: 80vh; overflow-y: auto; padding: 20px; border-radius: 8px; box-shadow: 0 5px 15px rgba(0,0,0,0.3); display: flex; flex-direction: column;">
        <h3 style="margin-top: 0; margin-bottom: 15px; color: var(--primary-color);">Asociar competencias a <span id="modalEvalName"></span></h3>
        <div id="competenceModalList" style="flex-grow: 1; overflow-y: auto; margin-bottom: 15px; border: 1px solid #eee; padding: 10px;">
            <!-- Checkboxes se a√±adir√°n aqu√≠ -->
        </div>
        <div style="text-align: right; margin-top: 10px;">
          <button id="competenceModalCancel" class="btn btn-warning btn-sm">Cancelar</button>
          <button id="competenceModalSave" class="btn btn-success btn-sm" style="margin-left: 10px;">Guardar</button>
        </div>
      </div>`;
    document.body.appendChild(competenceModal);

    // Variable global para el modal (mejor evitar global si es posible, pero mantenemos estructura)
    let currentEvalForCompetenceModal = null;

    // Funci√≥n para abrir el modal
    window.openCompetenceModal = function(evalName) { // Hacerla global para que onclick funcione
        currentEvalForCompetenceModal = evalName;
        const modal = document.getElementById('competenceModal');
        const list = document.getElementById('competenceModalList');
        const title = document.getElementById('modalEvalName');
        if (!modal || !list || !title) return;

        title.textContent = evalName;
        list.innerHTML = ''; // Limpiar lista

        const uniqueCompetences = utils.getUniqueCompetences();
        const mapped = appState.processedData.competenceMappings[evalName] || [];

        if (uniqueCompetences.length === 0) {
            list.innerHTML = 'No hay competencias disponibles.';
        } else {
            uniqueCompetences.forEach(comp => {
                const id = `modal-comp-${evalName}-${comp.replace(/\s+/g, '-')}`;
                const label = document.createElement('label');
                label.style.display = 'block';
                label.style.marginBottom = '8px';
                label.style.cursor = 'pointer';
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = id;
                checkbox.value = comp;
                checkbox.checked = mapped.includes(comp);
                checkbox.style.marginRight = '8px';
                label.appendChild(checkbox);
                label.appendChild(document.createTextNode(comp));
                list.appendChild(label);
            });
        }
        modal.style.display = 'flex'; // Mostrar modal (usando flex para centrar)
    }

    // Listeners para botones del modal (dentro del DOMContentLoaded para asegurar que existen)
    document.addEventListener('DOMContentLoaded', function() {
        const modal = document.getElementById('competenceModal');
        if (modal) {
            document.getElementById('competenceModalCancel').onclick = () => {
                modal.style.display = 'none';
                currentEvalForCompetenceModal = null;
            };
            document.getElementById('competenceModalSave').onclick = () => {
                if (!currentEvalForCompetenceModal) return;
                const checks = document.querySelectorAll('#competenceModalList input[type=checkbox]');
                const newMappedCompetences = [];
                checks.forEach(chk => {
                    if (chk.checked) newMappedCompetences.push(chk.value);
                });
                // Actualizar estado
                appState.processedData.competenceMappings[currentEvalForCompetenceModal] = newMappedCompetences;
                console.log(`Mapeo guardado para ${currentEvalForCompetenceModal}:`, newMappedCompetences);
                modal.style.display = 'none';
                currentEvalForCompetenceModal = null;
                // Re-renderizar la pesta√±a de mapeo si est√° activa
                if (document.getElementById('mapping')?.classList.contains('active')) {
                    renderCompetenceMapping();
                }
                 // Re-renderizar la pesta√±a de config si est√° activa (para reflejar en checkboxes all√≠)
                 if (document.getElementById('config')?.classList.contains('active')) {
                     eventHandlers.fieldSelectionChange(); // Esto deber√≠a refrescar los checkboxes en config
                 }
            };
             // Cerrar modal si se hace clic fuera del contenido
             modal.addEventListener('click', (event) => {
                if (event.target === modal) { // Si el clic fue en el fondo oscuro
                    modal.style.display = 'none';
                    currentEvalForCompetenceModal = null;
                }
            });
        }
    });
}
// --- FIN C√≥digo del Modal ---


// Diagn√≥stico para depuraci√≥n del reporte grupal (Lo dejamos como estaba)
function diagnosticoReporteGrupal() {
  try {
    const grupo = appState.config.selectedGroup;
    const estudiantes = appState.processedData.students || [];
    const evaluaciones = appState.processedData.evaluations || [];
    const pesos = appState.config.weights || {};
    const mapeo = appState.processedData.competenceMappings || {};
    console.log('--- DIAGN√ìSTICO REPORTE GRUPAL ---');
    console.log('Grupo seleccionado:', grupo);
    console.log('Estudiantes procesados:', estudiantes.length);
    console.log('Evaluaciones:', evaluaciones);
    console.log('Pesos:', pesos);
    console.log('Mapeo de competencias por evaluaci√≥n:', mapeo);
    console.log('Filtros Grupales Actuales:', appState.filters.group);
    console.log('-----------------------------------');
  } catch (e) {
    console.error('Error en diagn√≥stico de reporte grupal:', e);
  }
}

// Sobrescribir el handler de tabs para a√±adir el diagn√≥stico (si eventHandlers existe)
if (typeof eventHandlers !== 'undefined' && eventHandlers.tabClick) {
    const originalTabClickHandler = eventHandlers.tabClick;
    eventHandlers.tabClick = function(e) { // Usar 'e' del evento original
        const tabId = e.target.getAttribute('data-tab'); // Obtener tabId del evento
        if (tabId === 'group') {
            // Llamar diagn√≥stico ANTES de que el handler original intente renderizar
            diagnosticoReporteGrupal();
        }
        // Llamar al handler original
        originalTabClickHandler.call(this, e); // Pasar el evento original
    };
} else {
     console.warn("eventHandlers.tabClick no est√° definido al intentar a√±adir diagn√≥stico.");
}


</script>
</body>
</html>